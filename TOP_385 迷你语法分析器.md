# 题目

给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 `NestedInteger` 。

列表中的每个元素只可能是整数或整数嵌套列表

**示例 1：**

```
输入：s = "324",
输出：324
解释：你应该返回一个 NestedInteger 对象，其中只包含整数值 324。
```

**示例 2：**

```
输入：s = "[123,[456,[789]]]",
输出：[123,[456,[789]]]
解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：
1. 一个 integer 包含值 123
2. 一个包含两个元素的嵌套列表：
    i.  一个 integer 包含值 456
    ii. 一个包含一个元素的嵌套列表
         a. 一个 integer包含值 789
```

**提示：**

- $1 <= s.length <= 5 * 10^4$
- `s` 由数字、方括号 `"[]"`、负号 `'-'` 、逗号 `','`组成
- 用例保证 `s` 是可解析的 `NestedInteger`
- 输入中的所有值的范围是$ [-10^6, 10^6]$

## 我的解法

解法的思路较为容易，但是代码书写经常处理不到位！

```python
# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger:
#    def __init__(self, value=None):
#        """
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        """
#
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def add(self, elem):
#        """
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        """
#
#    def setInteger(self, value):
#        """
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """
class Solution:
    def deserialize(self, s: str) -> NestedInteger:

        def takeOut(s):
            print(s)
            if s[0] != '[':
                mid = int(s)
                return NestedInteger(mid)
            else:
                sl = len(s)
                if sl == 2:
                    return NestedInteger()
                else:
                    res = NestedInteger()
                    s = s[1: sl - 1]
                    mid = ""
                    flag = 0
                    for i in s:
                        if i == ',' and flag == 0:
                            resMid = takeOut(mid)
                            res.add(resMid)
                            mid = ""
                        elif i == '[':
                            flag += 1
                            mid += i
                        elif i == ']':
                            flag -= 1
                            mid += i
                        else:
                            mid += i
                    resMid = takeOut(mid)
                    res.add(resMid) 
                    return res
        ans = takeOut(s)
        return ans
```

## 其他解法

### 深度优先搜索

```c++
class Solution {
public:
    int index = 0;

    NestedInteger deserialize(string s) {
        if (s[index] == '[') {
            index++;
            NestedInteger ni;
            while (s[index] != ']') {
                ni.add(deserialize(s));
                if (s[index] == ',') {
                    index++;
                }
            }
            index++;
            return ni;
        } else {
            bool negative = false;
            if (s[index] == '-') {
                negative = true;
                index++;
            }
            int num = 0;
            while (index < s.size() && isdigit(s[index])) {
                num = num * 10 + s[index] - '0';
                index++;
            }
            if (negative) {
                num *= -1;
            }
            return NestedInteger(num);
        }
    }
};
```

```java
class Solution {
    int index = 0;

    public NestedInteger deserialize(String s) {
        if (s.charAt(index) == '[') {
            index++;
            NestedInteger ni = new NestedInteger();
            while (s.charAt(index) != ']') {
                ni.add(deserialize(s));
                if (s.charAt(index) == ',') {
                    index++;
                }
            }
            index++;
            return ni;
        } else {
            boolean negative = false;
            if (s.charAt(index) == '-') {
                negative = true;
                index++;
            }
            int num = 0;
            while (index < s.length() && Character.isDigit(s.charAt(index))) {
                num = num * 10 + s.charAt(index) - '0';
                index++;
            }
            if (negative) {
                num *= -1;
            }
            return new NestedInteger(num);
        }
    }
}
```

```python
class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        index = 0

        def dfs() -> NestedInteger:
            nonlocal index
            if s[index] == '[':
                index += 1
                ni = NestedInteger()
                while s[index] != ']':
                    ni.add(dfs())
                    if s[index] == ',':
                        index += 1
                index += 1
                return ni
            else:
                negative = False
                if s[index] == '-':
                    negative = True
                    index += 1
                num = 0
                while index < len(s) and s[index].isdigit():
                    num *= 10
                    num += int(s[index])
                    index += 1
                if negative:
                    num = -num
                return NestedInteger(num)

        return dfs()
```

#### 思路

根据题意，一个$ \texttt{NestedInteger}$实例只能包含下列两部分之一：1）一个整数；2）一个列表，列表中的每个元素都是一个 $\texttt{NestedInteger}$实例。据此，$\texttt{NestedInteger}$是通过递归定义的，因此也可以用递归的方式来解析。

从左至右遍历 s，

如果第一位是 $\texttt{'['}$ 字符，则表示待解析的是一个列表，从 $\texttt{'['}$ 后面的字符开始又是一个新的 $\texttt{NestedInteger}$实例，我们仍调用解析函数来解析列表的元素，调用结束后如果遇到的是 , 字符，表示列表仍有其他元素，需要继续调用。如果是 $\texttt{']'}$ 字符，表示这个列表已经解析完毕，可以返回 $\texttt{NestedInteger}$实例。

否则，则表示待解析的 $\texttt{NestedInteger}$只包含一个整数。我们可以从左至右解析这个整数，并注意是否是负数，直到遍历完或者遇到非数字字符（$\texttt{`]'}$ 或 $\texttt{','}$），并返回 $\texttt{NestedInteger}$实例。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是 s 的长度。我们需要遍历 ss 的每一位来解析。

- 空间复杂度：O(n)，其中 n 是 s 的长度。深度优先搜索的深度最多为 O(n)，需要 O(n)的栈空间


### 栈

```c++
class Solution {
public:
    NestedInteger deserialize(string s) {
        if (s[0] != '[') {
            return NestedInteger(stoi(s));
        }
        stack<NestedInteger> st;
        int num = 0;
        bool negative = false;
        for (int i = 0; i < s.size(); i++) {
            char c = s[i];
            if (c == '-') {
                negative = true;
            } else if (isdigit(c)) {
                num = num * 10 + c - '0';
            } else if (c == '[') {
                st.emplace(NestedInteger());
            } else if (c == ',' || c == ']') {
                if (isdigit(s[i - 1])) {
                    if (negative) {
                        num *= -1;
                    }
                    st.top().add(NestedInteger(num));
                }
                num = 0;
                negative = false;
                if (c == ']' && st.size() > 1) {
                    NestedInteger ni = st.top();
                    st.pop();
                    st.top().add(ni);
                }
            }
        }
        return st.top();
    }
};
```

```java
class Solution {
    public NestedInteger deserialize(String s) {
        if (s.charAt(0) != '[') {
            return new NestedInteger(Integer.parseInt(s));
        }
        Deque<NestedInteger> stack = new ArrayDeque<NestedInteger>();
        int num = 0;
        boolean negative = false;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '-') {
                negative = true;
            } else if (Character.isDigit(c)) {
                num = num * 10 + c - '0';
            } else if (c == '[') {
                stack.push(new NestedInteger());
            } else if (c == ',' || c == ']') {
                if (Character.isDigit(s.charAt(i - 1))) {
                    if (negative) {
                        num *= -1;
                    }
                    stack.peek().add(new NestedInteger(num));
                }
                num = 0;
                negative = false;
                if (c == ']' && stack.size() > 1) {
                    NestedInteger ni = stack.pop();
                    stack.peek().add(ni);
                }
            }
        }
        return stack.pop();
    }
}
```

```python
class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        if s[0] != '[':
            return NestedInteger(int(s))
        stack, num, negative = [], 0, False
        for i, c in enumerate(s):
            if c == '-':
                negative = True
            elif c.isdigit():
                num = num * 10 + int(c)
            elif c == '[':
                stack.append(NestedInteger())
            elif c in ',]':
                if s[i-1].isdigit():
                    if negative:
                        num = -num
                    stack[-1].add(NestedInteger(num))
                num, negative = 0, False
                if c == ']' and len(stack) > 1:
                    stack[-2].add(stack.pop())
        return stack.pop()
```

#### 思路

上述递归的思路也可以用栈来模拟。从左至右遍历 s，如果遇到 $\texttt{'['}$，则表示是一个新的 $\texttt{NestedInteger}$实例，需要将其入栈。如果遇到 $\texttt{']'}$ 或 $\texttt{','}$，则表示是一个数字或者 $\texttt{NestedInteger}$实例的结束，需要将其添加入栈顶的 $\texttt{NestedInteger}$实例。最后需返回栈顶的实例。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是 s 的长度。我们需要遍历 s 的每一位来解析。

- 空间复杂度：O(n)，其中 n 是 s 的长度。栈的深度最多为 O(n)。


