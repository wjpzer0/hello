# 题目

环形公交路线上有 `n` 个站，按次序从 `0` 到 `n - 1` 进行编号。我们已知每一对相邻公交站之间的距离，`distance[i]` 表示编号为 `i` 的车站和编号为 `(i + 1) % n` 的车站之间的距离。

环线上的公交车都可以按顺时针和逆时针的方向行驶。

返回乘客从出发点 `start` 到目的地 `destination` 之间的最短距离。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg)

```
输入：distance = [1,2,3,4], start = 0, destination = 1
输出：1
解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。
```

 

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg)

```
输入：distance = [1,2,3,4], start = 0, destination = 2
输出：3
解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。
```

 

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg)

```
输入：distance = [1,2,3,4], start = 0, destination = 3
输出：4
解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。
```

**提示：**

- $1 <= n <= 10^4$
- `distance.length == n`
- `0 <= start, destination < n`
- $0 <= distance[i] <= 10^4$

## 我的解法

思路有点憨批！

```python
class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        n = len(distance)
        i = start 
        j = start
        forward = 0
        back = 0
        while i != destination or j != destination:
            if i != destination:
                forward += distance[i]
                i += 1
                if i == n:
                    i = 0
            if j != destination:
                if j == 0:
                    j = n
                j -= 1
                back += distance[j]
        return min(forward, back)
```

## 其他解法

### 一次遍历

```c++
class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        if (start > destination) {
            swap(start, destination);
        }
        return min(accumulate(distance.begin() + start, distance.begin() + destination, 0),
                   accumulate(distance.begin(), distance.begin() + start, 0) +
                   accumulate(distance.begin() + destination, distance.end(), 0));
    }
};
```

```java
class Solution {
    public int distanceBetweenBusStops(int[] distance, int start, int destination) {
        if (start > destination) {
            int temp = start;
            start = destination;
            destination = temp;
        }
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < distance.length; i++) {
            if (i >= start && i < destination) {
                sum1 += distance[i];
            } else {
                sum2 += distance[i];
            }
        }
        return Math.min(sum1, sum2);
    }
}
```

```python
class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        if start > destination:
            start, destination = destination, start
        return min(sum(distance[start:destination]), sum(distance[:start]) + sum(distance[destination:]))
```

记数组 $\textit{distance}$的长度为 n。假设$ \textit{start} \le \textit{destination}$，那么我们可以：

从 $\textit{start}$ 到 $\textit{destination}$，距离为 $\sum\limits_{i=\textit{start}}^{\textit{destination}-1}\textit{distance}[i] $；
从 $\textit{start}$到 0，再从 0 到 $\textit{destination}$，距离为$ \sum\limits_{i=0}^{\textit{start}-1}\textit{distance}[i]+\sum\limits_{i=\textit{destination}}^{n-1}\textit{distance}[i] $。
答案为这两个距离的最小值。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是数组 $\textit{distance}$的长度。

- 空间复杂度：O(1)，只需要额外的常数级别的空间。


