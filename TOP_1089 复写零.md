# 题目

给你一个长度固定的整数数组 `arr`，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。

注意：请不要在超过该数组长度的位置写入元素。

要求：请对输入的数组 **就地** 进行上述修改，不要从函数返回任何东西。

**示例 1：**

```
输入：[1,0,2,3,0,4,5,0]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
```

**示例 2：**

```
输入：[1,2,3]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,2,3]
```

**提示：**

1. `1 <= arr.length <= 10000`
2. `0 <= arr[i] <= 9`

## 我的解法

使用了额外的空间，没有做到O(1)!

```python
class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """
        Do not return anything, modify arr in-place instead.
        """
        n = len(arr)
        res = []
        for num in arr:
            res.append(num)
            if num == 0:
                res.append(0)
        print(res)
        for i in range(n):
            arr[i] = res[i]
```

## 其他解法

### 双指针

```c++
class Solution {
public:
    void duplicateZeros(vector<int>& arr) {
        int n = arr.size();
        int top = 0;
        int i = -1;
        while (top < n) {
            i++;
            if (arr[i] != 0) {
                top++;
            } else {
                top += 2;
            }
        }
        int j = n - 1;
        if (top == n + 1) {
            arr[j] = 0;
            j--;
            i--;
        } 
        while (j >= 0) {
            arr[j] = arr[i];
            j--;
            if (!arr[i]) {
                arr[j] = arr[i];
                j--;
            } 
            i--;
        }
    }
};
```

```java
class Solution {
    public void duplicateZeros(int[] arr) {
        int n = arr.length;
        int top = 0;
        int i = -1;
        while (top < n) {
            i++;
            if (arr[i] != 0) {
                top++;
            } else {
                top += 2;
            }
        }
        int j = n - 1;
        if (top == n + 1) {
            arr[j] = 0;
            j--;
            i--;
        } 
        while (j >= 0) {
            arr[j] = arr[i];
            j--;
            if (arr[i] == 0) {
                arr[j] = arr[i];
                j--;
            } 
            i--;
        }
    }
}
```

```python
class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        n = len(arr)
        top = 0
        i = -1
        while top < n:
            i += 1
            top += 1 if arr[i] else 2
        j = n - 1
        if top == n + 1:
            arr[j] = 0
            j -= 1
            i -= 1
        while j >= 0:
            arr[j] = arr[i]
            j -= 1
            if arr[i] == 0:
                arr[j] = arr[i]
                j -= 1
            i -= 1
```

#### 思路与算法

首先如果没有原地修改的限制，那么我们可以另开辟一个栈来进行模拟放置：

![img](https://assets.leetcode-cn.com/solution-static/1089/1.png)
![img](https://assets.leetcode-cn.com/solution-static/1089/2.png)
![img](https://assets.leetcode-cn.com/solution-static/1089/3.png)
![img](https://assets.leetcode-cn.com/solution-static/1089/4.png)
![img](https://assets.leetcode-cn.com/solution-static/1089/5.png)
![img](https://assets.leetcode-cn.com/solution-static/1089/6.png)
![img](https://assets.leetcode-cn.com/solution-static/1089/7.png)
![img](https://assets.leetcode-cn.com/solution-static/1089/8.png)
![img](https://assets.leetcode-cn.com/solution-static/1089/9.png)
![img](https://assets.leetcode-cn.com/solution-static/1089/10.png)

而实际上我们可以不需要开辟栈空间来模拟放置元素，我们只需要用两个指针来进行标记栈顶位置和现在需要放置的元素位置即可。我们用 $\textit{top}$来标记栈顶位置，用 i 来标记现在需要放置的元素位置，那么我们找到原数组中对应放置在最后位置的元素位置，然后在数组最后从该位置元素往前来进行模拟放置即可。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为数组 $\textit{arr}$的长度。需要遍历两遍数组。

- 空间复杂度：O(1)，仅使用常量空间。

