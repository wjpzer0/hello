# 题目

**完全二叉树** 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。

设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。

实现 `CBTInserter` 类:

- `CBTInserter(TreeNode root)` 使用头节点为 `root` 的给定树初始化该数据结构；
- `CBTInserter.insert(int v)` 向树中插入一个值为 `Node.val == val`的新节点 `TreeNode`。使树保持完全二叉树的状态，**并返回插入节点** `TreeNode` **的父节点的值**；
- `CBTInserter.get_root()` 将返回树的头节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg)

```
输入
["CBTInserter", "insert", "insert", "get_root"]
[[[1, 2]], [3], [4], []]
输出
[null, 1, 2, [1, 2, 3, 4]]

解释
CBTInserter cBTInserter = new CBTInserter([1, 2]);
cBTInserter.insert(3);  // 返回 1
cBTInserter.insert(4);  // 返回 2
cBTInserter.get_root(); // 返回 [1, 2, 3, 4]
```

**提示：**

- 树中节点数量范围为 `[1, 1000]` 
- `0 <= Node.val <= 5000`
- `root` 是完全二叉树
- `0 <= val <= 5000` 
- 每个测试用例最多调用 `insert` 和 `get_root` 操作 `104` 次

## 我的解法

思路正确，但还可以优化！

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class CBTInserter:

    def __init__(self, root: TreeNode):
        self.nodeList = [0]
        self.nodeList.append(root)
        q = deque()
        q.append(root)
        while q:
            mid = q.popleft()
            if mid.left:
                q.append(mid.left)
                self.nodeList.append(mid.left)
            if mid.right:
                q.append(mid.right)
                self.nodeList.append(mid.right)

    def insert(self, val: int) -> int:
        n = len(self.nodeList)
        node = TreeNode(val)
        if n % 2 == 0:
            self.nodeList[n // 2].left = node
        else:
            self.nodeList[n // 2].right = node
        self.nodeList.append(node)
        return self.nodeList[n // 2].val

    def get_root(self) -> TreeNode:
        return self.nodeList[1]

# Your CBTInserter object will be instantiated and called as such:
# obj = CBTInserter(root)
# param_1 = obj.insert(val)
# param_2 = obj.get_root()
```

## 其他解法

### 队列

```c++
class CBTInserter {
public:
    CBTInserter(TreeNode* root) {
        this->root = root;

        queue<TreeNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();
            if (node->left) {
                q.push(node->left);
            }
            if (node->right) {
                q.push(node->right);
            }
            if (!(node->left && node->right)) {
                candidate.push(node);
            }
        }
    }
    
    int insert(int val) {
        TreeNode* child = new TreeNode(val);
        TreeNode* node = candidate.front();
        int ret = node->val;
        if (!node->left) {
            node->left = child;
        }
        else {
            node->right = child;
            candidate.pop();
        }
        candidate.push(child);
        return ret;
    }
    
    TreeNode* get_root() {
        return root;
    }

private:
    queue<TreeNode*> candidate;
    TreeNode* root;
};
```

```java
class CBTInserter {
    Queue<TreeNode> candidate;
    TreeNode root;

    public CBTInserter(TreeNode root) {
        this.candidate = new ArrayDeque<TreeNode>();
        this.root = root;

        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
            if (!(node.left != null && node.right != null)) {
                candidate.offer(node);
            }
        }
    }

    public int insert(int val) {
        TreeNode child = new TreeNode(val);
        TreeNode node = candidate.peek();
        int ret = node.val;
        if (node.left == null) {
            node.left = child;
        } else {
            node.right = child;
            candidate.poll();
        }
        candidate.offer(child);
        return ret;
    }

    public TreeNode get_root() {
        return root;
    }
}
```

```python
class CBTInserter:

    def __init__(self, root: TreeNode):
        self.root = root
        self.candidate = deque()

        q = deque([root])
        while q:
            node = q.popleft()
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
            if not (node.left and node.right):
                self.candidate.append(node)

    def insert(self, val: int) -> int:
        candidate_ = self.candidate

        child = TreeNode(val)
        node = candidate_[0]
        ret = node.val
        
        if not node.left:
            node.left = child
        else:
            node.right = child
            candidate_.popleft()
        
        candidate_.append(child)
        return ret

    def get_root(self) -> TreeNode:
        return self.root
```

#### 思路与算法

对于一棵完全二叉树而言，其除了最后一层之外都是完全填充的，并且最后一层的节点全部在最左侧。那么，只有倒数第二层（如果存在）最右侧的若干个节点，以及最后一层的全部节点可以再添加子节点，其余的节点都已经拥有两个子节点。

因此，我们可以使用一个队列存储上述提到的这些可以添加子节点的节点。队列中的存储顺序为：首先「从左往右」存储倒数第二层最右侧的节点，再「从左往右」存储最后一层的全部节点。这一步可以使用广度优先搜索来完成，因为广度优先搜索就是按照层优先进行遍历的。

随后，当我们每次调用 $\text{insert(val)} $时，我们就创建出一个节点 $\textit{child}$，并将它最为队列的队首节点的子节点。在这之后，我们需要把$ \textit{child}$加入队尾，并且如果对队首节点已经有两个子节点，我们需要将其从队列中移除。

#### 复杂度分析

时间复杂度：初始化 $\text{CBTInserter(root)} $需要的时间为 O(n)，其中 n 是给定的初始完全二叉树的节点个数。$\text{insert(v)}$ 和 $\text{get\_root()}$ 的时间复杂度均为 O(1)。

空间复杂度：O(n+q)，其中 q 是 $\text{insert(v)}$ 的调用次数。在调用了 q 次 $\text{insert(v)}$ 后，完全二叉树中有 n+q 个节点，其中有一半的节点在队列中，需要 O(n+q) 的空间。

### 二进制表示

```c++
class CBTInserter {
public:
    CBTInserter(TreeNode* root) {
        this->root = root;

        queue<TreeNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            ++cnt;
            TreeNode* node = q.front();
            q.pop();
            if (node->left) {
                q.push(node->left);
            }
            if (node->right) {
                q.push(node->right);
            }
        }
    }
    
    int insert(int val) {
        ++cnt;
        TreeNode* child = new TreeNode(val);
        TreeNode* node = root;
        int highbit = 31 - __builtin_clz(cnt);
        for (int i = highbit - 1; i >= 1; --i) {
            if (cnt & (1 << i)) {
                node = node->right;
            }
            else {
                node = node->left;
            }
        }
        if (cnt & 1) {
            node->right = child;
        }
        else {
            node->left = child;
        }
        return node->val;
    }
    
    TreeNode* get_root() {
        return root;
    }

private:
    int cnt = 0;
    TreeNode* root;
};
```

```java
class CBTInserter {
    int cnt;
    TreeNode root;

    public CBTInserter(TreeNode root) {
        this.cnt = 0;
        this.root = root;

        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            ++cnt;
            TreeNode node = queue.poll();
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }

    public int insert(int val) {
        ++cnt;
        TreeNode child = new TreeNode(val);
        TreeNode node = root;
        int highbit = 31 - Integer.numberOfLeadingZeros(cnt);
        for (int i = highbit - 1; i >= 1; --i) {
            if ((cnt & (1 << i)) != 0) {
                node = node.right;
            } else {
                node = node.left;
            }
        }
        if ((cnt & 1) != 0) {
            node.right = child;
        } else {
            node.left = child;
        }
        return node.val;
    }

    public TreeNode get_root() {
        return root;
    }
}
```

```python
class CBTInserter:

    def __init__(self, root: TreeNode):
        self.root = root
        self.cnt = 0

        q = deque([root])
        while q:
            self.cnt += 1
            node = q.popleft()
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)

    def insert(self, val: int) -> int:
        self.cnt += 1

        child = TreeNode(val)
        node = self.root
        highbit = self.cnt.bit_length() - 1

        for i in range(highbit - 1, 0, -1):
            if self.cnt & (1 << i):
                node = node.right
            else:
                node = node.left
        
        if self.cnt & 1:
            node.right = child
        else:
            node.left = child
        
        return node.val

    def get_root(self) -> TreeNode:
        return self.root
```

#### 思路与算法

如果我们将完全二叉树的每个节点进行编号，其中：

- 根节点的编号为 1；

- 如果某个节点的编号为 x，那么其左子节点的编号为 2x，右子节点的编号为 2x+1。


那么我们可以发现，按照广度优先搜索的顺序，完全二叉树中的所有节点的编号是连续的。这可以用二进制表示看出：完全二叉树的第 $i (i \geq 1)$ 层有 $2^{i-1}$个节点，它们的编号恰好对应着 i 位的二进制表示，共有 $2^{i-1}$ 个（最高位必须为 1）。当某个节点编号为 x 时，左子节点的编号 2x 即为将 x 的二进制表示左移一位后在最低位补 0，右子节点的编号即为将 x 的二进制表示右移一位后在最低位补 1。

因此，在初始化时，我们只需要使用深度优先搜索或者广度优先搜索，得到初始完全二叉树中的节点个数。在调用 $\text{insert(v)}$ 时，我们可以知道它的编号 x，那么就可以从高到低遍历 x 的每一个二进制位（忽略最高位的 1），如果为 0 就往左子节点移动，否则往右子节点移动，这样就可以到达节点需要被插入的位置。

#### 复杂度分析

- 时间复杂度：初始化 $\text{CBTInserter(root)}$ 需要的时间为 O(n)，其中 n 是给定的初始完全二叉树的节点个数。这里也可以通过 222. 完全二叉树的节点个数 中的方法优化到 $O(\log^2 n)$。$\text{insert(v)} $需要的时间为 $O(\log (n+q))$，其中 q 是 $\text{insert(v)}$ 的调用次数。$\text{get\_root()}$ 的时间复杂度为 O(1)。

- 空间复杂度：初始化 $\text{CBTInserter(root)}$ 需要的空间为 O(n)。如果使用优化方法，空间可以降低到 $O(\log n)$。其它所有函数调用都只需要 O(1) 的空间。


