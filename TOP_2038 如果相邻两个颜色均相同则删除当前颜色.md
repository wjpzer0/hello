# 题目

总共有 `n` 个颜色片段排成一列，每个颜色片段要么是 `'A'` 要么是 `'B'` 。给你一个长度为 `n` 的字符串 `colors` ，其中 `colors[i]` 表示第 `i` 个颜色片段的颜色。

Alice 和 Bob 在玩一个游戏，他们 **轮流** 从这个字符串中删除颜色。Alice **先手** 。

- 如果一个颜色片段为 `'A'` 且 **相邻两个颜色** 都是颜色 `'A'` ，那么 Alice 可以删除该颜色片段。Alice **不可以** 删除任何颜色 `'B'` 片段。
- 如果一个颜色片段为 `'B'` 且 **相邻两个颜色** 都是颜色 `'B'` ，那么 Bob 可以删除该颜色片段。Bob **不可以** 删除任何颜色 `'A'` 片段。
- Alice 和 Bob **不能** 从字符串两端删除颜色片段。
- 如果其中一人无法继续操作，则该玩家 **输** 掉游戏且另一玩家 **获胜** 。

假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 `true`，否则 Bob 获胜，返回 `false`。

 

**示例 1：**

```
输入：colors = "AAABABB"
输出：true
解释：
AAABABB -> AABABB
Alice 先操作。
她删除从左数第二个 'A' ，这也是唯一一个相邻颜色片段都是 'A' 的 'A' 。

现在轮到 Bob 操作。
Bob 无法执行任何操作，因为没有相邻位置都是 'B' 的颜色片段 'B' 。
因此，Alice 获胜，返回 true 。
```

**示例 2：**

```
输入：colors = "AA"
输出：false
解释：
Alice 先操作。
只有 2 个 'A' 且它们都在字符串的两端，所以她无法执行任何操作。
因此，Bob 获胜，返回 false 。
```

**示例 3：**

```
输入：colors = "ABBBBBBBAAA"
输出：false
解释：
ABBBBBBBAAA -> ABBBBBBBAA
Alice 先操作。
她唯一的选择是删除从右数起第二个 'A' 。

ABBBBBBBAA -> ABBBBBBAA
接下来轮到 Bob 操作。
他有许多选择，他可以选择任何一个 'B' 删除。

然后轮到 Alice 操作，她无法删除任何片段。
所以 Bob 获胜，返回 false 。
```

**提示：**

- $1 <= colors.length <= 10^5$
- `colors` 只包含字母 `'A'` 和 `'B'`

## 我的解法

代码可以优化！

```python
class Solution:
    def winnerOfGame(self, colors: str) -> bool:
        a = 0
        b = 0
        al = []
        bl = []
        for i in colors:
            if i == 'A':
                a += 1
                if b != 0:
                    bl.append(b)
                    b = 0
            else:
                b += 1
                if a != 0:
                    al.append(a)
                    a = 0
        if a != 0:
            al.append(a)
        if b != 0:
            bl.append(b)
        
        aSum = 0
        for i in al:
            if i > 2:
                aSum += i - 2
        
        bSum = 0
        for i in bl:
            if i > 2:
                bSum += i - 2

        return aSum > bSum
```

## 其他解法

### 贪心

```c++
class Solution {
public:
    bool winnerOfGame(string colors) {
        int freq[2] = {0, 0};
        char cur = 'C';
        int cnt = 0;
        for (char c : colors) {
            if (c != cur) {
                cur = c;
                cnt = 1;
            } else if (++cnt >= 3) {
                ++freq[cur - 'A'];
            }
        }            
        return freq[0] > freq[1];
    }
};
```

```java
class Solution {
    public boolean winnerOfGame(String colors) {
        int[] freq = {0, 0};
        char cur = 'C';
        int cnt = 0;
        for (int i = 0; i < colors.length(); i++) {
            char c = colors.charAt(i);
            if (c != cur) {
                cur = c;
                cnt = 1;
            } else {
                cnt += 1;
                if (cnt >= 3) {
                    freq[cur - 'A'] += 1;
                }
            }
        }            
        return freq[0] > freq[1];
    }
}
```

```python
class Solution:
    def winnerOfGame(self, colors: str) -> bool:
        freq = [0, 0]
        cur, cnt = 'C', 0
        for c in colors:
            if c != cur:
                cur = c
                cnt = 1
            else:
                cnt += 1
                if cnt >= 3:
                    freq[ord(cur) - ord('A')] += 1
        return freq[0] > freq[1]
```

#### 思路

根据题意，当 $\textit{colors}$ 中有一串连续的长度为 $L_\text{A}$的 $\text{A}$ 时，$\text{Alice}$ 可以删除中间的 $L_\text{A}-2$个 $\text{A}$，而不能删除两边的 2 个 $\text{A}$。并且 $\text{Bob}$Bob 删除$ \text{B}$ 的操作，不会影响 $\text{Alice}$ 删除 $L_\text{A}$的操作。

同理，当 $\textit{colors}$ 中有一串连续的长度为 $L_\text{B}$的$ \text{B}$ 时，$\text{Bob}$ 可以删除中间的 $L_\text{B}-2$ 个 \text{B}B，而不能删除两边的 2 个 $\text{B}$。并且 $\text{Alice}$ 删除$ \text{A}$ 的操作，不会影响$ \text{Bob}$ 删除$ L_\text{B}$ 的操作。

根据这两个结论，我们可以分别计算出 $\text{Alice}$ 和 $\text{Bob}$ 的操作数。当 $\text{Alice}$ 的操作数大于 $\text{Bob}$b的操作数时，$\text{Alice}$ 获胜；否则，$\text{Bob}$ 获胜。

#### 复杂度分析

时间复杂度：O(n)，其中 n 是 $\textit{colors}$ 的长度。需要遍历 $\textit{colors}$ 来统计 $\text{Alice}$ 和 $\text{Bob}$ 可以移动的次数。

空间复杂度：O(1)。仅需要常数空间。

