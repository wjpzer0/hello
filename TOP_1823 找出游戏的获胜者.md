# 题目

共有 `n` 名小伙伴一起做游戏。小伙伴们围成一圈，按 **顺时针顺序** 从 `1` 到 `n` 编号。确切地说，从第 `i` 名小伙伴顺时针移动一位会到达第 `(i+1)` 名小伙伴的位置，其中 `1 <= i < n` ，从第 `n` 名小伙伴顺时针移动一位会回到第 `1` 名小伙伴的位置。

游戏遵循如下规则：

1. 从第 `1` 名小伙伴所在位置 **开始** 。
2. 沿着顺时针方向数 `k` 名小伙伴，计数时需要 **包含** 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
3. 你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
4. 如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 **顺时针下一位** 小伙伴 **开始**，回到步骤 `2` 继续执行。
5. 否则，圈子中最后一名小伙伴赢得游戏。

给你参与游戏的小伙伴总数 `n` ，和一个整数 `k` ，返回游戏的获胜者。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png)

```
输入：n = 5, k = 2
输出：3
解释：游戏运行步骤如下：
1) 从小伙伴 1 开始。
2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。
3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。
4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。
5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。
6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。
7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。
8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。
9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。
```

**示例 2：**

```
输入：n = 6, k = 5
输出：1
解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。
```

**提示：**

- `1 <= k <= n <= 500`

## 我的解法

模拟！

```python
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        import queue
        q = queue.Queue()
        for i in range(1, n + 1):
            q.put(i)
        mark = 0
        while q.qsize() != 1:
            num = q.get()
            mark += 1
            if mark == k:
                mark = 0
                continue
            q.put(num)
        return q.get()
```

问题描述
约瑟夫环问题是这样的：

0, 1, …, n - 1 这 n 个数字排成一个圆圈，从数字 00 开始，每次从这个圆圈里删除第 m 个数字。求出这个圆圈里剩下的最后一个数字。

> 例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。

如下图所示。

![image.png](https://pic.leetcode-cn.com/1651627619-KhrukC-image.png)

根据上图中的箭头，我们可以看到每一轮中移走的是第 m 个数字（因为数组下标是从 0 开始，所以被移走的数字下标为 m - 1）。
所以每一轮的第 m + 1 个数字（下标为 m），将成为下一轮的开头元素（下标变成 0）。

#### 解法

解决约瑟夫环问题，我们采用倒推，我们倒推出：最后剩下的这个数字，在最开始的数组中的位置。

1. 剩下最后一个数字（简称“它”）的时候，总个数为 1，它的下标 pos = 0。
2. 那么它在上一轮也是安全的，总个数为 2，它的下标 $pos = (0 + m) \% 2$； （解释：在上一轮中，它前面的数字（即红色的数字，下标为 m - 1）被移走了；因此它的下标是 m；由于是环，因此需要 $\% 2$）
3. 那么它在上上轮也是安全的，总个数为 3，它的下标 $pos = ((0 + m) \% 2 + m) \% 3$；
4. 那么它在上上上轮也是安全的，总个数为 4，它的下标 $pos = (((0 + m) \% 2 + m) \% 3) \% 4$；
5. ...
6. 那么它在游戏开始的第一轮也是安全的，总个数为 n，它的下标 pos 就是所求。

即如果从下向上反推的时候：假如它下一轮的下标为 pos，那么当前轮次的下标就是： $(pos + m) \%$ 当前轮次的人数。

最后，由于给出的数字是 nums = 0, 1, 2, .., n - 1，即 nums[i] = i，因此找出下标 pos 就相当于找到这个数字。

```python
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        winner = 0
        for i in range(2, n + 1):
            winner = (k + winner) % i 
        return winner + 1
```

## 其他解法

### 模拟 + 队列

```c++
class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> qu;
        for (int i = 1; i <= n; i++) {
            qu.emplace(i);
        }
        while (qu.size() > 1) {
            for (int i = 1; i < k; i++) {
                qu.emplace(qu.front());
                qu.pop();
            }
            qu.pop();
        }
        return qu.front();
    }
};
```

```java
class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> queue = new ArrayDeque<Integer>();
        for (int i = 1; i <= n; i++) {
            queue.offer(i);
        }
        while (queue.size() > 1) {
            for (int i = 1; i < k; i++) {
                queue.offer(queue.poll());
            }
            queue.poll();
        }
        return queue.peek();
    }
}
```

```python
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        q = deque(range(1, n + 1))
        while len(q) > 1:
            for _ in range(k - 1):
                q.append(q.popleft())
            q.popleft()
        return q[0]
```

最直观的方法是模拟游戏过程。使用队列存储圈子中的小伙伴编号，初始时将 1 到 n 的所有编号依次加入队列，队首元素即为第 1 名小伙伴的编号。

每一轮游戏中，从当前小伙伴开始数 k 名小伙伴，数到的第 k 名小伙伴离开圈子。模拟游戏过程的做法是，将队首元素取出并将该元素在队尾处重新加入队列，重复该操作 k - 1 次，则在 k - 1 次操作之后，队首元素即为这一轮中数到的第 k 名小伙伴的编号，将队首元素取出，即为数到的第 k 名小伙伴离开圈子。上述操作之后，新的队首元素即为下一轮游戏的起始小伙伴的编号。

每一轮游戏之后，圈子中减少一名小伙伴，队列中减少一个元素。重复上述过程，直到队列中只剩下 1 个元素，该元素即为获胜的小伙伴的编号。

#### 复杂度分析

- 时间复杂度：O(nk)，其中 n 是做游戏的小伙伴数量，k 是每一轮离开圈子的小伙伴的计数。初始时需要将 n 个元素加入队列，每一轮需要将 k 个元素从队列中取出，将 k - 1 个元素加入队列，一共有 n - 1 轮，因此时间复杂度是 O(nk)。

- 空间复杂度：O(n)，其中 n 是做游戏的小伙伴数量。空间复杂度主要取决于队列，队列中最多有 n 个元素。


### 数学 + 递归

```c++
class Solution {
public:
    int findTheWinner(int n, int k) {
        if (n == 1) {
            return 1;
        }
        return (k + findTheWinner(n - 1, k) - 1) % n + 1;
    }
};
```

```java
class Solution {
    public int findTheWinner(int n, int k) {
        if (n == 1) {
            return 1;
        }
        return (k + findTheWinner(n - 1, k) - 1) % n + 1;
    }
}
```

```python
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        return 1 if n == 1 else (k + self.findTheWinner(n - 1, k) - 1) % n + 1
```

以下用 f(n, k) 表示 n 名小伙伴做游戏，每一轮离开圈子的小伙伴的计数为 k 时的获胜者编号。

当 n = 1 时，圈子中只有一名小伙伴，该小伙伴即为获胜者，因此 f(1, k) = 1。

当 n > 1 时，将有一名小伙伴离开圈子，圈子中剩下 n - 1 名小伙伴。圈子中的第 k'名小伙伴离开圈子，k'满足 $1 \le k' \le n$ 且 k - k'是 n 的倍数。

由于 $1 \le k' \le n$，因此 $0 \le k' - 1 \le n - 1$。又由于 k - k'是 n 的倍数等价于 (k - 1) - (k' - 1)是 n 的倍数，因此 $k' - 1 = (k - 1) \bmod n$，$k' = (k - 1) \bmod n + 1$。

当圈子中剩下 n - 1 名小伙伴时，可以递归地计算 f(n - 1, k)，得到剩下的 n - 1 名小伙伴中的获胜者。令 x = f(n - 1, k)。

由于在第 k'名小伙伴离开圈子之后，圈子中剩下的 n - 1 名小伙伴从第 k' + 1名小伙伴开始计数，获胜者编号是从第 k' + 1名小伙伴开始的第 x 名小伙伴，因此当圈子中有 n 名小伙伴时，获胜者编号是 $f(n, k) = (k' \bmod n + x - 1) \bmod n + 1 = (k + x - 1) \bmod n + 1$。

将 x = f(n - 1, k) 代入上述关系，可得：$f(n, k) = (k + f(n - 1, k) - 1) \bmod n + 1$。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是做游戏的小伙伴数量。需要计算的值有 n 个，每个值的计算时间都是 O(1)。

- 空间复杂度：O(n)，其中 n 是做游戏的小伙伴数量。空间复杂度主要取决于递归调用栈的深度，为 O(n) 层。


### 数学 + 迭代

```c++
class Solution {
public:
    int findTheWinner(int n, int k) {
        int winner = 1;
        for (int i = 2; i <= n; i++) {
            winner = (k + winner - 1) % i + 1;
        }
        return winner;
    }
};
```

```java
class Solution {
    public int findTheWinner(int n, int k) {
        int winner = 1;
        for (int i = 2; i <= n; i++) {
            winner = (k + winner - 1) % i + 1;
        }
        return winner;
    }
}
```

```python
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        winner = 1
        for i in range(2, n + 1):
            winner = (k + winner - 1) % i + 1
        return winner
```

方法二的递归实现可以改成迭代实现，省略递归调用栈空间。

#### **复杂度分析**

- 时间复杂度：O(n)，其中 n是做游戏的小伙伴数量。需要 O(n) 的时间遍历并计算结果。
- 空间复杂度：O(1)。