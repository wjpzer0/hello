# 题目

Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 `groupSize` ，并且由 `groupSize` 张连续的牌组成。

给你一个整数数组 `hand` 其中 `hand[i]` 是写在第 `i` 张牌，和一个整数 `groupSize` 。如果她可能重新排列这些牌，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
输出：true
解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。
```

**示例 2：**

```
输入：hand = [1,2,3,4,5], groupSize = 4
输出：false
解释：Alice 手中的牌无法被重新排列成几个大小为 4 的组。
```

**提示：**

- $1 <= hand.length <= 10^4$
- $0 <= hand[i] <= 10^9$
- `1 <= groupSize <= hand.length`

## 我的解法

解法的思路应该没有问题，书写代码的思路有问题，代码的细节处理不到位！

```python
class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        map = defaultdict(int)
        n = len(hand)
        if n % groupSize != 0:
            return False
        for i in hand:
            map[i] += 1

        mapkey = sorted(map.keys())
        while mapkey:
            for i in range(groupSize):
                if len(mapkey) < groupSize:
                    return False
                if i != groupSize - 1 and mapkey[i] + 1 != mapkey[i + 1]:
                    return False
                map[mapkey[i]] -= 1
            while map[mapkey[0]] == 0:
                del mapkey[0]
                if not mapkey:
                    break
        return True
```

## 其他解法

### 贪心

```c++
class Solution {
public:
    bool isNStraightHand(vector<int>& hand, int groupSize) {
        int n = hand.size();
        if (n % groupSize != 0) {
            return false;
        }
        sort(hand.begin(), hand.end());
        unordered_map<int, int> cnt;
        for (auto & num : hand) {
            cnt[num]++;
        }
        for (auto & x : hand) {
            if (!cnt.count(x)) {
                continue;
            }
            for (int j = 0; j < groupSize; j++) {
                int num = x + j;
                if (!cnt.count(num)) {
                    return false;
                }
                cnt[num]--;
                if (cnt[num] == 0) {
                    cnt.erase(num);
                }
            }
        }
        return true;
    }
};
```

```java
class Solution {
    public boolean isNStraightHand(int[] hand, int groupSize) {
        int n = hand.length;
        if (n % groupSize != 0) {
            return false;
        }
        Arrays.sort(hand);
        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();
        for (int x : hand) {
            cnt.put(x, cnt.getOrDefault(x, 0) + 1);
        }
        for (int x : hand) {
            if (!cnt.containsKey(x)) {
                continue;
            }
            for (int j = 0; j < groupSize; j++) {
                int num = x + j;
                if (!cnt.containsKey(num)) {
                    return false;
                }
                cnt.put(num, cnt.get(num) - 1);
                if (cnt.get(num) == 0) {
                    cnt.remove(num);
                }
            }
        }
        return true;
    }
}
```

```python
class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        if len(hand) % groupSize > 0:
            return False
        hand.sort()
        cnt = Counter(hand)
        for x in hand:
            if cnt[x] == 0:
                continue
            for num in range(x, x + groupSize):
                if cnt[num] == 0:
                    return False
                cnt[num] -= 1
        return True
```

题目要求将数组 $\textit{hand}$ 中的牌分组使得每组的大小是 $\textit{groupSize}$。假设数组 $\textit{hand}$ 的长度是 n，只有当 $n \bmod \textit{groupSize} = 0$ 时才可能完成分组，因此如果 $n \bmod \textit{groupSize} \ne 0$则直接返回 $\text{false}$。

当 $n \bmod \textit{groupSize} = 0$ 时，可以将数组 $\textit{hand}$ 中的牌分组使得每组的大小是 $\textit{groupSize}$，此时需要判断是否存在一种分组方式使得同一组的牌都是连续的。

由于每张牌都必须被分到某个组，因此可以使用贪心的策略。假设尚未分组的牌中，最小的数字是 x，则如果存在符合要求的分组方式，x 一定是某个组中的最小数字（否则 x 不属于任何一个组，不符合每张牌都必须被分到某个组），该组的数字范围是 $[x, x + \textit{groupSize} - 1]$。在将 x 到 $x + \textit{groupSize} - 1$ 的$ \textit{groupSize}$ 张牌分成一个组之后，继续使用贪心的策略对剩下的牌分组，直到所有的牌分组结束或者无法完成分组。如果在分组过程中发现从最小数字开始的连续 $\textit{groupSize}$ 个数字中有不存在的数字，则无法完成分组。

首先对数组 $\textit{hand}$ 排序，并使用哈希表记录数组 $\textit{hand}$ 中每个元素的出现次数，然后遍历数组 $\textit{hand}$，使用基于上述贪心策略的做法判断是否可以完成分组。贪心策略的具体做法如下：

1. 将当前元素记为 x，如果 x 不在哈希表中则跳过，如果 x 在哈希表中，则 x 是某个组中的最小数字（因为数组 $\textit{hand}$ 有序，当遍历到 x 时，x 一定是所有尚未分组的元素中的最小数字），该组的数字范围是 $[x, x + \textit{groupSize} - 1]$；

2. 如果可以完成分组，则 x 到 $x + \textit{groupSize} - 1$ 的每个整数在哈希表中记录的出现次数都至少为 1，如果遇到某个整数的出现次数为 0 则无法完成分组，返回$ \text{false}$；

3. 将 x 到 $x + \textit{groupSize} - 1$ 的每个整数在哈希表中记录的出现次数减 1，如果出现次数减为 0 则从哈希表中移除该整数；

4. 对于其余元素，重复上述操作，直到遍历结束。


遍历结束之后，如果没有出现无法完成分组的情况，返回 $\text{true}$。

#### 复杂度分析

- 时间复杂度：$O(n \log n)$，其中 n 是数组 $\textit{hand}$ 的长度。对数组 $\textit{hand}$ 排序需要 $O(n \log n)$ 的时间，排序之后遍历数组 $\textit{hand}$ 两次，每次遍历过程中，每个元素的处理时间都是 O(1)，因此每次遍历的时间复杂度都是 O(n)，总时间复杂度是 $O(n \log n)$。

- 空间复杂度：O(n)，其中 n 是数组 $\textit{hand}$ 的长度。空间复杂度主要取决于哈希表，哈希表中最多存储 n 个元素。


