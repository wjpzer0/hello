# 题目

颠倒给定的 32 位无符号整数的二进制位。

提示：

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

进阶:
如果多次调用这个函数，你将如何优化你的算法？

示例 1：

```
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```


示例 2：

```
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```


示例 1：

```
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```


示例 2：

```
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```


提示：

输入是一个长度为 32 的二进制字符串

## 我的解法

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        n2 = bin(n)[2:]
        if (len(n2)) < 32:
            n2 = "0" * (32 - len(n2)) + n2
        else:
            n2 = n2
        reN2 = n2[::-1]
        num = 0
        mi = 31
        for i in reN2:
            if i == "1":
                num = num + 2 ** mi
            mi -= 1
        return num
```

思路较为清晰，但解法步骤较为繁琐。

## 其他解法

### 取模求和

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            res = (res << 1) + (n & 1);
            n >>= 1;
        }
        return res;
    }
}
```

与反转十进制整数使用取模除十累加的方法类似，

- 十进制：ans = ans * 10 + n % 10; n = n / 10;
- 二进制：ans = ans * 2 + n % 2; n = n / 2;

但是，仅仅使用这种写法，会有一些问题，比如都要考虑是否整型溢出，Java的整数溢出后的二进制数会表示成负数（补码形式），Java中负数除以2会向零取整；具体可以参考这篇博客还有这个视频中: -3 / 2 = -1 而 -3 >> 1 = -2

然后还要考虑前导零，因为十进制是不考虑前面是否还有零的，比如100反转后就是1，不用写成001，而二进制要考虑前导零的问题。

所以综上所述，要使用位运算来避免溢出问题，同时循环32次。

因为一共只有32位，所以时间复杂度和空间复杂度都是O(1)。

###  按位翻转

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i <= 31; i++) {            
            // res += (n & (1 << i)) != 0 ? 1 << (31 - i) : 0;
            // res |= (n & (1 << i)) != 0 ? 1 << (31 - i) : 0;
            res ^= (n & (1 << i)) != 0 ? 1 << (31 - i) : 0;
        }
        return res;
    }
}
```

直接颠倒计算每一位的数字

- 32位 int 标记 [0 ~ 31]，如果 n 的第 i 位为1，则相应的res 第 31 - i 位应该为1
- 类似地，如果 n 的第 i 位为0，则相应的 res 第 31 - i 位应该为0

res初始化为0，每次考虑 n的某一位，移动到颠倒后的位置，设该位表示的数为temp，temp只有两种情况，要么等于0，要么等于一个2的幂次(相当于二进制000... 1 ...0000这种形式)

对于temp = 0，res加上0相当于没加，和0按位或、异或还是等于原来的数，所以这三者是一样的

对于temp = 2^(31 - i)，temp二进制下只有一位为1，看样子似乎+=和|=不一样，但是不要忘了我们是按位循环的，当进行到31 - i这一位时，res的这一位还是0，那么就回到上一种情况了，+=,|=, ^=这三种种写法其实还是等效的。

因为考虑的temp只有某一位，每次对应于res也是是其中某一位，而且由于是按位考虑，所以每次遍历到该位时，res二进制下的这一位也还是0，res |= ... , res += ... , res |= ...都是等价的，都是在表达，只要temp的该位为1，res该位就为1，因为res的那一位一开始是0，如果temp该位为0，由于res这一位也为0,那么0 + 0, 0 | 0, 0 ^ 0其实都等于0。三种写法都可以，但是更推荐使用位运算

### 分治合并

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        n = (n >>> 16) | (n << 16); 
        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8); 
        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4); 
        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2); 
        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1); 
        return n;
    }
}
```

补充：Integer 包装类自带一个静态方法Integer.reverse(int i)，思想是一样的，写法略有不同，

```java
public static int reverse(int i) {

    i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;
    i = (i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;
    i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;
    i = (i << 24) | ((i & 0xff00) << 8) |
        ((i >>> 8) & 0xff00) | (i >>> 24);
    return i;
}
```

既然知道 int 值一共32位，那么可以采用分治思想，反转左右16位，然后反转每个16位中的左右8位，依次类推，最后反转2位，反转后合并即可，同时可以利用位运算在原地反转。JDK中的Integer.bitCount()函数也是使用类似的方法。

这么说比较抽象，可以直接结合代码看下面的步骤，也可以拿代码在IDE中debug一下，看每一步都做了什么

- 首先随便找一个数 (为了看的清楚用_作分隔，可以忽略)

  十进制43261596;   // 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬

- 左边16位移到右边，右边16位移到左边，然后使用|符号合并起来

	- Java中的无符号位移 >>>：无论是正数还是负数，高位通通补0。

	- \>>：带符号右移。正数右移高位补0，负数右移高位补1。

	- |：按位或逻辑，该位只要有一位为1，结果就为1，这里用来合并

- 使用一些有规律的数，将16位，再分成左右8位进行反转后合并，起始数字变为‭0001 1110 1001 1100 _ 0000 0010 1001 0100‬

	- 0xff00ff00 表示16进制数1111 1111 0000 0000 _ 1111 1111 0000 0000 ，

	- 0x00ff00ff 表示16进制数0000 0000 1111 1111 _ 0000 0000 1111 1111，

- 重复以上步骤，分组、合并，最后得到反转后的结果。

- 总结来说就是利用位运算进行反转，同时存储反转后的数，继续分治进行反转，直到全部反转完成，变化过程为：


```
// 原数字43261596
 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬ 
// 反转左右16位：
‭ 0001 1110 1001 1100 _ 0000 0010 1001 0100‬ 
// 继续分为8位一组反转：
 1001 1100 0001 1110 _ 1001 0100 0000 0010
// 4位一组反转：
 1100 1001 1110 0001 _ 0100 1001 0010 0000‬
// 2位一组反转：
 0011 0110 1011 0100 _ 0001 0110 1000 0000
// 每两位再反转一下
‭ 0011 1001 0111 1000 _ 0010 1001 0100 0000‬‬
// 这就是43261596反转后的结果：‭964176192‬
```

