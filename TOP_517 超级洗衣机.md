# 题目

假设有 `n` 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。

在每一步操作中，你可以选择任意 `m` (`1 <= m <= n`) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。

给定一个整数数组 `machines` 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 **最少的操作步数** 。如果不能使每台洗衣机中衣物的数量相等，则返回 `-1` 。

**示例 1：**

```
输入：machines = [1,0,5]
输出：3
解释：
第一步:    1     0 <-- 5    =>    1     1     4
第二步:    1 <-- 1 <-- 4    =>    2     1     3    
第三步:    2     1 <-- 3    =>    2     2     2   
```

**示例 2：**

```
输入：machines = [0,3,0]
输出：2
解释：
第一步:    0 <-- 3     0    =>    1     2     0    
第二步:    1     2 --> 0    =>    1     1     1     
```

**示例 3：**

```
输入：machines = [0,2,0]
输出：-1
解释：
不可能让所有三个洗衣机同时剩下相同数量的衣物。
```

**提示：**

- `n == machines.length`
- $1 <= n <= 10^4$
- $0 <= machines[i] <= 10^5$

## 我的解法

写出了，开头，没有写出遍历的贪心解法，查看题解后写出！

```python
class Solution:
    def findMinMoves(self, machines: List[int]) -> int:
        sumM = sum(machines)
        numM = len(machines)
        if sumM % numM != 0:
            return -1
        
        average = int(sumM / numM)
        
        ans = 0
        s = 0
        for num in machines:
            num -= average
            s += num
            ans = max(ans, abs(s), num)
        
        return ans
```

## 其他解法

### 贪心

```c++
class Solution {
public:
    int findMinMoves(vector<int> &machines) {
        int tot = accumulate(machines.begin(), machines.end(), 0);
        int n = machines.size();
        if (tot % n) {
            return -1;
        }
        int avg = tot / n;
        int ans = 0, sum = 0;
        for (int num: machines) {
            num -= avg;
            sum += num;
            ans = max(ans, max(abs(sum), num));
        }
        return ans;
    }
};
```

```java
class Solution {
    public int findMinMoves(int[] machines) {
        int tot = Arrays.stream(machines).sum();
        int n = machines.length;
        if (tot % n != 0) {
            return -1;
        }
        int avg = tot / n;
        int ans = 0, sum = 0;
        for (int num : machines) {
            num -= avg;
            sum += num;
            ans = Math.max(ans, Math.max(Math.abs(sum), num));
        }
        return ans;
    }
}
```

```python
class Solution:
    def findMinMoves(self, machines: List[int]) -> int:
        tot = sum(machines)
        n = len(machines)
        if tot % n:
            return -1
        avg = tot // n
        ans, s = 0, 0
        for num in machines:
            num -= avg
            s += num
            ans = max(ans, abs(s), num)
        return ans
```

设所有洗衣机内的衣服个数之和为 $\textit{tot}$，要使最终所有洗衣机内的衣服个数相同，那么 $\textit{tot}$ 必须是 n 的倍数，否则我们直接返回 $-1$。

记 $\textit{avg}=\dfrac{\textit{tot}}{n}$，定义 $\textit{machines}[i]'=\textit{machines}[i]-\textit{avg}$，若 $\textit{machines}[i]'$为正则说明需要移出$ \textit{machines}[i]'$件衣服，为负则说明需要移入 $-\textit{machines}[i]'$件衣服。

将前 i 台洗衣机看成一组，记作 A，其余洗衣机看成另一组，记作 B。设 $\textit{sum}[i]=\sum_{j=0}^i \textit{machines}[j]'$，若 $\textit{sum}[i]$ 为正则说明需要从 A 向 B 移入 $\textit{sum}[i]$ 件衣服，为负则说明需要从 B 向 A 移入 $-\textit{sum}[i]$件衣服。

我们分两种情况来考虑操作步数：

- A 与 B 两组之间的衣服，最多需要 $\max_{i=0}^{n-1}|\textit{sum}[i]|$次衣服移动；
- 组内的某一台洗衣机内的衣服数量过多，需要向左右两侧移出衣服，这最多需要 $\max_{i=0}^{n-1}\textit{machines}[i]'$次衣服移动。

取两者的最大值即为答案。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是数组 $\textit{machines}$ 的长度。

- 空间复杂度：O(1)。只需要常数的空间存放若干变量。


