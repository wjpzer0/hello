# 题目

给你一个头结点为 `head` 的单链表和一个整数 `k` ，请你设计一个算法将链表分隔为 `k` 个连续的部分。

每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。

这 `k` 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。

返回一个由上述 `k` 部分组成的数组。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg)

```
输入：head = [1,2,3], k = 5
输出：[[1],[2],[3],[],[]]
解释：
第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。
最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg)

```
输入：head = [1,2,3,4,5,6,7,8,9,10], k = 3
输出：[[1,2,3,4],[5,6,7],[8,9,10]]
解释：
输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。
```

**提示：**

- 链表中节点的数目在范围 `[0, 1000]`
- `0 <= Node.val <= 1000`
- `1 <= k <= 50`

## 我的解法

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def splitListToParts(self, head: ListNode, k: int) -> List[ListNode]:
        num = 0
        statistics = head
        while statistics:
            num += 1
            statistics = statistics.next
        
        average = num // k
        res = [average] * k
        remainder = num % k
        for i in range(remainder):
            res[i] += 1

        ans = head
        for i in range(k):
            if res[i] == 0:
                res[i] = None
                continue
            newH = ListNode()
            resH = newH
            for j in range(res[i]):
                newH.next = ListNode(val=ans.val)
                newH = newH.next
                ans = ans.next
            res[i] = resH.next
        return res
```

代码一开始没有理清楚，思路没有问题！

## 其他解法

```c++
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        int n = 0;
        ListNode *temp = head;
        while (temp != nullptr) {
            n++;
            temp = temp->next;
        }
        int quotient = n / k, remainder = n % k;

        vector<ListNode*> parts(k,nullptr);
        ListNode *curr = head;
        for (int i = 0; i < k && curr != nullptr; i++) {
            parts[i] = curr;
            int partSize = quotient + (i < remainder ? 1 : 0);
            for (int j = 1; j < partSize; j++) {
                curr = curr->next;
            }
            ListNode *next = curr->next;
            curr->next = nullptr;
            curr = next;
        }
        return parts;
    }
};
```

```java
class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {
        int n = 0;
        ListNode temp = head;
        while (temp != null) {
            n++;
            temp = temp.next;
        }
        int quotient = n / k, remainder = n % k;

        ListNode[] parts = new ListNode[k];
        ListNode curr = head;
        for (int i = 0; i < k && curr != null; i++) {
            parts[i] = curr;
            int partSize = quotient + (i < remainder ? 1 : 0);
            for (int j = 1; j < partSize; j++) {
                curr = curr.next;
            }
            ListNode next = curr.next;
            curr.next = null;
            curr = next;
        }
        return parts;
    }
}
```

### 拆分链表

题目要求将给定的链表分隔成 k 个连续的部分。由于分隔成的每个部分的长度和原始链表的长度有关，因此需要首先遍历链表，得到链表的长度 n。

得到链表的长度 n 之后，记 $\textit{quotient} = \Big\lfloor \dfrac{n}{k} \Big\rfloor$，$\textit{remainder} = n \bmod k$，则在分隔成的 k 个部分中，前 $\textit{remainder}$ 个部分的长度各为 $\textit{quotient} + 1$，其余每个部分的长度各为 $\textit{quotient}$。

分隔链表时，从链表的头结点开始遍历，记当前结点为 $\textit{curr}$，对于每个部分，进行如下操作：

1. 将 $\textit{curr}$ 作为当前部分的头结点；

2. 计算当前部分的长度 $\textit{partSize}$；

3. 将 $\textit{curr}$ 向后移动$ \textit{partSize}$ 步，则 $\textit{curr}$ 为当前部分的尾结点；

4. 当 $\textit{curr}$ 到达当前部分的尾结点时，需要拆分 $\textit{curr}$ 和后面一个结点之间的连接关系，在拆分之前需要存储 $\textit{curr}$ 的后一个结点 $\textit{next}$；

5. 令 $\textit{curr}$ 的 $\textit{next}$ 指针指向 $\text{null}$，完成 $\textit{curr}$ 和 $\textit{next}$ 的拆分；

6. 将 $\textit{next}$ 赋值给 $\textit{curr}$。


完成上述操作之后，即得到分隔链表后的一个部分。重复上述操作，直到分隔出 kk 个部分，或者链表遍历结束，即 $\textit{curr}$ 指向 $\text{null}$。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表两次，得到链表的长度和分隔链表。

- 空间复杂度：O(1)。只使用了常量的额外空间，注意返回值不计入空间复杂度。
