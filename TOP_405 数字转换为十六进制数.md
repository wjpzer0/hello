# 题目

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 [补码运算](https://baike.baidu.com/item/补码/6854613?fr=aladdin) 方法。

**注意:**

1. 十六进制中所有字母(`a-f`)都必须是小写。
2. 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符`'0'`来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
3. 给定的数确保在32位有符号整数范围内。
4. **不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。**

**示例 1：**

```
输入:
26

输出:
"1a"
```

**示例 2：**

```
输入:
-1

输出:
"ffffffff"
```

## 我的解法

```python
class Solution:
    def toHex(self, num: int) -> str:
        map = {10:"a", 11:"b", 12:"c", 13:"d", 14:"e", 15:"f"}
        ans = ""
        if num >= 0:
            num = num
        else:
            maxNum = 2 ** 32
            num = maxNum + num
            
        while num:
            mid = num % 16
            if mid >= 10:
                ans = map[mid] + ans
            else:
                ans = str(mid) + ans
            num = num // 16

        return ans if ans else "0"
```

思路没毛病！

## 其他解法

### 位运算

```c++
class Solution {
public:
    string toHex(int num) {
        if (num == 0) {
            return "0";
        }
        string sb;
        for (int i = 7; i >= 0; i --) {
            int val = (num >> (4 * i)) & 0xf;
            if (sb.length() > 0 || val > 0) {
                char digit = val < 10 ? (char) ('0' + val) : (char) ('a' + val - 10);
                sb.push_back(digit);
            }
        }
        return sb;
    }
};
```

```java
class Solution {
    public String toHex(int num) {
        if (num == 0) {
            return "0";
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 7; i >= 0; i --) {
            int val = (num >> (4 * i)) & 0xf;
            if (sb.length() > 0 || val > 0) {
                char digit = val < 10 ? (char) ('0' + val) : (char) ('a' + val - 10);
                sb.append(digit);
            }
        }
        return sb.toString();
    }
}
```

题目要求将给定的整数 $\textit{num}$转换为十六进制数，负整数使用补码运算方法。

在补码运算中，最高位表示符号位，符号位是 0 表示正整数和零，符号位是 1 表示负整数。32 位有符号整数的二进制数有 32 位，由于一位十六进制数对应四位二进制数，因此 32 位有符号整数的十六进制数有 8 位。将 $\textit{num}$ 的二进制数按照四位一组分成 8 组，依次将每一组转换为对应的十六进制数，即可得到 $\textit{num}$ 的十六进制数。

假设二进制数的 8 组从低位到高位依次是第 0 组到第 7 组，则对于第 i 组，可以通过 $(\textit{nums} >> (4 \times i))~\&~\text{0xf}$ 得到该组的值，其取值范围是 0 到 15（即十六进制的 $\text{f}$）。将每一组的值转换为十六进制数的做法如下：

- 对于 0 到 9，数字本身就是十六进制数；

- 对于 10 到 15，将其转换为 $\text{a}$ 到 $\text{f}$ 中的对应字母。


对于负整数，由于最高位一定不是 0，因此不会出现前导零。对于零和正整数，可能出现前导零。避免前导零的做法如下：

- 如果 $\textit{num}=0$，则直接返回 0；

- 如果 $\textit{num}>0$，则在遍历每一组的值时，从第一个不是 00 的值开始拼接成十六进制数。


#### 复杂度分析

- 时间复杂度：O(k)，其中 k 是整数的十六进制数的位数，这道题中 k=8。无论 $\textit{num}$ 的值是多少，都需要遍历 $\textit{num}$ 的十六进制表示的全部数位。

- 空间复杂度：O(k)，其中 k 是整数的十六进制数的位数，这道题中 k=8。空间复杂度主要取决于中间结果的存储空间，这道题中需要存储 $\textit{num}$ 的十六进制表示中的除了前导零以外的全部数位。


