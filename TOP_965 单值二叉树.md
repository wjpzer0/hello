# 题目

如果二叉树每个节点都具有相同的值，那么该二叉树就是*单值*二叉树。

只有给定的树是单值二叉树时，才返回 `true`；否则返回 `false`。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png)

```
输入：[1,1,1,1,1,null,1]
输出：true
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50050-pm.png)

```
输入：[2,2,2,5,2]
输出：false
```

**提示：**

1. 给定树的节点数范围是 `[1, 100]`。
2. 每个节点的值都是整数，范围为 `[0, 99]` 。

## 我的解法

dfs，快速解决

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isUnivalTree(self, root: TreeNode) -> bool:
        qu = deque()
        qu.append(root)
        ans = True
        num = root.val
        while qu:
            node = qu.popleft()
            mid = node.val
            if mid != num:
                ans = False
                break
            if node.left:
                qu.append(node.left)
            if node.right:
                qu.append(node.right)
        
        return ans
```

## 其他解法

### 深度优先搜索

```c++
class Solution {
public:
    bool isUnivalTree(TreeNode* root) {
        if (!root) {
            return true;
        }
        if (root->left) {
            if (root->val != root->left->val || !isUnivalTree(root->left)) {
                return false;
            }
        }
        if (root->right) {
            if (root->val != root->right->val || !isUnivalTree(root->right)) {
                return false;
            }
        }
        return true;
    }
};
```

```java
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (root.left != null) {
            if (root.val != root.left.val || !isUnivalTree(root.left)) {
                return false;
            }
        }
        if (root.right != null) {
            if (root.val != root.right.val || !isUnivalTree(root.right)) {
                return false;
            }
        }
        return true;
    }
}
```

```python
class Solution:
    def isUnivalTree(self, root: TreeNode) -> bool:
        if not root:
            return True
        
        if root.left:
            if root.val != root.left.val or not self.isUnivalTree(root.left):
                return False
        
        if root.right:
            if root.val != root.right.val or not self.isUnivalTree(root.right):
                return False
        
        return True
```

#### 思路与算法

一棵树的所有节点都有相同的值，当且仅当对于树上的每一条边的两个端点，它们都有相同的值（这样根据传递性，所有节点都有相同的值）。

因此，我们可以对树进行一次深度优先搜索。当搜索到节点 x 时，我们检查 x 与 x 的每一个子节点之间的边是否满足要求。例如对于左子节点而言，如果其存在并且值与 x 相同，那么我们继续向下搜索该左子节点；如果值与 x 不同，那么我们直接返回 $\text{False}$。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是二叉树的节点个数。我们遍历二叉树的每个节点至多一次。

- 空间复杂度：O(n)，即为深度优先搜索中需要使用的栈空间。

- 
  