# 题目

给你两个整数 `left` 和 `right` ，在闭区间 `[left, right]` 范围内，统计并返回 **计算置位位数为质数** 的整数个数。

**计算置位位数** 就是二进制表示中 `1` 的个数。

- 例如， `21` 的二进制表示 `10101` 有 `3` 个计算置位。

**示例 1：**

```
输入：left = 6, right = 10
输出：4
解释：
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)
共计 4 个计算置位为质数的数字。
```

**示例 2：**

```
输入：left = 10, right = 15
输出：5
解释：
10 -> 1010 (2 个计算置位, 2 是质数)
11 -> 1011 (3 个计算置位, 3 是质数)
12 -> 1100 (2 个计算置位, 2 是质数)
13 -> 1101 (3 个计算置位, 3 是质数)
14 -> 1110 (3 个计算置位, 3 是质数)
15 -> 1111 (4 个计算置位, 4 不是质数)
共计 5 个计算置位为质数的数字。
```

**提示：**

- $1 <= left <= right <= 10^6$
- $0 <= right - left <= 10^4$

## 我的解法

简单的模拟思路！

```python
class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:
        ans = 0
        for num in range(left, right + 1):
            mid = 0
            while num:
                if num & 1 == 1:
                    mid += 1
                num >>= 1

            flag = True
            if mid == 1:
                flag = False
            for i in range(2, int(mid ** 0.5) + 1):
                if mid % i == 0:
                    flag = False
                    break

            ans += flag
        return ans
```

## 其他解法

### 数学 + 位运算

```c++
class Solution {
    bool isPrime(int x) {
        if (x < 2) {
            return false;
        }
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }

public:
    int countPrimeSetBits(int left, int right) {
        int ans = 0;
        for (int x = left; x <= right; ++x) {
            if (isPrime(__builtin_popcount(x))) {
                ++ans;
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    public int countPrimeSetBits(int left, int right) {
        int ans = 0;
        for (int x = left; x <= right; ++x) {
            if (isPrime(Integer.bitCount(x))) {
                ++ans;
            }
        }
        return ans;
    }

    private boolean isPrime(int x) {
        if (x < 2) {
            return false;
        }
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```

```python
class Solution:
    def isPrime(self, x: int) -> bool:
        if x < 2:
            return False
        i = 2
        while i * i <= x:
            if x % i == 0:
                return False
            i += 1
        return True

    def countPrimeSetBits(self, left: int, right: int) -> int:
        return sum(self.isPrime(x.bit_count()) for x in range(left, right + 1))
```

我们可以枚举$ [\textit{left},\textit{right}]$ 范围内的每个整数，挨个判断是否满足题目要求。

对于每个数 x，我们需要解决两个问题：

如何求出 x 的二进制中的 1 的个数，见「191. 位 1 的个数」，下面代码用库函数实现；
如何判断一个数是否为质数，见「204. 计数质数」的「官方解法」的方法一（注意 0 和 1 不是质数）。

#### 复杂度分析

- 时间复杂度：$O((\textit{right}-\textit{left})\sqrt{\log\textit{right}})$。二进制中 1 的个数为 $O(\log\textit{right})$，判断值为 x 的数是否为质数的时间为 $O(\sqrt{x})$。
- 空间复杂度：O(1)。我们只需要常数的空间保存若干变量。


### 判断质数优化

```c++
class Solution {
public:
    int countPrimeSetBits(int left, int right) {
        int ans = 0;
        for (int x = left; x <= right; ++x) {
            if ((1 << __builtin_popcount(x)) & 665772) {
                ++ans;
            }
        }
        return ans;
    }
};
```

```java
class Solution {
public:
    int countPrimeSetBits(int left, int right) {
        int ans = 0;
        for (int x = left; x <= right; ++x) {
            if ((1 << __builtin_popcount(x)) & 665772) {
                ++ans;
            }
        }
        return ans;
    }
};
```

```python
class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:
        return sum(((1 << x.bit_count()) & 665772) != 0 for x in range(left, right + 1))
```

注意到 $\textit{right} \le 10^6 < 2^{20}$，因此二进制中 1 的个数不会超过 19，而不超过 19 的质数只有
$$
2, 3, 5, 7, 11, 13, 17, 19
$$
我们可以用一个二进制数 $\textit{mask}=665772=10100010100010101100_{2}$来存储这些质数，其中 $\textit{mask}$ 二进制的从低到高的第 i 位为 1 表示 i 是质数，为 0 表示 i 不是质数。

设整数 x 的二进制中 1 的个数为 c，若 $\textit{mask}$ 按位与 $2^c$不为 0，则说明 c 是一个质数。

### 复杂度分析

- 时间复杂度：$O(\textit{right}-\textit{left})$


- 空间复杂度：O(1)。我们只需要常数的空间保存若干变量。


