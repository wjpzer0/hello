# 题目

给定一个长度为偶数的整数数组 `arr`，只有对 `arr` 进行重组后可以满足 “对于每个 `0 <= i < len(arr) / 2`，都有 `arr[2 * i + 1] = 2 * arr[2 * i]`” 时，返回 `true`；否则，返回 `false`。

**示例 1：**

```
输入：arr = [3,1,3,6]
输出：false
```

**示例 2：**

```
输入：arr = [2,1,2,6]
输出：false
```

**示例 3：**

```
输入：arr = [4,-2,2,-4]
输出：true
解释：可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]
```

**提示：**

- `0 <= arr.length <= 3 * 104`
- `arr.length` 是偶数
- $-10^5 <= arr[i] <= 10^5$

## 我的解法

思路没什么问题，但是代码的资源消耗较高，代码还可以优化！

```python
class Solution:
    def canReorderDoubled(self, arr: List[int]) -> bool:
        n = len(arr)
        arr.sort()
        q = []
        print(arr)
        for i in arr:
            if i < 0:
                mid = i / 2
            else:
                mid = i * 2
            if len(q) == 0:
                q.append(mid)
            elif i != q[0]:
                q.append(mid)
            else:
                q.pop(0)

        return len(q) == 0
```

## 其他解法

### 哈希表 + 排序

```c++
class Solution {
public:
    bool canReorderDoubled(vector<int> &arr) {
        unordered_map<int, int> cnt;
        for (int x : arr) {
            ++cnt[x];
        }
        if (cnt[0] % 2) {
            return false;
        }

        vector<int> vals;
        vals.reserve(cnt.size());
        for (auto &[x, _] : cnt) {
            vals.push_back(x);
        }
        sort(vals.begin(), vals.end(), [](int a, int b) { return abs(a) < abs(b); });

        for (int x : vals) {
            if (cnt[2 * x] < cnt[x]) { // 无法找到足够的 2x 与 x 配对
                return false;
            }
            cnt[2 * x] -= cnt[x];
        }
        return true;
    }
};
```

```java
class Solution {
    public boolean canReorderDoubled(int[] arr) {
        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();
        for (int x : arr) {
            cnt.put(x, cnt.getOrDefault(x, 0) + 1);
        }
        if (cnt.getOrDefault(0, 0) % 2 != 0) {
            return false;
        }

        List<Integer> vals = new ArrayList<Integer>();
        for (int x : cnt.keySet()) {
            vals.add(x);
        }
        Collections.sort(vals, (a, b) -> Math.abs(a) - Math.abs(b));

        for (int x : vals) {
            if (cnt.getOrDefault(2 * x, 0) < cnt.get(x)) { // 无法找到足够的 2x 与 x 配对
                return false;
            }
            cnt.put(2 * x, cnt.getOrDefault(2 * x, 0) - cnt.get(x));
        }
        return true;
    }
}
```

```python
class Solution:
    def canReorderDoubled(self, arr: List[int]) -> bool:
        cnt = Counter(arr)
        if cnt[0] % 2:
            return False
        for x in sorted(cnt, key=abs):
            if cnt[2 * x] < cnt[x]:  # 无法找到足够的 2x 与 x 配对
                return False
            cnt[2 * x] -= cnt[x]
        return True
```

设 $\textit{arr}$ 的长度为 n，题目本质上是问 $\textit{arr}$ 能否分成 $\dfrac{n}{2} $对元素，每对元素中一个数是另一个数的两倍。

设 $\textit{cnt}[x]$ 表示 $\textit{arr}$ 中 x 的个数。

对于 $\textit{arr}$ 中的 0，它只能与 0 匹配。如果 $\textit{cnt}[0]$ 是奇数，那么必然无法满足题目要求。

去掉 $\textit{arr}$ 中的 0。设 x 为 $\textit{arr}$ 中绝对值最小的元素，由于没有绝对值比 x 更小的数，因此 x 只能与 2x 匹配。如果此时 $\textit{cnt}[2x] < \textit{cnt}[x]$，那么会有部分 x 无法找到它的另一半，即无法满足题目要求；否则将所有 x 和 $\textit{cnt}[x]$ 个 2x 从 $\textit{arr}$ 中去掉，继续判断剩余元素是否满足题目要求。不断重复此操作，如果某个时刻 $\textit{arr}$ 为空，则说明 $\textit{arr}$ 可以满足题目要求。

代码实现时，我们可以用一个哈希表来统计 $\textit{cnt}$，并将其键值按绝对值从小到大排序，然后模拟上述操作，去掉元素的操作可以改为从 $\textit{cnt}$ 中减去对应值。

#### 复杂度分析

- 时间复杂度：$O(n\log n)$)，其中 n 是数组 $\textit{arr}$ 的长度。最坏情况下哈希表中有 n 个元素，对其排序需要 $O(n\log n)$ 的时间。

- 空间复杂度：O(n)。最坏情况下哈希表中有 n 个元素，需要 O(n) 的空间。


