# 题目

有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。

**示例 1:**

```
输入: k = 5

输出: 9
```

## 我的解法

查看题解，理解后写出！

```python
class Solution:
    def getKthMagicNumber(self, k: int) -> int:
        dp = [0] * k
        dp[0] = 1
        p1 = p2 = p3 = 0
        for i in range(1, k):
            num1, num2, num3 = dp[p1] * 3, dp[p2] * 5, dp[p3] * 7
            mid = min(num1, num2, num3)
            dp[i] = mid
            if dp[i] == num1:
                p1 += 1
            if dp[i] == num2:
                p2 += 1
            if dp[i] == num3:
                p3 += 1
        return dp[k - 1]
```

## 其它解法

### 最小堆

```c++
class Solution {
public:
    int getKthMagicNumber(int k) {
        vector<int> factors = {3, 5, 7};
        unordered_set<long> seen;
        priority_queue<long, vector<long>, greater<long>> heap;
        seen.insert(1L);
        heap.push(1L);
        int magic = 0;
        for (int i = 0; i < k; i++) {
            long curr = heap.top();
            heap.pop();
            magic = (int)curr;
            for (int factor : factors) {
                long next = curr * factor;
                if (!seen.count(next)) {
                    seen.insert(next);
                    heap.push(next);
                }
            }
        }
        return magic;
    }
};
```

```java
class Solution {
    public int getKthMagicNumber(int k) {
        int[] factors = {3, 5, 7};
        Set<Long> seen = new HashSet<Long>();
        PriorityQueue<Long> heap = new PriorityQueue<Long>();
        seen.add(1L);
        heap.offer(1L);
        int magic = 0;
        for (int i = 0; i < k; i++) {
            long curr = heap.poll();
            magic = (int) curr;
            for (int factor : factors) {
                long next = curr * factor;
                if (seen.add(next)) {
                    heap.offer(next);
                }
            }
        }
        return magic;
    }
}
```

```python
class Solution:
    def getKthMagicNumber(self, k: int) -> int:
        factors = [3, 5, 7]
        seen = {1}
        heap = [1]

        for i in range(k - 1):
            curr = heapq.heappop(heap)
            for factor in factors:
                if (nxt := curr * factor) not in seen:
                    seen.add(nxt)
                    heapq.heappush(heap, nxt)

        return heapq.heappop(heap)
```

要得到从小到大的第 k 个数，可以使用最小堆实现。

初始时堆为空。首先将最小的数 1 加入堆。

每次取出堆顶元素 x，则 x 是堆中最小的数，由于 3x, 5x, 7x 也是符合要求的数，因此将 3x, 5x, 7x 加入堆。

上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。

在排除重复元素的情况下，第 k 次从最小堆中取出的元素即为第 k 个数。

![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p1.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p2.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p3.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p4.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p5.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p6.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p7.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p8.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p9.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p10.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p11.png)

#### 复杂度分析

- 时间复杂度：$O(k \log k)$。得到第 k 个数需要进行 k 次循环，每次循环都要从最小堆中取出 1 个元素以及向最小堆中加入最多 3 个元素，因此每次循环的时间复杂度是 $O(\log (3k) + 3 \log (3k))=O(\log k)$，总时间复杂度是 $O(k \log k)$。

- 空间复杂度：O(k)。空间复杂度主要取决于最小堆和哈希集合的大小，最小堆和哈希集合的大小都不会超过 3k。

### 动态规划

```c++
class Solution {
public:
    int getKthMagicNumber(int k) {
        vector<int> dp(k + 1);
        dp[1] = 1;
        int p3 = 1, p5 = 1, p7 = 1;
        for (int i = 2; i <= k; i++) {
            int num3 = dp[p3] * 3, num5 = dp[p5] * 5, num7 = dp[p7] * 7;
            dp[i] = min(min(num3, num5), num7);
            if (dp[i] == num3) {
                p3++;
            }
            if (dp[i] == num5) {
                p5++;
            }
            if (dp[i] == num7) {
                p7++;
            }
        }
        return dp[k];
    }
};
```

```java
class Solution {
    public int getKthMagicNumber(int k) {
        int[] dp = new int[k + 1];
        dp[1] = 1;
        int p3 = 1, p5 = 1, p7 = 1;
        for (int i = 2; i <= k; i++) {
            int num3 = dp[p3] * 3, num5 = dp[p5] * 5, num7 = dp[p7] * 7;
            dp[i] = Math.min(Math.min(num3, num5), num7);
            if (dp[i] == num3) {
                p3++;
            }
            if (dp[i] == num5) {
                p5++;
            }
            if (dp[i] == num7) {
                p7++;
            }
        }
        return dp[k];
    }
}
```

```python
class Solution:
    def getKthMagicNumber(self, k: int) -> int:
        dp = [0] * (k + 1)
        dp[1] = 1
        p3 = p5 = p7 = 1

        for i in range(2, k + 1):
            num3, num5, num7 = dp[p3] * 3, dp[p5] * 5, dp[p7] * 7
            dp[i] = min(num3, num5, num7)
            if dp[i] == num3:
                p3 += 1
            if dp[i] == num5:
                p5 += 1
            if dp[i] == num7:
                p7 += 1
        
        return dp[k]
```

方法一使用最小堆，会预先存储较多的数，维护最小堆的过程也导致时间复杂度较高。可以使用动态规划的方法进行优化。

定义数组 $\textit{dp}$，其中 $\textit{dp}[i]$ 表示第 i 个数，第 k 个数即为 $\textit{dp}[k]$。

由于最小的数是 1，因此 $\textit{dp}[1]=1$。

如何得到其余的数呢？定义三个指针$ p_3,p_5,p_7$，表示下一个数是当前指针指向的数乘以对应的质因数。初始时，三个指针的值都是 1。

当 $2 \le i \le k$ 时，令 $\textit{dp}[i]=\min(\textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5, \textit{dp}[p_7] \times 7)$，然后分别比较 $\textit{dp}[i]$ 和 $\textit{dp}[p_3] \times 3,\textit{dp}[p_5] \times 5,\textit{dp}[p_7] \times 7$ 是否相等，如果相等则将对应的指针加 1。

#### 正确性证明

对于 i>1，在计算 $\textit{dp}[i]$ 时，指针 $p_x(x \in \{3,5,7\})$ 的含义是使得 $\textit{dp}[j] \times x>\textit{dp}[i-1]$ 的最小的下标 j，即当 $j \ge p_x$ 时 $\textit{dp}[j] \times x>\textit{dp}[i-1]$，当 $j<p_x$ 时 $\textit{dp}[j] \times x \le \textit{dp}[i-1]$。

因此，对于 i>1，在计算 $\textit{dp}[i]$ 时，$\textit{dp}[p_3] \times 3,\textit{dp}[p_5] \times 5,\textit{dp}[p_7] \times 7$ 都大于$ \textit{dp}[i-1]$，$\textit{dp}[p_3-1] \times 3,\textit{dp}[p_5-1] \times 5,\textit{dp}[p_7-1] \times 7$ 都小于或等于 $\textit{dp}[i-1]$。令 $\textit{dp}[i]=\min(\textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5, \textit{dp}[p_7] \times 7)$，则 $\textit{dp}[i]>\textit{dp}[i-1]$ 且 $\textit{dp}[i]$ 是大于 $\textit{dp}[i-1]$ 的最小的数。

在计算 $\textit{dp}[i]$ 之后，会更新三个指针$ p_3,p_5,p_7$，更新之后的指针将用于计算 $\textit{dp}[i+1]$，同样满足$ \textit{dp}[i+1]>\textit{dp}[i]$ 且 $\textit{dp}[i+1]$ 是大于 $\textit{dp}[i]$ 的最小的数。

![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p12.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p13.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p14.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p15.png)
![img](https://assets.leetcode-cn.com/solution-static/jindian_17.09/p16.png)

#### 复杂度分析

- 时间复杂度：O(k)。需要计算数组 $\textit{dp}$中的 k 个元素，每个元素的计算都可以在 O(1) 的时间内完成。

- 空间复杂度：O(k)。空间复杂度主要取决于数组 $\textit{dp}$的大小。


