# 题目

在一个 `n x n` 的矩阵 `grid` 中，除了在数组 `mines` 中给出的元素为 `0`，其他每个元素都为 `1`。`mines[i] = [xi, yi]`表示 `grid[xi][yi] == 0`

返回 `grid` *中包含 `1` 的最大的 **轴对齐** 加号标志的阶数* 。如果未找到加号标志，则返回 `0` 。

一个 `k` 阶由 *`1`* 组成的 **“轴对称”加号标志** 具有中心网格 `grid[r][c] == 1` ，以及4个从中心向上、向下、向左、向右延伸，长度为 `k-1`，由 `1` 组成的臂。注意，只有加号标志的所有网格要求为 `1` ，别的网格可能为 `0` 也可能为 `1` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg)

```
输入: n = 5, mines = [[4, 2]]
输出: 2
解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg)

```
输入: n = 1, mines = [[0, 0]]
输出: 0
解释: 没有加号标志，返回 0 。
```

**提示：**

- `1 <= n <= 500`
- `1 <= mines.length <= 5000`
- `0 <= xi, yi < n`
- 每一对 `(xi, yi)` 都 **不重复**

## 我的解法

超时！

```python
class Solution:
    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:
        k = (n - 1) // 2
        matrix = [[1] * n for i in range(n)]
        for mine in mines:
            x = mine[0]
            y = mine[1]
            matrix[x][y] = 0

        for i in range(k, -1, -1):
            for x in range(i, n - i):
                for y in range(i, n - i):
                    mid = matrix[x][y]
                    for j in range(1, i + 1):
                        mid *= matrix[x + j][y]
                        mid *= matrix[x - j][y]
                        mid *= matrix[x][y + j]
                        mid *= matrix[x][y - j]
                    if mid == 1:
                        return i + 1
        return 0
```

## 其它解法

### 动态规划

```c++
class Solution {
public:
    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {
        vector<vector<int>> dp(n, vector<int>(n, n));
        unordered_set<int> banned;
        for (auto &&vec : mines) {
            banned.emplace(vec[0] * n + vec[1]);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int count = 0;
            /* left */
            for (int j = 0; j < n; j++) {
                if (banned.count(i * n + j)) {
                    count = 0;
                } else {
                    count++;
                }
                dp[i][j] = min(dp[i][j], count);
            }
            count = 0;
            /* right */ 
            for (int j = n - 1; j >= 0; j--) {
                if (banned.count(i * n + j)) {
                    count = 0;
                } else {
                    count++;
                }
                dp[i][j] = min(dp[i][j], count);
            }
        }
        for (int i = 0; i < n; i++) {
            int count = 0;
            /* up */
            for (int j = 0; j < n; j++) {
                if (banned.count(j * n + i)) {
                    count = 0;
                } else {
                    count++;
                }
                dp[j][i] = min(dp[j][i], count);
            }
            count = 0;
            /* down */
            for (int j = n - 1; j >= 0; j--) {
                if (banned.count(j * n + i)) {
                    count = 0;
                } else {
                    count++;
                }
                dp[j][i] = min(dp[j][i], count);
                ans = max(ans, dp[j][i]);
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    public int orderOfLargestPlusSign(int n, int[][] mines) {
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], n);
        }
        Set<Integer> banned = new HashSet<Integer>();
        for (int[] vec : mines) {
            banned.add(vec[0] * n + vec[1]);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int count = 0;
            /* left */
            for (int j = 0; j < n; j++) {
                if (banned.contains(i * n + j)) {
                    count = 0;
                } else {
                    count++;
                }
                dp[i][j] = Math.min(dp[i][j], count);
            }
            count = 0;
            /* right */ 
            for (int j = n - 1; j >= 0; j--) {
                if (banned.contains(i * n + j)) {
                    count = 0;
                } else {
                    count++;
                }
                dp[i][j] = Math.min(dp[i][j], count);
            }
        }
        for (int i = 0; i < n; i++) {
            int count = 0;
            /* up */
            for (int j = 0; j < n; j++) {
                if (banned.contains(j * n + i)) {
                    count = 0;
                } else {
                    count++;
                }
                dp[j][i] = Math.min(dp[j][i], count);
            }
            count = 0;
            /* down */
            for (int j = n - 1; j >= 0; j--) {
                if (banned.contains(j * n + i)) {
                    count = 0;
                } else {
                    count++;
                }
                dp[j][i] = Math.min(dp[j][i], count);
                ans = Math.max(ans, dp[j][i]);
            }
        }
        return ans;
    }
}
```

```python
class Solution:
    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:
        dp = [[n] * n for _ in range(n)]
        banned = set(map(tuple, mines))
        for i in range(n):
            # left
            count = 0
            for j in range(n):
                count = 0 if (i, j) in banned else count + 1
                dp[i][j] = min(dp[i][j], count)
            # right
            count = 0
            for j in range(n - 1, -1, -1):
                count = 0 if (i, j) in banned else count + 1
                dp[i][j] = min(dp[i][j], count)
        for j in range(n):
            # up
            count = 0
            for i in range(n):
                count = 0 if (i, j) in banned else count + 1
                dp[i][j] = min(dp[i][j], count)
            # down
            count = 0
            for i in range(n - 1, -1, -1):
                count = 0 if (i, j) in banned else count + 1
                dp[i][j] = min(dp[i][j], count)
        return max(map(max, dp))
```

#### 思路与算法

对于每个中心点坐标 (i,j)，分别从上下左右四个方向计算从 (i,j) 开始最长连续 1 的个数。设 $\textit{dp}[i][j][k]$ 表示以 (i,j) 为起点在方向 k 上的连续 1 的最大数目：

如果 $\textit{grid}[i][j]$为 0，那么此时该方向的连续 1 的最大数目为 0；
如果 $\textit{grid}[i][j]$为 1, 那么此时该方向的连续 1 的最大数目为该方向上前一个单元为起点的最大数目加 1；
假设当前 k=0,1,2,3k = 0,1,2,3k=0,1,2,3 时，分别表示方向为左、右、上、下，则我们可以得到递推公式如下：
$$
\textit{dp}[i][j][0] = \begin{cases} 0, & \textit{grid}[i][j] = 0 \\ \textit{dp}[i][j-1][0] + 1 , & \textit{grid}[i][j] = 1 \\ \end{cases} \\ \textit{dp}[i][j][1] = \begin{cases} 0, & \textit{grid}[i][j] = 0 \\ \textit{dp}[i][j+1][1] + 1 , & \textit{grid}[i][j] = 1 \\ \end{cases} \\ \textit{dp}[i][j][2] = \begin{cases} 0, & \textit{grid}[i][j] = 0 \\ \textit{dp}[i-1][j][2] + 1 , & \textit{grid}[i][j] = 1 \\ \end{cases} \\ \textit{dp}[i][j][3] = \begin{cases} 0, & \textit{grid}[i][j] = 0 \\ \textit{dp}[i+1][j][3] + 1 , & \textit{grid}[i][j] = 1 \\ \end{cases} \\
$$
假设网格中有一行为 $\texttt{01110110}$，当前方向为向左，那么对应的连续 1 的个数就是 012301201。以每个点为 (i,j) 为中心的四个方向中最小连续 1 的个数即为以其为中心构成的加号标志的最大阶数，我们用公式表示 $L = \min\limits_{k=0}^{3}\textit{dp}[i][j][k]$ 。在实际计算时，我们为了方便计算只用 $\textit{dp}[i][j]$保存四个方向中最小的连续 1 的个数即可。

### 复杂度分析

- 时间复杂度：$O(n^2)$，其中 n 表示矩阵的行数。我们最多需要遍历 4 次即可计算出每个点上的 4 方向上连续 1 的最大数目，因此需要的时间为$ O(n^2)$。

- 空间复杂度：$O(n^2)$。我们需要保存每个点上的 4 方向上连续 1 的最小数目即可，需要的空间为 $O(n^2)$。

