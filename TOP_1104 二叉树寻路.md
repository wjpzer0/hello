# 题目

在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 **逐行** 依次按 “之” 字形进行标记。

如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；

而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/28/tree.png)

给你树上某一个节点的标号 `label`，请你返回从根节点到该标号为 `label` 节点的路径，该路径是由途经的节点标号所组成的。

**示例 1：**

```
输入：label = 14
输出：[1,3,4,14]
```

**示例 2：**

```
输入：label = 26
输出：[1,2,6,10,26]
```

**提示：**

- $1 <= label <= 10^6$

## 我的解法

未解出，思绪混乱！

## 其他解法

### 数学

```c++
class Solution {
public:
    int getReverse(int label, int row) {
        return (1 << row - 1) + (1 << row) - 1 - label;
    }

    vector<int> pathInZigZagTree(int label) {
        int row = 1, rowStart = 1;
        while (rowStart * 2 <= label) {
            row++;
            rowStart *= 2;
        }
        if (row % 2 == 0) {
            label = getReverse(label, row);
        }
        vector<int> path;
        while (row > 0) {
            if (row % 2 == 0) {
                path.push_back(getReverse(label, row));
            } else {
                path.push_back(label);
            }
            row--;
            label >>= 1;
        }
        reverse(path.begin(), path.end());
        return path;
    }
};
```

```java
class Solution {
    public List<Integer> pathInZigZagTree(int label) {
        int row = 1, rowStart = 1;
        while (rowStart * 2 <= label) {
            row++;
            rowStart *= 2;
        }
        if (row % 2 == 0) {
            label = getReverse(label, row);
        }
        List<Integer> path = new ArrayList<Integer>();
        while (row > 0) {
            if (row % 2 == 0) {
                path.add(getReverse(label, row));
            } else {
                path.add(label);
            }
            row--;
            label >>= 1;
        }
        Collections.reverse(path);
        return path;
    }

    public int getReverse(int label, int row) {
        return (1 << row - 1) + (1 << row) - 1 - label;
    }
}
```

```python
class Solution:
    def pathInZigZagTree(self, label: int) -> List[int]:
        path = []
        row = 1
        rowstart = 1
        while rowstart *2 <= label:
            row += 1
            rowstart *=2

        def getReverse(label, row):
            return (1 << row - 1) + (1 << row) - 1 - label

        if row % 2 == 0:
            label = getReverse(label, row)
        
        while row > 0:
            if row % 2 == 0:
                path.append(getReverse(label, row))
            else:
                path.append(label)
            row -= 1
            label >>= 1
        
        path.reverse()
        return path
```

我们先来研究一个简单的情形：二叉树的每一行都是按从左到右的顺序进行标记。此时二叉树满足以下性质：

根节点位于第 1 行；

- 第 i 行有 $2^{i-1}$个节点，最左边的节点标号为 $2^{i-1}$，最右边的节点标号为 $2^i-1$；

- 对于标号为 $\textit{val}$ 的节点，其左子节点的标号为 $2 \times \textit{val}$​，右子节点的标号为$ 2 \times \textit{val} + 1$​，当 $\textit{val}>1$​​1 时，其父节点的标号为 $\lfloor \frac{\textit{val}}{2} \rfloor$。
- 对于给定节点的标号 $\textit{label}$​，可以根据上述性质得到从该节点到根节点的路径，将路径反转后，即为从根节点到标号 $\textit{label}$​ 的节点的路径。


回到这题，对于偶数行按从右到左的顺序进行标记的情况，可以转换成按从左到右的顺序进行标记的情况，然后按照上述思路得到路径，只要对偶数行的标号进行转换即可。为了表述简洁，下文将按从左到右的顺序进行标记时的节点的标号称为「从左到右标号」。

首先找到标号为 $\textit{label}$​ 的节点所在的行和该节点的「从左到右标号」。为了找到节点所在行，需要找到 i 满足 $2^{i-1} \le \textit{label} < 2^i$，则该节点在第 i 行。该节点的「从左到右标号」需要根据 i 的奇偶性计算：

- 当 i 是奇数时，第 i 行为按从左到右的顺序进行标记，因此该节点的「从左到右标号」即为 $\textit{label}$；

- 当 i 是偶数时，第 i 行为按从右到左的顺序进行标记，将整行的标号左右翻转之后得到按从左到右的顺序进行标记的标号，对于同一个节点，其翻转前后的标号之和为 $2^{i-1} + 2^i - 1$​，因此标号为 $\textit{label}$ 的节点的「从左到右标号」为 $2^{i-1} + 2^i - 1 - \textit{label}$。

得到标号为 $\textit{label}$ 的节点的「从左到右标号」之后，即可得到从该节点到根节点的路径，以及路径上的每个节点的「从左到右标号」。对于路径上的每个节点，需要根据节点所在行的奇偶性，得到该节点的实际标号：

- 当 i 是奇数时，第 i 行的每个节点的「从左到右标号」即为该节点的实际标号；

- 当 i 是偶数时，如果第 i 行的一个节点的「从左到右标号」为 $\textit{val}$，则该节点的实际标号为 $2^{i-1} + 2^i - 1 - \textit{val}$。


最后，将路径反转，即可得到从根节点到标号 $\textit{label}$ 的节点的路径。

#### 复杂度分析

- 时间复杂度：$O(\log \textit{label})$。标号为 $\textit{label}$ 的节点所在的行数为 $O(\log \textit{label})$，因此从根节点到标号 $\textit{label}$ 的节点的路径的长度为$ O(\log \textit{label})$，路径中的每个节点的标号都可以在 O(1) 时间内计算得到。

- 空间复杂度：O(1)。除了返回值以外，额外使用的空间为常数。


