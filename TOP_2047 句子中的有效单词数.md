# 题目

句子仅由小写字母（`'a'` 到 `'z'`）、数字（`'0'` 到 `'9'`）、连字符（`'-'`）、标点符号（`'!'`、`'.'` 和 `','`）以及空格（`' '`）组成。每个句子可以根据空格分解成 **一个或者多个 token** ，这些 token 之间由一个或者多个空格 `' '` 分隔。

如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：

- 仅由小写字母、连字符和/或标点（不含数字）。
- **至多一个** 连字符 `'-'` 。如果存在，连字符两侧应当都存在小写字母（`"a-b"` 是一个有效单词，但 `"-ab"` 和 `"ab-"` 不是有效单词）。
- **至多一个** 标点符号。如果存在，标点符号应当位于 token 的 **末尾** 。

这里给出几个有效单词的例子：`"a-b."`、`"afad"`、`"ba-c"`、`"a!"` 和 `"!"` 。

给你一个字符串 `sentence` ，请你找出并返回 `sentence` 中 **有效单词的数目** 。

 

**示例 1：**

```
输入：sentence = "cat and  dog"
输出：3
解释：句子中的有效单词是 "cat"、"and" 和 "dog"
```

**示例 2：**

```
输入：sentence = "!this  1-s b8d!"
输出：0
解释：句子中没有有效单词
"!this" 不是有效单词，因为它以一个标点开头
"1-s" 和 "b8d" 也不是有效单词，因为它们都包含数字
```

**示例 3：**

```
输入：sentence = "alice and  bob are playing stone-game10"
输出：5
解释：句子中的有效单词是 "alice"、"and"、"bob"、"are" 和 "playing"
"stone-game10" 不是有效单词，因为它含有数字
```

**示例 4：**

```
输入：sentence = "he bought 2 pencils, 3 erasers, and 1  pencil-sharpener."
输出：6
解释：句子中的有效单词是 "he"、"bought"、"pencils,"、"erasers,"、"and" 和 "pencil-sharpener."
```

**提示：**

- `1 <= sentence.length <= 1000`
- `sentence` 由小写英文字母、数字（`0-9`）、以及字符（`' '`、`'-'`、`'!'`、`'.'` 和 `','`）组成
- 句子中至少有 `1` 个 token

## 我的解法

一步一步来！

```python
class Solution:
    def countValidWords(self, sentence: str) -> int:
        wordList = sentence.split()
        ans = 0
        for word in wordList:
            flag = True
            hyphen = 0
            punctuation = 0
            for idx, s in enumerate(word):
                if s in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']:
                    flag = False
                    break
                if s == '-':
                    hyphen += 1
                if s in ['!', '.', ',']:
                    punctuation += 1
                if hyphen > 1 or punctuation > 1:
                    flag = False
                    break
                if s == '-' and (idx == 0 or idx == len(word) - 1 or (not word[idx - 1].isalpha()) or (not word[idx + 1].isalpha())):
                    flag = False
                    break
                if s in ['!', '.', ','] and idx != len(word) - 1:
                    flag = False
                    break

            if flag:
                ans += 1
        return ans
```

可以使用正则表达式！

- [a-z]* 匹配任意多的小写字母'a'到'z'
- ([a-z]-[a-z]+)? 有问号，整体可以不存在，也可以出现一次。以小写字母-小写字母出现
- [!.,]?$ 结尾可以为三种符号中的一种

```python
class Solution:
    def countValidWords(self, sentence: str) -> int:
        return sum(bool(re.match(r'[a-z]*([a-z]-[a-z]+)?[!.,]?$', word)) for word in sentence.split(" ") if word)
```

## 其他解法

### 遍历

```c++
class Solution {
public:
    int countValidWords(string sentence) {
        int n = sentence.length();
        int l = 0, r = 0;
        int ret = 0;
        string_view slice(sentence);
        while (true) {
            while (l < n && sentence[l] == ' ') {
                l++;
            }
            if (l >= n) {
                break;
            }
            r = l + 1;
            while (r < n && sentence[r] != ' ') {
                r++;
            }
            if (isValid(slice.substr(l, r - l))) { // 判断根据空格分解出来的 token 是否有效
                ret++;
            }
            l = r + 1;
        }
        return ret;
    }

    bool isValid(const string_view &word) {
        int n = word.length();
        bool has_hyphens = false;
        for (int i = 0; i < n; i++) {
            if (word[i] >= '0' && word[i] <= '9') {
                return false;
            } else if (word[i] == '-') {
                if (has_hyphens == true || i == 0 || i == n - 1 || !islower(word[i - 1]) || !islower(word[i + 1])) {
                    return false;
                }
                has_hyphens = true;
            } else if (word[i] == '!' || word[i] == '.' || word[i] == ',') {
                if (i != n - 1) {
                    return false;
                }
            }
        }
        return true;
    }
};
```

```java
class Solution {
    public int countValidWords(String sentence) {
        int n = sentence.length();
        int l = 0, r = 0;
        int ret = 0;
        while (true) {
            while (l < n && sentence.charAt(l) == ' ') {
                l++;
            }
            if (l >= n) {
                break;
            }
            r = l + 1;
            while (r < n && sentence.charAt(r) != ' ') {
                r++;
            }
            if (isValid(sentence.substring(l, r))) { // 判断根据空格分解出来的 token 是否有效
                ret++;
            }
            l = r + 1;
        }
        return ret;
    }

    public boolean isValid(String word) {
        int n = word.length();
        boolean hasHyphens = false;
        for (int i = 0; i < n; i++) {
            if (Character.isDigit(word.charAt(i))) {
                return false;
            } else if (word.charAt(i) == '-') {
                if (hasHyphens == true || i == 0 || i == n - 1 || !Character.isLetter(word.charAt(i - 1)) || !Character.isLetter(word.charAt(i + 1))) {
                    return false;
                }
                hasHyphens = true;
            } else if (word.charAt(i) == '!' || word.charAt(i) == '.' || word.charAt(i) == ',') {
                if (i != n - 1) {
                    return false;
                }
            }
        }
        return true;
    }
}
```

```python
class Solution:
    def countValidWords(self, sentence: str) -> int:
        def valid(s: str) -> bool:
            hasHyphens = False
            for i, ch in enumerate(s):
                if ch.isdigit() or ch in "!.," and i < len(s) - 1:
                    return False
                if ch == '-':
                    if hasHyphens or i == 0 or i == len(s) - 1 or not s[i - 1].islower() or not s[i + 1].islower():
                        return False
                    hasHyphens = True
            return True

        return sum(valid(s) for s in sentence.split())
```

#### 思路与算法

首先将句子按空格分隔成单词，然后判断单词是否有效。由题意知，单词不有效的条件为以下其中之一：

- 单词中包含数字；

- 单词中包含两个以上连字符；

- 连字符在单词头部或者单词末尾；

- 连字符的左/右边字符不是小写字母；

- 单词中的标点符号不在单词的末尾。


记录有效的单词的个数，即为答案。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是句子的长度。切分整个句子，并处理单词需要 O(n)。

- 空间复杂度：O(1)。只需要常数空间保存变量。


### 正则表达式

#### 解题思路

正则表达式规则:
\：\字符能够改变字符原本的含义

^：^字符指示字符串的头，且要求字符串以字符开头，不占位。^表示一个真正的^符号。

：：字符指示字符串的尾，且要求字符串以字符结尾，不占位。$表示一个真正的$符号。

()：分组，大正则中包含小正则。可以改变默认的优先级。在模式中可以使用\1来表示第一组已然捕获到的东西。

\b：指示字符串的边界（头/尾/空格左/空格右），字符\b要求边界的左边是字符，\b字符要求边界的右边是字符。

.：表示一个除了\n以外的任意一个字符。.表示一个真正的.符号。

|：字符串1|字符串2表示一个字符串，该字符串是字符串1、字符串2中的一个。|在正则中的优先级比较混乱，所以建议加上足够多的括号来分组。

[]：[字符1字符2字符3...]表示一个字符，该字符是字符1、字符2、字符3……中的某一个。中括号中出现的所有字符都是代表本身意思的字符（没有特殊含义），如[.]只能匹配.符号，而不能匹配任意符号。

[^字符1字符2字符3...]表示一个字符，该字符不是字符1、字符2、字符3……中的任何一个

[a-z]表示一个字符，该字符是a、b、c……z中的某一个

[^a-z]表示一个字符，该字符不是a、b、c……z中的任何一个

\w：表示一个字符，该字符是数字、字母、下划线中的某一个。等价于[(0-9)(a-z)(A-Z)(_)]

\W：表示一个字符，该字符不是数字、字母、下划线中的任何一个。等价于[]

\d表示一个字符，该字符是0、1、2……9中的某一个

\D表示一个字符，该字符不是0、1、2……9中的任何一个

\s表示一个字符，该字符是空白符（空格、制表符、换页符）2、代表出现次数的

量词元字符
：字符要求字符出现0到多次

+：字符+要求字符出现1到多次

?：字符?要求字符出现0次或1次

{n}：字符{n}要求字符出现n次

{n,}：字符{n,}要求字符出现n到多次

{n,m}：字符{n,m}要求字符出现n到m次、

```c++
#include <regex>
class Solution {
public:
    int countValidWords(string sentence) {
        regex r1("(([a-z]+-)?[a-z]+)?[!,.]?");            //定义匹配pattern
        istringstream iss(sentence);
        int ans=0;
        string word;
        while(iss>>word){
            if(regex_match(word,r1)){
                ans++;
            }
        }
        return ans;
    }
};
```

