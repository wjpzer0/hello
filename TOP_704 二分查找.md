# 题目

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。
**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

## 我的解法

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0,  r = nums.size() - 1;
        while (l <= r)
        {
            int mid = (r - l) / 2 + l;
            if (nums[mid] == target)
            {
                return mid;
            }
            else if (nums[mid] < target)
            {
                l = mid + 1;
            }
            else if (nums[mid] > target)
            {
                r = mid - 1;
            }       
        } 
        return -1;
    }
};
```

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (r - l) // 2 + l
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                l = mid + 1
            elif nums[mid] > target:
                r = mid - 1
        return -1
```

问题不大！

添加注释和理解的代码！

```c++
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

```c++
// 版本二
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

## 其他解法

### 二分查找

```java
class Solution {
    public int search(int[] nums, int target) {
        int low = 0, high = nums.length - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            int num = nums[mid];
            if (num == target) {
                return mid;
            } else if (num > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
}
```

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        low, high = 0, len(nums) - 1
        while low <= high:
            mid = (high - low) // 2 + low
            num = nums[mid]
            if num == target:
                return mid
            elif num > target:
                high = mid - 1
            else:
                low = mid + 1
        return -1
```

在升序数组 $\textit{nums}$ 中寻找目标值 $\textit{target}$，对于特定下标 $i$，比较 $\textit{nums}[i]$ 和 $\textit{target}$ 的大小：

- 如果 $\textit{nums}[i] = \textit{target}$，则下标 $i$ 即为要寻找的下标；

- 如果 $\textit{nums}[i] > \textit{target}$，则 $\textit{target}$ 只可能在下标 $i$ 的左侧；

- 如果 $\textit{nums}[i] < \textit{target}$，则 $\textit{target}$ 只可能在下标 $i$ 的右侧。


基于上述事实，可以在有序数组中使用二分查找寻找目标值。

二分查找的做法是，定义查找的范围 $[\textit{left}, \textit{right}]$，初始查找范围是整个数组。每次取查找范围的中点 $\textit{mid}$，比较 $\textit{nums}[\textit{mid}]$ 和 $\textit{target}$ 的大小，如果相等则 $\textit{mid}$ 即为要寻找的下标，如果不相等则根据 $\textit{nums}[\textit{mid}]$ 和 $\textit{target}$ 的大小关系将查找范围缩小一半。

由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 $O(\log n)$，其中 n 是数组的长度。

二分查找的条件是查找范围不为空，即 $\textit{left} \le \textit{right}$。如果 $\textit{target}$ 在数组中，二分查找可以保证找到 $\textit{target}$，返回 $\textit{target}$ 在数组中的下标。如果 $\textit{target}$ 不在数组中，则当 $\textit{left} > \textit{right}$ 时结束查找，返回 $-1$。

#### **复杂度分析**

- 时间复杂度：$O(\log n)$，其中 n 是数组的长度。
- 空间复杂度：O(1)。

