# 题目

城市用一个 **双向连通** 图表示，图中有 `n` 个节点，从 `1` 到 `n` 编号（包含 `1` 和 `n`）。图中的边用一个二维整数数组 `edges` 表示，其中每个 `edges[i] = [ui, vi]` 表示一条节点 `ui` 和节点 `vi` 之间的双向连通边。每组节点对由 **最多一条** 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 `time` 分钟。

每个节点都有一个交通信号灯，每 `change` 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 **同时** 改变。你可以在 **任何时候** 进入某个节点，但是 **只能** 在节点 **信号灯是绿色时** 才能离开。如果信号灯是 **绿色** ，你 **不能** 在节点等待，必须离开。

**第二小的值** 是 **严格大于** 最小值的所有值中最小的值。

- 例如，`[2, 3, 4]` 中第二小的值是 `3` ，而 `[2, 2, 4]` 中第二小的值是 `4` 。

给你 `n`、`edges`、`time` 和 `change` ，返回从节点 `1` 到节点 `n` 需要的 **第二短时间** 。

**注意：**

- 你可以 **任意次** 穿过任意顶点，**包括** `1` 和 `n` 。
- 你可以假设在 **启程时** ，所有信号灯刚刚变成 **绿色** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/09/29/e1.png)       ![img](https://assets.leetcode.com/uploads/2021/09/29/e2.png)

```
输入：n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
输出：13
解释：
上面的左图展现了给出的城市交通图。
右图中的蓝色路径是最短时间路径。
花费的时间是：
- 从节点 1 开始，总花费时间=0
- 1 -> 4：3 分钟，总花费时间=3
- 4 -> 5：3 分钟，总花费时间=6
因此需要的最小时间是 6 分钟。

右图中的红色路径是第二短时间路径。
- 从节点 1 开始，总花费时间=0
- 1 -> 3：3 分钟，总花费时间=3
- 3 -> 4：3 分钟，总花费时间=6
- 在节点 4 等待 4 分钟，总花费时间=10
- 4 -> 5：3 分钟，总花费时间=13
因此第二短时间是 13 分钟。      
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/09/29/eg2.png)

```
输入：n = 2, edges = [[1,2]], time = 3, change = 2
输出：11
解释：
最短时间路径是 1 -> 2 ，总花费时间 = 3 分钟
最短时间路径是 1 -> 2 -> 1 -> 2 ，总花费时间 = 11 分钟
```

**提示：**

- $2 <= n <= 10^4$
- $n - 1 <= edges.length <= min(2 * 10^4, n * (n - 1) / 2)$
- `edges[i].length == 2`
- `1 <= ui, vi <= n`
- `ui != vi`
- 不含重复边
- 每个节点都可以从其他节点直接或者间接到达
- $1 <= time, change <= 10^3$

## 我的解法

未解出，废物一个！

### 大佬的解析

首先明确一点，路径越长耗费的时间越多，那么这题就可以简化为一个求次短路径的问题，由于本题的路径是无权的（unweighted），直接想到用BFS求解。

那么问题来了，如何找次短而不是最短。先考虑最短路径，很明显，在最短路径中每个节点最多访问一次。我们可以在每个节点最多访问两次的条件下找到次短路径（若次短路径上的某个节点访问超过两次，可将访问次数降至两次以内且不改变路径长度）。在BFS过程中增加visited和log保证节点的访问次数不会超过两次，且在一次BFS的层遍历过程中不会重复添加节点至队列（包括目的节点）。

说明： 如果路径上某个节点访问次数为两次，那么这条路径必不是最短路径（可能是次短路径），如果路径上某个节点访问超过两次，那么我们可以减少该节点访问次数至两次以内的同时不改变路径长度，所以搜索次短路径的条件是每个节点最多访问两次。

TIPS: 单源最短路径的几种求解算法

- 无权，采用BFS
- 有权，权重均为非负，采用dijkstra
- 有权，权重包含负值，采用bellman-ford

## 其他解法

### 广度优先搜索

```c++
class Solution {
public:
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
        vector<vector<int>> graph(n + 1);
        for (auto &e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }

        // path[i][0] 表示从 1 到 i 的最短路长度，path[i][1] 表示从 1 到 i 的严格次短路长度
        vector<vector<int>> path(n + 1, vector<int>(2, INT_MAX));
        path[1][0] = 0;
        queue<pair<int, int>> q;
        q.push({1, 0});
        while (path[n][1] == INT_MAX) {
            auto [cur, len] = q.front();
            q.pop();
            for (auto next : graph[cur]) {
                if (len + 1 < path[next][0]) {
                    path[next][0] = len + 1;
                    q.push({next, len + 1});
                } else if (len + 1 > path[next][0] && len + 1 < path[next][1]) {
                    path[next][1] = len + 1;
                    q.push({next, len + 1});
                }
            }
        }

        int ret = 0;
        for (int i = 0; i < path[n][1]; i++) {
            if (ret % (2 * change) >= change) {
                ret = ret + (2 * change - ret % (2 * change));
            }
            ret = ret + time;
        }
        return ret;
    }
};
```

```java
class Solution {
public:
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
        vector<vector<int>> graph(n + 1);
        for (auto &e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }

        // path[i][0] 表示从 1 到 i 的最短路长度，path[i][1] 表示从 1 到 i 的严格次短路长度
        vector<vector<int>> path(n + 1, vector<int>(2, INT_MAX));
        path[1][0] = 0;
        queue<pair<int, int>> q;
        q.push({1, 0});
        while (path[n][1] == INT_MAX) {
            auto [cur, len] = q.front();
            q.pop();
            for (auto next : graph[cur]) {
                if (len + 1 < path[next][0]) {
                    path[next][0] = len + 1;
                    q.push({next, len + 1});
                } else if (len + 1 > path[next][0] && len + 1 < path[next][1]) {
                    path[next][1] = len + 1;
                    q.push({next, len + 1});
                }
            }
        }

        int ret = 0;
        for (int i = 0; i < path[n][1]; i++) {
            if (ret % (2 * change) >= change) {
                ret = ret + (2 * change - ret % (2 * change));
            }
            ret = ret + time;
        }
        return ret;
    }
};
```

```python
class Solution:
    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        graph = [[] for _ in range(n + 1)]
        for e in edges:
            x, y = e[0], e[1]
            graph[x].append(y)
            graph[y].append(x)

        # dist[i][0] 表示从 1 到 i 的最短路长度，dist[i][1] 表示从 1 到 i 的严格次短路长度
        dist = [[float('inf')] * 2 for _ in range(n + 1)]
        dist[1][0] = 0
        q = deque([(1, 0)])
        while dist[n][1] == float('inf'):
            p = q.popleft()
            for y in graph[p[0]]:
                d = p[1] + 1
                if d < dist[y][0]:
                    dist[y][0] = d
                    q.append((y, d))
                elif dist[y][0] < d < dist[y][1]:
                    dist[y][1] = d
                    q.append((y, d))

        ans = 0
        for _ in range(dist[n][1]):
            if ans % (change * 2) >= change:
                ans += change * 2 - ans % (change * 2)
            ans += time
        return ans
```

#### 思路与算法

依题意知，同一路径长度所需要花费的时间是相同的，且路径越长，所需时间越久。因此，如果我们可以求得到达目的地的严格次短路径，就可以直接计算到达目的地的第二短时间。

求解权重相同的最短路径问题可以采用广度优先搜索，这里我们做一些修改。使用广度优先搜索求解最短路径时，经过的点与初始点的路径长度是所有未搜索过的路径中的最小值，因此每次广度优先搜索获得的经过点与初始点的路径长度是非递减的。我们可以记录下所有点与初始点的最短路径与严格次短路径，一旦求得目的点的严格次短路径，我们就可以直接计算到达目的地的第二短时间。

对于路径长度与时间的计算，假设到达节点 i 的时间为 $t_i$，则到达节点 i+1 的时间为：

$$
t_{i+1} = t_i + t_\textit{wait} + \textit{time}
$$
其中$ t_\textit{wait}$的计算如下：
$$
t_\textit{wait}= \begin{cases} 0, & t_i \bmod (2 \times \textit{change}) \in [0, ~\textit{change}) \\ 2 \times \textit{change} - t_i \bmod (2 \times \textit{change}), & t_i \bmod (2 \times \textit{change}) \in [\textit{change}, ~2 \times \textit{change}) \end{cases}
$$

#### 复杂度分析

时间复杂度：O(n+e)，其中 n 是图的节点数，e 是图的边数。广度优先搜索队列保存过的元素不超过 $2 \times n$，因此整个循环的次数不超过 $2 \times n$，即 O(n)，而循环内访问边的总次数不会超过 $2 \times e$，因此访问边需要 O(e)。

空间复杂度：O(n+e)。建图 $\textit{graph}$ 需要 O(e)的空间，保存路径长度 $\textit{path}$ 需要 O(n) 的空间，广度优先搜索队列的元素个数不超过 $2 \times n$，需要 O(n) 的空间。



