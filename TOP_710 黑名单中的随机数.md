# 题目

给定一个整数 `n` 和一个 **无重复** 黑名单整数数组 `blacklist` 。设计一种算法，从 `[0, n - 1]` 范围内的任意整数中选取一个 **未加入** 黑名单 `blacklist` 的整数。任何在上述范围内且不在黑名单 `blacklist` 中的整数都应该有 **同等的可能性** 被返回。

优化你的算法，使它最小化调用语言 **内置** 随机函数的次数。

实现 `Solution` 类:

- `Solution(int n, int[] blacklist)` 初始化整数 `n` 和被加入黑名单 `blacklist` 的整数
- `int pick()` 返回一个范围为 `[0, n - 1]` 且不在黑名单 `blacklist` 中的随机整数

**示例 1：**

```
输入
["Solution", "pick", "pick", "pick", "pick", "pick", "pick", "pick"]
[[7, [2, 3, 5]], [], [], [], [], [], [], []]
输出
[null, 0, 4, 1, 6, 1, 0, 4]

解释
Solution solution = new Solution(7, [2, 3, 5]);
solution.pick(); // 返回0，任何[0,1,4,6]的整数都可以。注意，对于每一个pick的调用，
                 // 0、1、4和6的返回概率必须相等(即概率为1/4)。
solution.pick(); // 返回 4
solution.pick(); // 返回 1
solution.pick(); // 返回 6
solution.pick(); // 返回 1
solution.pick(); // 返回 0
solution.pick(); // 返回 4
```

**提示:**

- 1 <= n <= 109
- 0 <= blacklist.length <= min(105, n - 1)
- `0 <= blacklist[i] < n`
- `blacklist` 中所有值都 **不同**
-  `pick` 最多被调用 2 * 104 次

## 我的解法

查看题解的思路和评论区大佬的思路后写出！菜的安详！

```python
class Solution:

    def __init__(self, n: int, blacklist: List[int]):
        m = len(blacklist)
        self.black = set(blacklist)
        self.s = n - m
        bSet = {b for b in blacklist if b < self.s}
        wSet = set()
        for w in range(self.s, n):
            if w not in self.black:
                wSet.add(w)
        self.bTw = dict(zip(bSet, wSet))

    def pick(self) -> int:
        num = randrange(0, self.s)
        return num if num not in self.bTw else self.bTw[num]

# Your Solution object will be instantiated and called as such:
# obj = Solution(n, blacklist)
# param_1 = obj.pick()
```

## 其他解法

### 黑名单映射

```c++
class Solution {
    unordered_map<int, int> b2w;
    int bound;

public:
    Solution(int n, vector<int> &blacklist) {
        int m = blacklist.size();
        bound = n - m;
        unordered_set<int> black;
        for (int b: blacklist) {
            if (b >= bound) {
                black.emplace(b);
            }
        }

        int w = bound;
        for (int b: blacklist) {
            if (b < bound) {
                while (black.count(w)) {
                    ++w;
                }
                b2w[b] = w++;
            }
        }
    }

    int pick() {
        int x = rand() % bound;
        return b2w.count(x) ? b2w[x] : x;
    }
};
```

```java
class Solution {
    Map<Integer, Integer> b2w;
    Random random;
    int bound;

    public Solution(int n, int[] blacklist) {
        b2w = new HashMap<Integer, Integer>();
        random = new Random();
        int m = blacklist.length;
        bound = n - m;
        Set<Integer> black = new HashSet<Integer>();
        for (int b : blacklist) {
            if (b >= bound) {
                black.add(b);
            }
        }

        int w = bound;
        for (int b : blacklist) {
            if (b < bound) {
                while (black.contains(w)) {
                    ++w;
                }
                b2w.put(b, w);
                ++w;
            }
        }
    }

    public int pick() {
        int x = random.nextInt(bound);
        return b2w.getOrDefault(x, x);
    }
}
```

```python
class Solution:
    def __init__(self, n: int, blacklist: List[int]):
        m = len(blacklist)
        self.bound = w = n - m
        black = {b for b in blacklist if b >= self.bound}
        self.b2w = {}
        for b in blacklist:
            if b < self.bound:
                while w in black:
                    w += 1
                self.b2w[b] = w
                w += 1

    def pick(self) -> int:
        x = randrange(self.bound)
        return self.b2w.get(x, x)
```

设$ \textit{blacklist}$的长度为 m。

考察一个特殊的例子：所有黑名单数全部在区间 $[n-m,n)$ 范围内。此时我们可以直接在 $[0,n-m)$ 范围内取随机整数。

这给我们一个启示，对于在 $[0,n-m) $范围内的黑名单数，我们可以将其映射到 $[n-m,n)$ 范围内的非黑名单数（白名单数）上。每次 $\text{pick()}$ 时，仍然可以在$ [0,n-m)$ 范围内取随机整数（设其为 x），那么：

- 如果 x 不在黑名单中，则直接返回 x；
- 如果 x 在黑名单中，则返回 x 映射到 $[n-m,n)$ 范围内的白名单数。

我们可以在初始化时，构建一个从 $[0,n-m)$范围内的黑名单数到 $[n-m,n)$ 的白名单数的映射：

1. 将 $[n-m,n)$ 范围内的黑名单数存入一个哈希集合 $\textit{black}$；
2. 初始化白名单数$ \textit{w}=n-m$；
3. 对于每个 $[0,n-m)$ 范围内的黑名单数 b，首先不断增加 $\textit{w}$直至其不在黑名单中，然后将 b 映射到 $\textit{w}$ 上，并将 $\textit{w}$ 增加一。

#### 复杂度分析

- 时间复杂度：初始化为 O(m)，$\text{pick()}$ 为 O(1)，其中 m 是数组 $\textit{blacklist}$的长度。在初始化结束时，$[n-m,n)$ 内的每个数字要么是黑名单数，要么被一个黑名单数所映射，因此 $\textit{white}$会恰好增加 m 次，因此初始化的时间复杂度为 O(m)。

- 空间复杂度：O(m)。哈希表需要 O(m) 的空间。


