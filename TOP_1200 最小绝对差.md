# 题目

给你个整数数组 `arr`，其中每个元素都 **不相同**。

请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。

**示例 1：**

```
输入：arr = [4,2,1,3]
输出：[[1,2],[2,3],[3,4]]
```

**示例 2：**

```
输入：arr = [1,3,6,10,15]
输出：[[1,3]]
```

**示例 3：**

```
输入：arr = [3,8,-10,23,19,-4,-14,27]
输出：[[-14,-10],[19,23],[23,27]]
```

**提示：**

- $2 <= arr.length <= 10^5$
- $-10^6 <= arr[i] <= 10^6$

## 我的解法

快速解决！

```python
class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()
        n = len(arr)
        ans = []
        difference = arr[-1] - arr[0]
        for i in range(1, n):
            mid = arr[i] - arr[i - 1]
            if mid < difference:
                difference = mid
                ans= [[arr[i - 1], arr[i]]]
            elif mid == difference:
                ans.append([arr[i - 1], arr[i]])
        return ans
```

## 其他解法

### 排序 + 一次遍历

```c++
class Solution {
public:
    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
        int n = arr.size();
        sort(arr.begin(), arr.end());

        int best = INT_MAX;
        vector<vector<int>> ans;
        for (int i = 0; i < n - 1; ++i) {
            if (int delta = arr[i + 1] - arr[i]; delta < best) {
                best = delta;
                ans = {{arr[i], arr[i + 1]}};
            }
            else if (delta == best) {
                ans.emplace_back(initializer_list<int>{arr[i], arr[i + 1]});
            }
        }

        return ans;
    }
};
```

```java
class Solution {
    public List<List<Integer>> minimumAbsDifference(int[] arr) {
        int n = arr.length;
        Arrays.sort(arr);

        int best = Integer.MAX_VALUE;
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        for (int i = 0; i < n - 1; ++i) {
            int delta = arr[i + 1] - arr[i];
            if (delta < best) {
                best = delta;
                ans.clear();
                List<Integer> pair = new ArrayList<Integer>();
                pair.add(arr[i]);
                pair.add(arr[i + 1]);
                ans.add(pair);
            } else if (delta == best) {
                List<Integer> pair = new ArrayList<Integer>();
                pair.add(arr[i]);
                pair.add(arr[i + 1]);
                ans.add(pair);
            }
        }

        return ans;
    }
}
```

```python
class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        n = len(arr)
        arr.sort()

        best, ans = float('inf'), list()
        for i in range(n - 1):
            if (delta := arr[i + 1] - arr[i]) < best:
                best = delta
                ans = [[arr[i], arr[i + 1]]]
            elif delta == best:
                ans.append([arr[i], arr[i + 1]])
        
        return ans
```

#### 思路与算法

首先我们对数组 $\textit{arr}$进行升序排序。这样一来，拥有「最小绝对差」的元素对只能由有序数组中相邻的两个元素构成。

随后我们对数组 $\textit{arr}$进行一次遍历。当遍历到 $\textit{arr}[i]$ 和$ \textit{arr}[i+1]$ 时，它们的差为 $\delta = \textit{arr}[i+1] - \textit{arr}[i]$。我们使用一个变量 $\textit{best}$存储当前遇到的最小差，以及一个数组 $\textit{ans}$存储答案：

- 如果 $\delta < \textit{best}$，那么说明我们遇到了更小的差值，需要更新 $\textit{best}$，同时 $\textit{ans}$清空并放入 $\textit{arr}[i]$ 和 $\textit{arr}[i+1]$；

- 如果 $\delta = \textit{best}$，那么我们只需要将 $\textit{arr}[i]$和 $\textit{arr}[i+1]$ 放入答案数组即可。


#### 复杂度分析

- 时间复杂度：$O(n \log n)$，其中 n 是数组 $\textit{arr}$的长度。排序需要的时间为 $O(n \log n)$，遍历需要的是时间为 O(n)，因此总时间复杂度为 $O(n \log n)$。

- 空间复杂度：$O(\log n)$，即为排序需要使用的栈空间。这里不计入返回值需要使用的空间。


