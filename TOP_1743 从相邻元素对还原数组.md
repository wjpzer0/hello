# 题目

存在一个由 `n` 个不同元素组成的整数数组 `nums` ，但你已经记不清具体内容。好在你还记得 `nums` 中的每一对相邻元素。

给你一个二维整数数组 `adjacentPairs` ，大小为 `n - 1` ，其中每个 `adjacentPairs[i] = [ui, vi]` 表示元素 `ui` 和 `vi` 在 `nums` 中相邻。

题目数据保证所有由元素 `nums[i]` 和 `nums[i+1]` 组成的相邻元素对都存在于 `adjacentPairs` 中，存在形式可能是 `[nums[i], nums[i+1]]` ，也可能是 `[nums[i+1], nums[i]]` 。这些相邻元素对可以 **按任意顺序** 出现。

返回 **原始数组** `nums` 。如果存在多种解答，返回 **其中任意一个** 即可。

**示例 1：**

```
输入：adjacentPairs = [[2,1],[3,4],[3,2]]
输出：[1,2,3,4]
解释：数组的所有相邻元素对都在 adjacentPairs 中。
特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。
```

**示例 2：**

```
输入：adjacentPairs = [[4,-2],[1,4],[-3,1]]
输出：[-2,4,1,-3]
解释：数组中可能存在负数。
另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。
```

**示例 3：**

```
输入：adjacentPairs = [[100000,-100000]]
输出：[100000,-100000]
```

**提示：**

- `nums.length == n`
- `adjacentPairs.length == n - 1`
- `adjacentPairs[i].length == 2`
- $2 <= n <= 10^5$
- $-10^5 <= nums[i], ui, vi <= 10^5$
- 题目数据保证存在一些以 `adjacentPairs` 作为元素对的数组 `nums`

## 我的解法

```python
class Solution:
    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
        res = adjacentPairs.pop()
        while adjacentPairs:
            mid = None
            for pairs in adjacentPairs:
                if pairs[0] == res[0]:
                    res.insert(0, pairs[1])
                    mid = pairs
                    break
                if pairs[-1] == res[0]:
                    res.insert(0, pairs[0])
                    mid = pairs
                    break
                if pairs[0] == res[-1]:
                    res.append(pairs[-1])
                    mid = pairs
                    break
                if pairs[-1] == res[-1]:
                    res.append(pairs[0])
                    mid = pairs
                    break
            adjacentPairs.remove(mid)
        return res
```

超时！有更优秀的解法，但是没有想到！

## 其他解法

### 哈希表

```c++
class Solution {
public:
    vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {
        unordered_map<int, vector<int>> mp;
        for (auto& adjacentPair : adjacentPairs) {
            mp[adjacentPair[0]].push_back(adjacentPair[1]);
            mp[adjacentPair[1]].push_back(adjacentPair[0]);
        }

        int n = adjacentPairs.size() + 1;
        vector<int> ret(n);
        for (auto& [e, adj] : mp) {
            if (adj.size() == 1) {
                ret[0] = e;
                break;
            }
        }

        ret[1] = mp[ret[0]][0];
        for (int i = 2; i < n; i++) {
            auto& adj = mp[ret[i - 1]];
            ret[i] = ret[i - 2] == adj[0] ? adj[1] : adj[0];
        }
        return ret;
    }
};
```

```java
class Solution {
    public int[] restoreArray(int[][] adjacentPairs) {
        Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();
        for (int[] adjacentPair : adjacentPairs) {
            map.putIfAbsent(adjacentPair[0], new ArrayList<Integer>());
            map.putIfAbsent(adjacentPair[1], new ArrayList<Integer>());
            map.get(adjacentPair[0]).add(adjacentPair[1]);
            map.get(adjacentPair[1]).add(adjacentPair[0]);
        }

        int n = adjacentPairs.length + 1;
        int[] ret = new int[n];
        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {
            int e = entry.getKey();
            List<Integer> adj = entry.getValue();
            if (adj.size() == 1) {
                ret[0] = e;
                break;
            }
        }

        ret[1] = map.get(ret[0]).get(0);
        for (int i = 2; i < n; i++) {
            List<Integer> adj = map.get(ret[i - 1]);
            ret[i] = ret[i - 2] == adj.get(0) ? adj.get(1) : adj.get(0);
        }
        return ret;
    }
}
```

```python
class Solution:
    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
        mp = defaultdict(list)
        for adjacentPair in adjacentPairs:
            mp[adjacentPair[0]].append(adjacentPair[1])
            mp[adjacentPair[1]].append(adjacentPair[0])
        
        n = len(adjacentPairs) + 1
        ret = [0] * n
        for (e, adj) in mp.items():
            if len(adj) == 1:
                ret[0] = e
                break
        
        ret[1] = mp[ret[0]][0]
        for i in range(2, n):
            adj = mp[ret[i-1]]
            ret[i] = adj[1] if ret[i - 2] == adj[0] else adj[0]
        
        return ret
```

#### 思路及算法

对于一维数组 $\textit{nums}$ 中的元素 $\textit{nums}[i]$，若其为数组的第一个或最后一个元素，则该元素有且仅有一个元素与其相邻；若其为数组的中间元素，则该元素有且仅有两个元素与其相邻。

我们可以对每个元素记录与它相邻的元素有哪些，然后依次检查每个元素的相邻元素数量，即可找到原数组的第一个元素和最后一个元素。由于我们可以返回任意一个满足条件的数组，故指定这两个元素中的一个为原数组的第一个元素，然后根据相邻元素信息确定数组的第二个、第三个元素……直到确定最后一个元素为止。

具体地，我们使用哈希表记录每一个的元素的相邻元素有哪些，然后我们遍历哈希表，找到有且仅有一个相邻元素的元素 $e_1$作为原数组的第一个元素。那么与 $e_1$唯一相邻的元素$ e_2$即为原数组的第二个元素。此时排除掉与 $e_2$​相邻的 $e_1$​后，可以确认与 $e_2$相邻的 $e_3$即为原数组的第三个元素……以此类推，我们可以将原数组完整推断出来。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是原数组的长度。我们只需要遍历每一个元素一次。

- 空间复杂度：O(n)，其中 n 是原数组的长度。主要为哈希表的开销。


