# 题目

对于一个 **正整数**，如果它和除了它自身以外的所有 **正因子** 之和相等，我们称它为 「完美数」。

给定一个 **整数** `n`， 如果是完美数，返回 `true`，否则返回 `false`

**示例 1：**

```
输入：num = 28
输出：true
解释：28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。
```

**示例 2：**

```
输入：num = 6
输出：true
```

**示例 3：**

```
输入：num = 496
输出：true
```

**示例 4：**

```
输入：num = 8128
输出：true
```

**示例 5：**

```
输入：num = 2
输出：false
```

**提示：**

- $1 <= num <= 10^8$

## 我的解法

不应该用列表进行记录后再相加的，直接相加可以减少空间复杂度！

```python
class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        if num == 1:
            return False
        sumNum = [1]
        numsqrt = int(num ** 0.5 + 1)
        for i in range(2, numsqrt):
            if num % i == 0:
                sumNum.append(i)
                if i != num // i:
                    sumNum.append(num // i)
        return sum(sumNum) == num
```

## 其他解法

### 枚举

```c++
class Solution {
public:
    bool checkPerfectNumber(int num) {
        if (num == 1) {
            return false;
        }

        int sum = 1;
        for (int d = 2; d * d <= num; ++d) {
            if (num % d == 0) {
                sum += d;
                if (d * d < num) {
                    sum += num / d;
                }
            }
        }
        return sum == num;
    }
};
```

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
        if (num == 1) {
            return false;
        }

        int sum = 1;
        for (int d = 2; d * d <= num; ++d) {
            if (num % d == 0) {
                sum += d;
                if (d * d < num) {
                    sum += num / d;
                }
            }
        }
        return sum == num;
    }
}
```

```python
class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        if num == 1:
            return False

        sum = 1
        d = 2
        while d * d <= num:
            if num % d == 0:
                sum += d
                if d * d < num:
                    sum += num / d
            d += 1
        return sum == num
```

我们可以枚举$ \textit{num}$ 的所有真因子，累加所有真因子之和，记作 $\textit{sum}$。若 $\textit{sum}=\textit{num}$ 则返回 $\texttt{true}$，否则返回 $\texttt{false}$。

在枚举时，我们只需要枚举不超过 $\sqrt{num} $的数。这是因为如果 $\textit{num}$ 有一个大于 $\sqrt{num} $ 的因数 d，那么它一定有一个小于$ \sqrt{num}$  的因数 $\dfrac{\textit{num}}{d} $ 。

在枚举时，若找到了一个因数 d，那么就找到了因数 $\dfrac{\textit{num}}{d} $。注意当 $d\cdot d=\textit{num}$ 时这两个因数相同，此时不能重复计算。

#### 复杂度分析

- 时间复杂度：$O(\sqrt{num})$。
- 空间复杂度：O(1)。

### 数学

```c++
class Solution {
public:
    bool checkPerfectNumber(int num) {
        return num == 6 || num == 28 || num == 496 || num == 8128 || num == 33550336;
    }
};
```

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
        return num == 6 || num == 28 || num == 496 || num == 8128 || num == 33550336;
    }
}
```

```python
class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        return num == 6 or num == 28 or num == 496 or num == 8128 or num == 33550336
```

根据欧几里得-欧拉定理，每个偶完全数都可以写成
$$
2^{p-1}(2^p-1)
$$
的形式，其中 p 为素数且 $2^p-1$ 为素数。

由于目前奇完全数还未被发现，因此题目范围 $[1,10^8]$ 内的完全数都可以写成上述形式。

这一共有如下 5 个：

$$
6, 28, 496, 8128, 33550336
$$

#### 复杂度分析

- 时间复杂度：O(1)。
- 空间复杂度：O(1)。