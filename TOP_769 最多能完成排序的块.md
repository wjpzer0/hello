# 题目

给定一个长度为 `n` 的整数数组 `arr` ，它表示在 `[0, n - 1]` 范围内的整数的排列。

我们将 `arr` 分割成若干 **块** (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。

返回数组能分成的最多块数量。

**示例 1:**

```
输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
```

**示例 2:**

```
输入: arr = [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
```

**提示:**

- `n == arr.length`
- `1 <= n <= 10`
- `0 <= arr[i] < n`
- `arr` 中每个元素都 **不同**

## 我的解法

思路正确！

```python
class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        res = 0
        maxNum = 0
        for i, num in enumerate(arr):
            maxNum = max(maxNum, num)
            if i == maxNum:
                res += 1
        return res
```

## 其它解法

### 贪心

```c++
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int m = 0, res = 0;
        for (int i = 0; i < arr.size(); i++) {
            m = max(m, arr[i]);
            if (m == i) {
                res++;
            }
        }
        return res;
    }
};
```

```java
class Solution {
    public int maxChunksToSorted(int[] arr) {
        int m = 0, res = 0;
        for (int i = 0; i < arr.length; i++) {
            m = Math.max(m, arr[i]);
            if (m == i) {
                res++;
            }
        }
        return res;
    }
}
```

```python
class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        ans = mx = 0
        for i, x in enumerate(arr):
            mx = max(mx, x)
            ans += mx == i
        return ans
```

根据题意我们可以得到以下两个定理：

- 定理一：对于某个块 A，它由块 B 和块 C 组成，即 A = B + C。如果块 B 和块 C 分别排序后都与原数组排序后的结果一致，那么块 A 排序后与原数组排序后的结果一致。

> 证明：因为块 B 和块 C 分别排序后都与原数组排序后的结果一致，所以块 B 的元素和块 C 的元素的并集为原数组排序后在对应区间的所有元素。而 A = B + C，因此将块 A 排序后与原数组排序后的结果一致。

- 定理二：对于某个块 A，它由块 B 和块 C 组成，即 A = B + C。如果块 A 和块 B 分别排序后都与原数组排序后的结果一致，那么块 C 排序后与原数组排序后的结果一致。

> 证明：如果块 C 排序后与原数组排序后的结果不一致，那么块 BB 的元素和块 CC 的元素的并集不等同于原数组排序后在对应区间的所有元素。而块 AA 排序后与原数组排序后的结果一致，说明块 AA 的元素等同于原数组排序后在对应区间的所有元素。这与块 AA 的元素由块 BB 的元素和 块 CC 的元素组成矛盾，因此块 CC 排序后与原数组排序后的结果一致。

假设数组 $\textit{arr}$ 一种分割方案为：$[a_0, a_{i_1}], [a_{i_1+1}, a_{i_2}], \ldots, [a_{i_m+1}, a_{n-1}]$，那么由定理一可知 $[a_0, a_{i_1}], [a_0, a_{i_2}], \ldots, [a_0, a_{n-1}]$分别排序后与原数组排序后的结果一致。反之如果 $[a_0, a_{i_1}], [a_0, a_{i_2}], \ldots, [a_0, a_{n-1}]$ 分别排序后与原数组排序后的结果一致，那么由定理二可知 $[a_0, a_{i_1}], [a_{i_1+1}, a_{i_2}], \ldots, [a_{i_m+1}, a_{n-1}]$ 是数组 $\textit{arr}$一种分割块方案。

因此我们只需要找到$ [a_0, a_{i_1}], [a_0, a_{i_2}], \ldots, [a_0, a_{n-1}]$的最大数目，就能找到最大分割块数目。因为数组 $\textit{arr}$的元素在区间 $[0, n - 1]$ 之间且互不相同，所以数组排序后有 $\textit{arr}[i] = i$。如果数组 $\textit{arr}$的某个长为 i+1i 的前缀块 $[a_0, a_i]$ 的最大值等于 i，那么说明它排序后与原数组排序后的结果一致。统计这些前缀块的数目，就可以得到最大分割块数目。

#### **复杂度分析**

- 时间复杂度：O(n)，其中 n 是数组 $\textit{arr}$ 的长度。
- 空间复杂度：O(1)。

### 前缀和

```java
class Solution {
    public int maxChunksToSorted(int[] arr) {
        int ret = 0;
        int vSum = 0;
        int iSum = 0;
        for(int i = 0; i < arr.length; i++){
            vSum += arr[i];
            iSum += i;
            if(vSum == iSum)ret++;
        }
        return ret;
    }
}
```

考虑到数组长度为n，而且数组元素位于区间[0, n-1]且不重复，那么数组排好序后，每个值和下标恰好是相等的；所以，从左到右遍历数组，并且分别对值和下标累加求和，只要两个和相等，就切出一个块。

时间复杂度O(n)，空间复杂度O(1)。