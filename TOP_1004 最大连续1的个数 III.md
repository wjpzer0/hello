# 题目

给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。

示例 1：

```
输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
```


示例 2：

```
输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
```


提示：

1. 1 <= A.length <= 20000
2. 0 <= K <= A.length
3. A[i] 为 0 或 1 

## 我的解法

未解出，对滑动窗口的解法仍然十分不熟悉。

### 分享滑动窗口模板

《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。

我分享一个滑动窗口的模板，能解决大多数的滑动窗口问题：

```python
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
```


滑动窗口中用到了左右两个指针，它们移动的思路是**：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间**。

模板的整体思想是：

- 定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；
- 第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和/计数；
- 第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和/计数；
- 在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求最大的区间长度，因此更新 res 为 max(res, 当前区间的长度) 。
- right 指针每次向右移动一步，开始探索新的区间。

模板中的 sums 需要根据题目意思具体去修改，本题是求和题目因此把sums 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sums 。

另外一个需要根据题目去修改的是内层 while 循环的判断条件，即： 区间 [left, right]不符合题意 。对于本题而言，就是该区间内的 0 的个数 超过了 2 。

### 题目分析

对于数组 A 的区间 [left,right] 而言，只要它包含不超过K 个 0，我们就可以根据它构造出一段满足要求，并且长度为 right−left+1 的区间。

因此，我们可以将该问题进行如下的转化，即：

> 对于任意的右端点 right，希望找到最小的左端点 left，使得 [left,right] 包含不超过 K 个 0。
>
> 只要我们枚举所有可能的右端点，将得到的区间的长度取最大值，即可得到答案。
>

要想快速判断一个区间内 0 的个数，我们可以考虑将数组 A 中的 0 变成 1，1 变成 0。此时，我们对数组 A 求出前缀和，记为数组 P，那么 [left,right] 中包含不超过 K 个 1（注意这里就不是 0 了），当且仅当二者的前缀和之差：

$$
P[\textit{right}] - P[\textit{left} - 1]
$$
小于等于 K。这样一来，我们就可以容易地解决这个问题了。

## 其他解法

### 滑动窗口

```python
class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        n = len(A)
        left = lsum = rsum = 0
        ans = 0
        
        for right in range(n):
            rsum += 1 - A[right]
            while lsum < rsum - K:
                lsum += 1 - A[left]
                left += 1
            ans = max(ans, right - left + 1)
        
        return ans
```



#### 解题思路

重点：题意转换。把「最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度」转换为 「找出一个最长的子数组，该子数组内最多允许有 K 个 0 」。
经过上面的题意转换，我们可知本题是求最大连续子区间，可以使用滑动窗口方法。滑动窗口的限制条件是：窗口内最多有 K 个 0。

可以使用我多次分享的滑动窗口模板解决，模板在代码之后。

**代码思路：**

- 使用 left 和 right 两个指针，分别指向滑动窗口的左右边界。
- rightright 主动右移：right 指针每次移动一步。当 A[right] 为 0，说明滑动窗口内增加了一个0；
- leftleft 被动右移：判断此时窗口内 0 的个数，如果超过了 K，则 left 指针被迫右移，直至窗口内的 0 的个数小于等于 K 为止。
- 滑动窗口长度的最大值就是所求。

#### 示例

以 `A= [1,1,1,0,0,0,1,1,1,1,0], K = 2` 为例，下面的动图演示了滑动窗口的两个指针的移动情况。

![1004.gif](https://pic.leetcode-cn.com/1613703526-DmKSCr-1004.gif)

#### 复杂度分析

- 时间复杂度：O(N)，因为每个元素只遍历了一次。
- 空间复杂度：O(1)，因为使用了常数个空间。

### 二分查找

```python
class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        n = len(A)
        P = [0]
        for num in A:
            P.append(P[-1] + (1 - num))
        
        ans = 0
        for right in range(n):
            left = bisect.bisect_left(P, P[right + 1] - K)
            ans = max(ans, right - left + 1)
        
        return ans
```



#### 思路与算法

$$
P[\textit{right}] - P[\textit{left} - 1] \leq K
$$

等价于

$$
P[\textit{left} - 1] \geq P[\textit{right}] - K \tag{1}
$$
也就是说，我们需要找到最小的满足 (1) 式的left。由于数组 A 中仅包含 0/1，因此前缀和数组是一个单调递增的数组，我们就可以使用二分查找的方法得到 left。

细节

注意到 (1) 式的左侧的下标是left−1 而不是 left，那么我们在构造前缀和数组时，可以将前缀和整体向右移动一位，空出 P[0] 的位置，即：

$$
\begin{cases} P[0] = 0 \\ P[i] = P[i-1] + (1 - A[i-1]) \end{cases}
$$

此时，我们在数组 P 上二分查找到的下标即为 left 本身，同时我们也避免了原先 left=0 时 left−1=−1 不在数组合法的下标范围中的边界情况。

#### 复杂度分析

- 时间复杂度：O(nlogn)，其中 n 是数组 A 的长度。每一次二分查找的时间复杂度为 O(logn)，我们需要枚举 right 进行 n 次二分查找，因此总时间复杂度为 O(nlogn)。

- 空间复杂度：O(n)，即为前缀和数组 P 需要的空间。


