# 题目

给你一个整数数组 `nums` 。你可以选定任意的 **正数** startValue 作为初始值。

你需要从左到右遍历 `nums` 数组，并将 startValue 依次累加上 `nums` 数组中的值。

请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 **正数** 作为 startValue 。

**示例 1：**

```
输入：nums = [-3,2,-3,4,2]
输出：5
解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。
                累加求和
                startValue = 4 | startValue = 5 | nums
                  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
                  (1 +2 ) = 3  | (2 +2 ) = 4    |   2
                  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
                  (0 +4 ) = 4  | (1 +4 ) = 5    |   4
                  (4 +2 ) = 6  | (5 +2 ) = 7    |   2
```

**示例 2：**

```
输入：nums = [1,2]
输出：1
解释：最小的 startValue 需要是正数。
```

**示例 3：**

```
输入：nums = [1,-2,-3]
输出：5
```

**提示：**

- `1 <= nums.length <= 100`
- `-100 <= nums[i] <= 100`

## 我的解法

快速解决！

```python
class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        minSum = float("inf")
        sumNum = 0
        for num in nums:
            sumNum += num 
            if minSum > sumNum:
                minSum = sumNum
        print(minSum)
        if minSum > 0:
            return 1
        else:
            return abs(minSum) + 1
```

## 其他解法

### 贪心

```c++
class Solution {
public:
    int minStartValue(vector<int>& nums) {
        int accSum = 0, accSumMin = 0;
        for (int num : nums) {
            accSum += num;
            accSumMin = min(accSumMin, accSum);
        }
        return -accSumMin + 1;
    }
};
```

```java
class Solution {
    public int minStartValue(int[] nums) {
        int accSum = 0, accSumMin = 0;
        for (int num : nums) {
            accSum += num;
            accSumMin = Math.min(accSumMin, accSum);
        }
        return -accSumMin + 1;
    }
}
```

```python
class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        accSum, accSumMin = 0, 0
        for num in nums:
            accSum += num
            accSumMin = min(accSumMin, accSum)
        return -accSumMin + 1
```

#### 思路

要保证所有的累加和 $\textit{accSum}$满足 $\textit{accSum} + \textit{startValue} \ge 1$，只需保证累加和的最小值 $\textit{accSumMin}$满足 $\textit{accSumMin} + \textit{startValue} \ge 1$，那么$ \textit{startValue}$的最小值即可取$ -\textit{accSumMin} + 1$。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是数组 $\textit{nums}$的长度。只需要遍历数组一次。

- 空间复杂度：O(1)。只需要使用常量空间。


### 二分查找

```c++
class Solution {
public:
    int minStartValue(vector<int>& nums) {
        int m = *min_element(nums.begin(), nums.end());
        if (m >= 0) {
            return 1;
        }
        int left = 1, right = -m * nums.size() + 1;
        while (left < right) {
            int medium = (left + right) / 2;
            if (valid(medium, nums)) {
                right = medium;
            } else {
                left = medium + 1;
            }
        }
        return left;
    }

    bool valid(int startValue, vector<int>& nums) {
        for (int num : nums) {
            startValue += num;
            if (startValue <= 0) {
                return false;
            }
        }
        return true;
    }
};
```

```java
class Solution {
    public int minStartValue(int[] nums) {
        int m = Arrays.stream(nums).min().getAsInt();
        if (m >= 0) {
            return 1;
        }
        int left = 1, right = -m * nums.length + 1;
        while (left < right) {
            int medium = (left + right) / 2;
            if (valid(medium, nums)) {
                right = medium;
            } else {
                left = medium + 1;
            }
        }
        return left;
    }

    public boolean valid(int startValue, int[] nums) {
        for (int num : nums) {
            startValue += num;
            if (startValue <= 0) {
                return false;
            }
        }
        return true;
    }
}
```

```python
class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        m = min(nums)
        if m >= 0:
            return 1
        left, right = 1, -m * len(nums) + 1
        while left < right:
            medium = (left + right) // 2
            if self.valid(medium, nums):
                right = medium
            else:
                left = medium + 1
        return left
    
    def valid(self, startValue: int, nums: List[int]) -> bool:
        for num in nums:
            startValue += num
            if startValue <= 0:
                return False
        return True
```

#### 思路

当 $\textit{nums}$所有元素均为非负数时，可以直接返回 1。当有负数时，可以

当某个数字满足 $\textit{startValue}$的要求时，比它大的数字肯定也都满足，比它小的数字则不一定能满足，因此$ \textit{startValue}$的性质具有单调性，此题可以用二分查找来解决。二分查找的左起始点为 1，右起始点可以设为 $\textit{nums}$的最小值的相反数乘上长度后再加 1，这样可以保证右端点一定满足 $\textit{startValue}$的要求。

判断某个数字是否满足 $\textit{startValue}$的要求时，可以将$ \textit{nums}$的数字逐步加到这个数字上，判断是否一直为正即可。

#### 复杂度分析

- 时间复杂度：$O(n \times \log (mn))$，其中 n 是数组 $\textit{nums}$的长度，m 是数组最小值的绝对值。二分查找的次数是 $O(\log (mn))$，每次消耗 O(n)。

- 空间复杂度：O(1)。只需要使用常量空间。


