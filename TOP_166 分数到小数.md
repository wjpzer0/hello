# 题目

给定两个整数，分别表示分数的分子 `numerator` 和分母 `denominator`，以 **字符串形式返回小数** 。

如果小数部分为循环小数，则将循环的部分括在括号内。

如果存在多个答案，只需返回 **任意一个** 。

对于所有给定的输入，**保证** 答案字符串的长度小于 $10^4$。

**示例 1：**

```
输入：numerator = 1, denominator = 2
输出："0.5"
```

**示例 2：**

```
输入：numerator = 2, denominator = 1
输出："2"
```

**示例 3：**

```
输入：numerator = 2, denominator = 3
输出："0.(6)"
```

**示例 4：**

```
输入：numerator = 4, denominator = 333
输出："0.(012)"
```

**示例 5：**

```
输入：numerator = 1, denominator = 5
输出："0.2"
```

 

**提示：**

- $-2^{31} <= numerator, denominator <= 2^{31} - 1$
- `denominator != 0`

## 我的解法

未解出，无法处理好循环部分！

查看题解后写出！

```python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator % denominator == 0:
            return str(numerator // denominator)
        
        sb = []
        if (numerator < 0) ^ (denominator < 0):
            sb.append("-")
        
        numeratorLong = abs(numerator)
        denominatorLong = abs(denominator)
        integerPart = numeratorLong // denominatorLong
        sb.append(str(integerPart))
        sb.append(".")

        fractionPart = []
        remainderIndexMap = {}
        remainder = numeratorLong % denominatorLong
        index = 0
        while remainder != 0 and not remainderIndexMap.get(remainder):
            remainderIndexMap[remainder] = index
            remainder *= 10
            fractionPart.append(str(remainder // denominatorLong))
            remainder = remainder % denominatorLong
            index += 1
        if remainder != 0:
            insertIndex = remainderIndexMap.get(remainder)
            fractionPart.insert(insertIndex, "(")
            fractionPart.append(")")
        
        sb += fractionPart

        return "".join(sb)
```

## 其他解法

### 长除法

```c++
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        if((int64_t)numerator % denominator == 0) return to_string((int64_t)numerator / denominator);

        int64_t up = abs((int64_t)numerator), down = abs((int64_t)denominator);
        string ans(((numerator < 0) ^ (denominator < 0) ? "-" : "") + to_string(up / down) + '.');
        unordered_map<int64_t, int> index;

        for(int i = ans.size(); up = up % down * 10; ++i){
            if(index.count(up)) {
                ans.insert(begin(ans) + index[up], '(');
                ans.push_back(')');
                break;
            }
            index[up] = i;
            ans.push_back('0' + up / down);
        }
        return ans;
    }
};
```

```java
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        long numeratorLong = (long) numerator;
        long denominatorLong = (long) denominator;
        if (numeratorLong % denominatorLong == 0) {
            return String.valueOf(numeratorLong / denominatorLong);
        }

        StringBuffer sb = new StringBuffer();
        if (numeratorLong < 0 ^ denominatorLong < 0) {
            sb.append('-');
        }

        // 整数部分
        numeratorLong = Math.abs(numeratorLong);
        denominatorLong = Math.abs(denominatorLong);
        long integerPart = numeratorLong / denominatorLong;
        sb.append(integerPart);
        sb.append('.');

        // 小数部分
        StringBuffer fractionPart = new StringBuffer();
        Map<Long, Integer> remainderIndexMap = new HashMap<Long, Integer>();
        long remainder = numeratorLong % denominatorLong;
        int index = 0;
        while (remainder != 0 && !remainderIndexMap.containsKey(remainder)) {
            remainderIndexMap.put(remainder, index);
            remainder *= 10;
            fractionPart.append(remainder / denominatorLong);
            remainder %= denominatorLong;
            index++;
        }
        if (remainder != 0) { // 有循环节
            int insertIndex = remainderIndexMap.get(remainder);
            fractionPart.insert(insertIndex, '(');
            fractionPart.append(')');
        }
        sb.append(fractionPart.toString());

        return sb.toString();
    }
}
```

题目要求根据给定的分子和分母，将分数转成整数或小数。由于给定的分子和分母的取值范围都是 $[-2^{31}, 2^{31}-1]$，为了防止计算过程中产生溢出，需要将分子和分母转成 64 位整数表示。

将分数转成整数或小数，做法是计算分子和分母相除的结果。可能的结果有三种：整数、有限小数、无限循环小数。

如果分子可以被分母整除，则结果是整数，将分子除以分母的商以字符串的形式返回即可。

如果分子不能被分母整除，则结果是有限小数或无限循环小数，需要通过模拟长除法的方式计算结果。为了方便处理，首先根据分子和分母的正负决定结果的正负（注意此时分子和分母都不为 0），然后将分子和分母都转成正数，再计算长除法。

计算长除法时，首先计算结果的整数部分，将以下部分依次拼接到结果中：

1. 如果结果是负数则将负号拼接到结果中，如果结果是正数则跳过这一步；

2. 将整数部分拼接到结果中；

3. 将小数点拼接到结果中。


完成上述拼接之后，根据余数计算小数部分。

计算小数部分时，每次将余数乘以 10，然后计算小数的下一位数字，并得到新的余数。重复上述操作直到余数变成 0 或者找到循环节。

- 如果余数变成 0，则结果是有限小数，将小数部分拼接到结果中。

- 如果找到循环节，则找到循环节的开始位置和结束位置并加上括号，然后将小数部分拼接到结果中。


如何判断是否找到循环节？注意到对于相同的余数，计算得到的小数的下一位数字一定是相同的，因此如果计算过程中发现某一位的余数在之前已经出现过，则为找到循环节。为了记录每个余数是否已经出现过，需要使用哈希表存储每个余数在小数部分第一次出现的下标。

假设在计算小数部分的第 i 位之前，余数为 $\textit{remainder}_i$，则在计算小数部分的第 i 位之后，余数为 $\textit{remainder}_{i+1}$。

假设存在下标 j 和 k，满足 $j \le k$ 且 $\textit{remainder}_j = \textit{remainder}_{k+1}$，则小数部分的第 k+1 位和小数部分的第 j 位相同，因此小数部分的第 j 位到第 k 位是一个循环节。在计算小数部分的第 k 位之后就会发现这个循环节的存在，因此在小数部分的第 j 位之前加上左括号，在小数部分的末尾（即第 k 位之后）加上右括号。

![fig1](https://assets.leetcode-cn.com/solution-static/166/1.png)

![fig2](https://assets.leetcode-cn.com/solution-static/166/2.png)

#### 复杂度分析

- 时间复杂度：O(l)，其中 l 是答案字符串的长度，这道题中 $l \le 10^4$。对于答案字符串中的每一个字符，计算时间都是 O(1)。
- 空间复杂度：O(l)，其中 l 是答案字符串的长度，这道题中 $l \le 10^4$  。空间复杂度主要取决于答案字符串和哈希表，哈希表中的每个键值对所对应的下标各不相同，因此键值对的数量不会超过 l。

### 补充

而 *_t是typedef定义的表示标志，是结构的一种标注。即我们所看到的 uint8_t、uint16_t、uint32_t都不是新的数据类型，而是通过typedef给类型起得别名。

uint8_t / uint16_t / uint32_t /uint64_t 是什么数据类型

这些数据类型是 C99 中定义的，具体定义在：/usr/include/stdint.h   ISO C99: 7.18 Integer types <stdint.h>

```c++
/* There is some amount of overlap with <sys/types.h> as known by inet code */
#ifndef __int8_t_defined
# define __int8_t_defined
typedef signed char             int8_t; 
typedef short int               int16_t;
typedef int                     int32_t;
# if __WORDSIZE &#61;&#61; 64
typedef long int                int64_t;
# else
__extension__
typedef long long int           int64_t;
# endif
#endif
 
/* Unsigned.  */
typedef unsigned char           uint8_t;
typedef unsigned short int      uint16_t;
#ifndef __uint32_t_defined
typedef unsigned int            uint32_t;
# define __uint32_t_defined
#endif
#if __WORDSIZE &#61;&#61; 64
typedef unsigned long int       uint64_t;
#else
__extension__
typedef unsigned long long int  uint64_t;
#endif
```

