# 题目

编写一个 `StockSpanner` 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。

今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。

例如，如果未来7天股票的价格是 `[100, 80, 60, 70, 60, 75, 85]`，那么股票跨度将是 `[1, 1, 1, 2, 1, 4, 6]`。

**示例：**

```
输入：["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]
输出：[null,1,1,1,2,1,4,6]
解释：
首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。

注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。
```

**提示：**

1. 调用 `StockSpanner.next(int price)` 时，将有 $1 <= price <= 10^5$。
2. 每个测试用例最多可以调用 `10000` 次 `StockSpanner.next`。
3. 在所有测试用例中，最多调用 `150000` 次 `StockSpanner.next`。
4. 此问题的总时间限制减少了 50%。

## 我的解法

第一反应暴力，超时，查看提示后用栈！

```python
class StockSpanner:

    def __init__(self):
        self.nums = []

    def next(self, price: int) -> int:
        self.nums.append(price)
        ans = 0
        for num in self.nums[::-1]:
            if num <= price:
                ans += 1
            else:
                break
        return ans

# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)
```

```c++
class StockSpanner {
public:
    StockSpanner() {
        idx = -1;
        nums.push({-1, INT_MAX});
    }
    
    int next(int price) {
        idx++;
        while(nums.top().second <= price)
        {
            nums.pop();
        }
        int ans = idx - nums.top().first;
        nums.push({idx, price});
        return ans;
    }
private:
    int idx;
    stack<pair<int, int>> nums;
};

/**
 * Your StockSpanner object will be instantiated and called as such:
 * StockSpanner* obj = new StockSpanner();
 * int param_1 = obj->next(price);
 */
```

## 其它解法

### 单调栈

```c++
class StockSpanner {
public:
    StockSpanner() {
        this->stk.emplace(-1, INT_MAX);
        this->idx = -1;
    }
    
    int next(int price) {
        idx++;
        while (price >= stk.top().second) {
            stk.pop();
        }
        int ret = idx - stk.top().first;
        stk.emplace(idx, price);
        return ret;
    }

private:
    stack<pair<int, int>> stk; 
    int idx;
};
```

```java
class StockSpanner {
    Deque<int[]> stack;
    int idx;

    public StockSpanner() {
        stack = new ArrayDeque<int[]>();
        stack.push(new int[]{-1, Integer.MAX_VALUE});
        idx = -1;
    }

    public int next(int price) {
        idx++;
        while (price >= stack.peek()[1]) {
            stack.pop();
        }
        int ret = idx - stack.peek()[0];
        stack.push(new int[]{idx, price});
        return ret;
    }
}
```

```python
class StockSpanner:
    def __init__(self):
        self.stack = [(-1, inf)]
        self.idx = -1

    def next(self, price: int) -> int:
        self.idx += 1
        while price >= self.stack[-1][1]:
            self.stack.pop()
        self.stack.append((self.idx, price))
        return self.idx - self.stack[-2][0]
```

#### 思路

调用 $\textit{next}$时，输入是新的一天的股票价格，需要返回包含此日在内的，往前数最多有连续多少日的股票价格是小于等于今日股票价格的。如果把每日的 $\textit{price}$当成数组不同下标的值，即需要求出每个值与上一个更大元素之间的下标之差。这种题目可以用单调栈求解，TOP_496. 下一个更大元素 I。此题的具体解法上，栈的元素可以是股票价格的下标（即天数）和股票价格的二元数对，并且在栈中先插入一个最大值作为天数为 -1 天的价格，来保证栈不会为空。调用$ \textit{next}$时，先将栈中价格小于等于此时 $\textit{price}$的元素都弹出，直到遇到一个大于 $\textit{price}$的值，并将 $\textit{price}$入栈，计算下标差返回。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为调用 $\textit{next}$函数的次数，每个 $\textit{price}$值最多都会入栈出栈各 1 次。

- 空间复杂度：O(n)，栈中最多有 n 个元素。


