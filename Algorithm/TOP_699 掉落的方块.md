# 题目

在无限长的数轴（即 x 轴）上，我们根据给定的顺序放置对应的正方形方块。

第 `i` 个掉落的方块（`positions[i] = (left, side_length)`）是正方形，其中 `left 表示该方块最左边的点位置(positions[i][0])，side_length 表示该方块的边长(positions[i][1])。`

每个方块的底部边缘平行于数轴（即 x 轴），并且从一个比目前所有的落地方块更高的高度掉落而下。在上一个方块结束掉落，并保持静止后，才开始掉落新方块。

方块的底边具有非常大的粘性，并将保持固定在它们所接触的任何长度表面上（无论是数轴还是其他方块）。邻接掉落的边不会过早地粘合在一起，`因为只有底边才具有粘性。`

返回一个堆叠高度列表 `ans` 。每一个堆叠高度 `ans[i]` 表示在通过 `positions[0], positions[1], ..., positions[i]` 表示的方块掉落结束后，目前所有已经落稳的方块堆叠的最高高度。

**示例 1:**

```
输入: [[1, 2], [2, 3], [6, 1]]
输出: [2, 5, 5]
解释:

第一个方块 positions[0] = [1, 2] 掉落：
_aa
_aa
-------
方块最大高度为 2 。

第二个方块 positions[1] = [2, 3] 掉落：
__aaa
__aaa
__aaa
_aa__
_aa__
--------------
方块最大高度为5。
大的方块保持在较小的方块的顶部，不论它的重心在哪里，因为方块的底部边缘有非常大的粘性。

第三个方块 positions[1] = [6, 1] 掉落：
__aaa
__aaa
__aaa
_aa
_aa___a
-------------- 
方块最大高度为5。

因此，我们返回结果[2, 5, 5]。
```

**示例 2:**

```
输入: [[100, 100], [200, 100]]
输出: [100, 100]
解释: 相邻的方块不会过早地卡住，只有它们的底部边缘才能粘在表面上。
```

**注意:**

- `1 <= positions.length <= 1000`.
- $1 <= positions[i][0] <= 10^8$.
- $1 <= positions[i][1] <= 10^6$.

##  我的解法

未写出，有个神奇的想法，弄一个$10^8 + 10^6$长的数组，遍历累加找到每次遍历中最高的！

## 其他解法

### 暴力枚举

```c++
class Solution {
public:
    vector<int> fallingSquares(vector<vector<int>>& positions) {
        int n = positions.size();
        vector<int> heights(n);
        for (int i = 0; i < n; i++) {
            int left1 = positions[i][0], right1 = positions[i][0] + positions[i][1] - 1;
            heights[i] = positions[i][1];
            for (int j = 0; j < i; j++) {
                int left2 = positions[j][0], right2 = positions[j][0] + positions[j][1] - 1;
                if (right1 >= left2 && right2 >= left1) {
                    heights[i] = max(heights[i], heights[j] + positions[i][1]);
                }
            }
        }
        for (int i = 1; i < n; i++) {
            heights[i] = max(heights[i], heights[i - 1]);
        }
        return heights;
    }
};
```

```java
class Solution {
    public List<Integer> fallingSquares(int[][] positions) {
        int n = positions.length;
        List<Integer> heights = new ArrayList<Integer>();
        for (int i = 0; i < n; i++) {
            int left1 = positions[i][0], right1 = positions[i][0] + positions[i][1] - 1;
            int height = positions[i][1];
            for (int j = 0; j < i; j++) {
                int left2 = positions[j][0], right2 = positions[j][0] + positions[j][1] - 1;
                if (right1 >= left2 && right2 >= left1) {
                    height = Math.max(height, heights.get(j) + positions[i][1]);
                }
            }
            heights.add(height);
        }
        for (int i = 1; i < n; i++) {
            heights.set(i, Math.max(heights.get(i), heights.get(i - 1)));
        }
        return heights;
    }
}
```

```python
class Solution:
    def fallingSquares(self, positions: List[List[int]]) -> List[int]:
        n = len(positions)
        heights = [0] * n
        for i, (left1, side1) in enumerate(positions):
            right1 = left1 + side1 - 1
            heights[i] = side1
            for j in range(i):
                left2, right2 = positions[j][0], positions[j][0] + positions[j][1] - 1
                if right1 >= left2 and right2 >= left1:
                    heights[i] = max(heights[i], heights[j] + side1)
        for i in range(1, n):
            heights[i] = max(heights[i], heights[i - 1])
        return heights
```

我们用数组$ \textit{heights}$记录各个方块掉落后的高度。对于第 i 个掉落的方块，如果它的底部区间与第 j 个掉落的方块有重叠，那么它掉落后的高度至少为 $\textit{heights}[j] + \textit{size}_i$，其中 $j \lt i$ 且 $\textit{size}_i$为第 i 个掉落的方块的边长。因此对于第 i 个掉落的方块，$\textit{heights}[i]$ 的初始值为 $\textit{size}_i$，我们暴力枚举所有之前已经掉落的方块，如果两者的底部区间有重叠，那么更新 $\textit{heights}[i] = \max(\textit{heights}[i], \textit{heights}[j] + \textit{size}_i)$。

因为题目要求返回一个所有已经落稳的方块的最大堆叠高度列表，我们从 i=1 开始，更新 $\textit{heights}[i] = \max(\textit{heights}[i], \textit{heights}[i - 1])$，然后返回 $\textit{heights}$即可。

#### 复杂度分析

时间复杂度：$O(n^2)$，其中 n 是数组 $\textit{positions}$的长度。

空间复杂度：O(1)。返回值不计入空间复杂度。

### 有序集合

```c++
class Solution {
public:
    vector<int> fallingSquares(vector<vector<int>>& positions) {
        int n = positions.size();
        vector<int> ret(n);
        map<int, int> heightMap;
        heightMap[0] = 0; // 初始时从 0 开始的所有点的堆叠高度都是 0
        for (int i = 0; i < n; i++) {
            int size = positions[i][1];
            int left = positions[i][0], right = positions[i][0] + positions[i][1] - 1;
            auto lp = heightMap.upper_bound(left), rp = heightMap.upper_bound(right);
            int rHeight = prev(rp)->second; // 记录 right + 1 对应的堆叠高度（如果 right + 1 不在 heightMap 中）

            // 更新第 i 个掉落的方块的堆叠高度
            int height = 0;
            for (auto p = prev(lp); p != rp; p++) {
                height = max(height, p->second + size);
            }

            // 清除 heightMap 中位于 (left, right] 内的点
            heightMap.erase(lp, rp);

            heightMap[left] = height; // 更新 left 的变化
            if (rp == heightMap.end() || rp->first != right + 1) { // 如果 right + 1 不在 heightMap 中，更新 right + 1 的变化
                heightMap[right + 1] = rHeight;
            }
            ret[i] = i > 0 ? max(ret[i - 1], height) : height;
        }
        return ret;
    }
};
```

```java
class Solution {
    public List<Integer> fallingSquares(int[][] positions) {
        int n = positions.length;
        List<Integer> ret = new ArrayList<Integer>();
        TreeMap<Integer, Integer> heightMap = new TreeMap<Integer, Integer>();
        heightMap.put(0, 0); // 初始时从 0 开始的所有点的堆叠高度都是 0
        for (int i = 0; i < n; i++) {
            int size = positions[i][1];
            int left = positions[i][0], right = positions[i][0] + positions[i][1] - 1;
            Integer lp = heightMap.higherKey(left), rp = heightMap.higherKey(right);
            Integer prevRightKey = rp != null ? heightMap.lowerKey(rp) : heightMap.lastKey();
            int rHeight = prevRightKey != null ? heightMap.get(prevRightKey) : 0; // 记录 right + 1 对应的堆叠高度（如果 right + 1 不在 heightMap 中）

            // 更新第 i 个掉落的方块的堆叠高度
            int height = 0;
            Integer prevLeftKey = lp != null ? heightMap.lowerKey(lp) : heightMap.lastKey();
            Map<Integer, Integer> tail = prevLeftKey != null ? heightMap.tailMap(prevLeftKey) : heightMap;
            for (Map.Entry<Integer, Integer> entry : tail.entrySet()) {
                if (entry.getKey() == rp) {
                    break;
                }
                height = Math.max(height, entry.getValue() + size);
            }

            // 清除 heightMap 中位于 (left, right] 内的点
            Set<Integer> keySet = new TreeSet<Integer>(tail.keySet());
            for (Integer tmp : keySet) {
                if (lp == null || tmp < lp) {
                    continue;
                }
                if (rp != null && tmp >= rp) {
                    break;
                }
                heightMap.remove(tmp);
            }

            heightMap.put(left, height); // 更新 left 的变化
            if (rp == null || rp != right + 1) { // 如果 right + 1 不在 heightMap 中，更新 right + 1 的变化
                heightMap.put(right + 1, rHeight);
            }
            ret.add(i > 0 ? Math.max(ret.get(i - 1), height) : height);
        }
        return ret;
    }
}
```

已经落稳的方块的堆叠高度情况可以使用一个有序集合 $\textit{heightMap}$进行记录，$\textit{heightMap}[x_1]$表示从 $x_1$开始（包括 $x_1$）直到遇到下一个 $x_2$（不包括 $x_2$）的所有数轴上的点的堆叠高度为 $\textit{heightMap}[x_1]$。通俗上来说就是用 $\textit{heightMap}$记录每一个相对于前一个点而言，堆叠高度发生变化的点。初始时，令 $\textit{heightMap}[0] = 0$，表示从 0 开始的所有点的堆叠高度都为 0。

对于第 i 个掉落的方块，记它底部的左端点为$ \textit{left}$，右端点为 $\textit{right}$。我们在有序集合中查找该区间 $[\textit{left}, \textit{right}]$ 内所有点的堆叠高度，然后更新该方块对应的堆叠高度 $\textit{height}$。在第 i 个方块掉落后，区间 $[\textit{left}, \textit{right}]$ 内的所有点的堆叠高度都是 $\textit{height}$，因此我们将有序集合里对应区间 $[\textit{left}, \textit{right}]$ 内的点全部删除。该掉落的方块带来的堆叠高度变化主要在两个点，即 $\textit{left}$和 $\textit{right} + 1$，更新对应的变化即可。

前 i 个掉落的方块的最大堆叠高度等于前 i - 1 个掉落的方块的最大堆叠高度与第 ii 个方块的堆叠高度的最大值。

#### 复杂度分析

- 时间复杂度：$O(n \log n)$，其中 n 是数组 $\textit{positions}$的长度。有序集合 $\textit{heightMap}$最多插入 2n + 1 个元素，因此整个循环最多执行删除操作 2n + 1 次，而每次循环里的查询操作只比删除操作多一次，因此总的查询操作最多为 3n + 1 次；插入操作、删除操作、迭代器递增操作以及二分查找操作都需要 $O(\log n)$，因此总共需要 $O(n \log n)$。

- 空间复杂度：O(n)。有序集合最多保存 2n + 1 个元素。


