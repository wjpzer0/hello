# 题目

二进制矩阵中的所有元素不是 **0** 就是 **1** 。

给你两个四叉树，`quadTree1` 和 `quadTree2`。其中 `quadTree1` 表示一个 `n * n` 二进制矩阵，而 `quadTree2` 表示另一个 `n * n` 二进制矩阵。

请你返回一个表示 `n * n` 二进制矩阵的四叉树，它是 `quadTree1` 和 `quadTree2` 所表示的两个二进制矩阵进行 **按位逻辑或运算** 的结果。

注意，当 `isLeaf` 为 **False** 时，你可以把 **True** 或者 **False** 赋值给节点，两种值都会被判题机制 **接受** 。

四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：

- `val`：储存叶子结点所代表的区域的值。1 对应 **True**，0 对应 **False**；
- `isLeaf`: 当这个节点是一个叶子结点时为 **True**，如果它有 4 个子节点则为 **False** 。

```
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;
}
```

我们可以按以下步骤为二维区域构建四叉树：

1. 如果当前网格的值相同（即，全为 `0` 或者全为 `1`），将 `isLeaf` 设为 True ，将 `val` 设为网格相应的值，并将四个子节点都设为 Null 然后停止。
2. 如果当前网格的值不同，将 `isLeaf` 设为 False， 将 `val` 设为任意值，然后如下图所示，将当前网格划分为四个子网格。
3. 使用适当的子网格递归每个子节点。

![img](https://assets.leetcode.com/uploads/2020/02/11/new_top.png)

如果你想了解更多关于四叉树的内容，可以参考 [wiki](https://en.wikipedia.org/wiki/Quadtree) 。

**四叉树格式：**

输出为使用层序遍历后四叉树的序列化形式，其中 `null` 表示路径终止符，其下面不存在节点。

它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 `[isLeaf, val]` 。

如果 `isLeaf` 或者 `val` 的值为 True ，则表示它在列表 `[isLeaf, val]` 中的值为 **1** ；如果 `isLeaf` 或者 `val` 的值为 False ，则表示值为 **0** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/02/11/qt1.png) ![img](https://assets.leetcode.com/uploads/2020/02/11/qt2.png)

```
输入：quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]
, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
输出：[[0,0],[1,1],[1,1],[1,1],[1,0]]
解释：quadTree1 和 quadTree2 如上所示。由四叉树所表示的二进制矩阵也已经给出。
如果我们对这两个矩阵进行按位逻辑或运算，则可以得到下面的二进制矩阵，由一个作为结果的四叉树表示。
注意，我们展示的二进制矩阵仅仅是为了更好地说明题意，你无需构造二进制矩阵来获得结果四叉树。
```

![img](https://assets.leetcode.com/uploads/2020/02/11/qtr.png)

**示例 2：**

```
输入：quadTree1 = [[1,0]]
, quadTree2 = [[1,0]]
输出：[[1,0]]
解释：两个数所表示的矩阵大小都为 1*1，值全为 0 
结果矩阵大小为 1*1，值全为 0 。
```

**示例 3：**

```
输入：quadTree1 = [[0,0],[1,0],[1,0],[1,1],[1,1]]
, quadTree2 = [[0,0],[1,1],[1,1],[1,0],[1,1]]
输出：[[1,1]]
```

**示例 4：**

```
输入：quadTree1 = [[0,0],[1,1],[1,0],[1,1],[1,1]]
, quadTree2 = [[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]
输出：[[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]
```

**示例 5：**

```
输入：quadTree1 = [[0,1],[1,0],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
, quadTree2 = [[0,1],[0,1],[1,0],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1]]
输出：[[0,0],[0,1],[0,1],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1],[1,0],[1,0],[1,1],[1,1]]
```

**提示：**

- `quadTree1` 和 `quadTree2` 都是符合题目要求的四叉树，每个都代表一个 `n * n` 的矩阵。
- `n == 2^x` ，其中 `0 <= x <= 9`.

## 我的解法

边界处理不到位，处理方式过于繁琐，导致出现问题，查看题解后写出！

```python
"""
# Definition for a QuadTree node.
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight
"""

class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        def dfs(node1, node2):
            if node1 == None:
                return node2
            elif node2 == None:
                return node1

            if node1.isLeaf == 1 and node2.isLeaf == 1:
                return  Node(node1.val | node2.val, 1)
            elif node1.isLeaf == 1 and node2.isLeaf == 0:
                if node1.val == 0:
                    return node2
                else:
                    return node1
            elif node1.isLeaf == 0 and node2.isLeaf == 1:
                if node2.val == 0:
                    return node1
                else:
                    return node2
            else:
                tLeft = dfs(node1.topLeft, node2.topLeft)
                tRight = dfs(node1.topRight, node2.topRight)
                bLeft = dfs(node1.bottomLeft, node2.bottomLeft)
                bRight = dfs(node1.bottomRight, node2.bottomRight)
                if tLeft.isLeaf == 1 and tRight.isLeaf == 1 and bLeft.isLeaf == 1 and bRight.isLeaf == 1:
                    if tLeft.val == 1 and tRight.val == 1 and bLeft.val == 1 and bRight.val == 1:
                        return Node(1, 1)
                return Node(0, 0, tLeft, tRight, bLeft, bRight)
        return dfs(quadTree1, quadTree2)       
```

```python
"""
# Definition for a QuadTree node.
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight
"""

class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        def dfs(node1, node2):
            if node1.isLeaf:
                return Node(1, 1) if node1.val else node2
            if node2.isLeaf:
                return dfs(node2, node1)
            tLeft = dfs(node1.topLeft, node2.topLeft)
            tRight = dfs(node1.topRight, node2.topRight)
            bLeft = dfs(node1.bottomLeft, node2.bottomLeft)
            bRight = dfs(node1.bottomRight, node2.bottomRight)
            if tLeft.isLeaf == 1 and tRight.isLeaf == 1 and bLeft.isLeaf == 1 and bRight.isLeaf == 1:
                if tLeft.val == 1 and tRight.val == 1 and bLeft.val == 1 and bRight.val == 1:
                    return Node(1, 1)
            return Node(0, 0, tLeft, tRight, bLeft, bRight)
        return dfs(quadTree1, quadTree2)
```

## 其他解法

### 分治

```c++
class Solution {
public:
    Node* intersect(Node* quadTree1, Node* quadTree2) {
        if (quadTree1->isLeaf) {
            if (quadTree1->val) {
                return new Node(true, true);
            }
            return new Node(quadTree2->val, quadTree2->isLeaf, quadTree2->topLeft, quadTree2->topRight, quadTree2->bottomLeft, quadTree2->bottomRight);
        }
        if (quadTree2->isLeaf) {
            return intersect(quadTree2, quadTree1);
        }
        Node* o1 = intersect(quadTree1->topLeft, quadTree2->topLeft);
        Node* o2 = intersect(quadTree1->topRight, quadTree2->topRight);
        Node* o3 = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);
        Node* o4 = intersect(quadTree1->bottomRight, quadTree2->bottomRight);
        if (o1->isLeaf && o2->isLeaf && o3->isLeaf && o4->isLeaf && o1->val == o2->val && o1->val == o3->val && o1->val == o4->val) {
            return new Node(o1->val, true);
        }
        return new Node(false, false, o1, o2, o3, o4);
    }
};
```

```java
class Solution {
    public Node intersect(Node quadTree1, Node quadTree2) {
        if (quadTree1.isLeaf) {
            if (quadTree1.val) {
                return new Node(true, true);
            }
            return new Node(quadTree2.val, quadTree2.isLeaf, quadTree2.topLeft, quadTree2.topRight, quadTree2.bottomLeft, quadTree2.bottomRight);
        }
        if (quadTree2.isLeaf) {
            return intersect(quadTree2, quadTree1);
        }
        Node o1 = intersect(quadTree1.topLeft, quadTree2.topLeft);
        Node o2 = intersect(quadTree1.topRight, quadTree2.topRight);
        Node o3 = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);
        Node o4 = intersect(quadTree1.bottomRight, quadTree2.bottomRight);
        if (o1.isLeaf && o2.isLeaf && o3.isLeaf && o4.isLeaf && o1.val == o2.val && o1.val == o3.val && o1.val == o4.val) {
            return new Node(o1.val, true);
        }
        return new Node(false, false, o1, o2, o3, o4);
    }
}
```

```python
class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        if quadTree1.isLeaf:
            return Node(True, True) if quadTree1.val else quadTree2
        if quadTree2.isLeaf:
            return self.intersect(quadTree2, quadTree1)
        o1 = self.intersect(quadTree1.topLeft, quadTree2.topLeft)
        o2 = self.intersect(quadTree1.topRight, quadTree2.topRight)
        o3 = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
        o4 = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)
        if o1.isLeaf and o2.isLeaf and o3.isLeaf and o4.isLeaf and o1.val == o2.val == o3.val == o4.val:
            return Node(o1.val, True)
        return Node(False, False, o1, o2, o3, o4)
```

#### 思路与算法

题目给出两棵「四叉树」——$\textit{quadTree}_1$，和$ \textit{quadTree}_2$，它们分别代表一个 $n \times n$  的矩阵，且每一个子节点都是父节点对应矩阵区域的 $\dfrac{1}{4}$ 
区域：

- $\textit{topLeft}$节点为其父节点对应的矩阵区域左上角的 $\dfrac{1}{4}$ 区域。
- $\textit{topRight}$节点为其父节点对应的矩阵区域右上角的 $\dfrac{1}{4} $  区域。
- $\textit{bottomLeft}$节点为其父节点对应的矩阵区域左下角的 $\dfrac{1}{4} $  区域。
- $\textit{bottomRight}$节点为其父节点对应的矩阵区域右下角的$ \dfrac{1}{4}$   区域。

我们需要把这两个矩阵中的对应位置的值进行「或」操作，然后返回操作后的矩阵即可。对于 $\forall x \in \{0,1\}$，有 $0 ~|~ x = x$ 和 1 $~|~ x = 1$ 成立。那么我们按照两棵树的对应的节点来进行合并操作，假设当前我们操作的两个节点分别为 $\textit{node}_1$ 和 $\textit{node}_2$，记节点的合并操作为 $\textit{node}_1 ~|~ \textit{node}_2$：

1. $\textit{node}_1$ 为叶子节点时：
   - 如果 $\textit{node}_1$的值为 1，那么 $\textit{node}_1 ~|~ \textit{node}_2 = \textit{node}_1$。
   - 否则 $\textit{node}_1 ~|~ \textit{node}_2 = \textit{node}_2$。
2. $\textit{node}_2$为叶子节点时：
   - 如果 $\textit{node}_2$ 的值为 1，那么 $\textit{node}_1 ~|~ \textit{node}_2 = \textit{node}_2$。
   - 否则 $\textit{node}_1 ~|~ \textit{node}_2 = \textit{node}_1$。
3. 两者都不是叶子节点时：那么分别对两者的四个子节点来进行对应的分治处理——分别进行合并操作，然后再判断合并后的四个子节点的对应区域是否都为一个全 0 或者全 1 区域，如果是则原节点为叶子节点，否则原节点不是叶子节点，且四个子节点为上面合并操作后的四个对应子节点。

#### 复杂度分析

- 时间复杂度：$O(n^2)$，其中 n 是四叉树$ \textit{quadTree}_1$和 $\textit{quadTree}_2$ 对应矩阵的边长。最坏的情况下，整个矩阵都会被遍历。
- 空间复杂度：$O(\log n)$，其中 n 是四叉树 $\textit{quadTree}_1$和 $\textit{quadTree}_2$ 对应矩阵的边长。空间开销主要为递归的空间开销。

