# 题目

给你一个以字符串形式表述的 [布尔表达式](https://baike.baidu.com/item/布尔表达式/1574380?fr=aladdin)（boolean） `expression`，返回该式的运算结果。

有效的表达式需遵循以下约定：

- `"t"`，运算结果为 `True`
- `"f"`，运算结果为 `False`
- `"!(expr)"`，运算过程为对内部表达式 `expr` 进行逻辑 **非的运算**（NOT）
- `"&(expr1,expr2,...)"`，运算过程为对 2 个或以上内部表达式 `expr1, expr2, ...` 进行逻辑 **与的运算**（AND）
- `"|(expr1,expr2,...)"`，运算过程为对 2 个或以上内部表达式 `expr1, expr2, ...` 进行逻辑 **或的运算**（OR）

 

**示例 1：**

```
输入：expression = "!(f)"
输出：true
```

**示例 2：**

```
输入：expression = "|(f,t)"
输出：true
```

**示例 3：**

```
输入：expression = "&(t,f)"
输出：false
```

**示例 4：**

```
输入：expression = "|(&(t,f,t),!(t))"
输出：false
```

**提示：**

- `1 <= expression.length <= 20000`
- `expression[i]` 由 `{'(', ')', '&', '|', '!', 't', 'f', ','}` 中的字符组成。
- `expression` 是以上述形式给出的有效表达式，表示一个布尔值。

## 我的解法

```python
class Solution:
    def parseBoolExpr(self, expression: str) -> bool:
        def dfs(s):
            if s[0] == "t":
                return 1
            elif s[0] == "f":
                return 0
            elif s[0] == "!":
                mid = dfs(s[2:-1])
                return mid ^ 1
            elif s[0] == "&":
                mid = s[2:-1]
                ans = 1
                mark = 0
                start = 0
                for i, char in enumerate(mid):
                    if char == "(":
                        mark += 1 
                    elif char == ")":
                        mark -= 1
                    if mark == 0 and char == ",":
                        ans &= dfs(mid[start:i])
                        start = i + 1
                ans &= dfs(mid[start:])
                return ans
            elif s[0] == "|":
                mid = s[2:-1]
                ans = 0
                mark = 0
                start = 0
                for i, char in enumerate(mid):
                    if char == "(":
                        mark += 1
                    elif char == ")":
                        mark -= 1
                    if mark == 0 and char == ",":
                        ans |= dfs(mid[start:i])
                        start = i + 1
                ans |= dfs(mid[start:])
                return ans
        ans = dfs(expression)
        return True if ans else False
```

## 其它解法

### 栈

```c++
class Solution {
public:
    bool parseBoolExpr(string expression) {
        stack<char> stk;
        int n = expression.size();
        for (int i = 0; i < n; i++) {
            char c = expression[i];
            if (c == ',') {
                continue;
            } else if (c != ')') {
                stk.push(c);
            } else {
                int t = 0, f = 0;
                while (stk.top() != '(') {
                    char val = stk.top();
                    stk.pop();
                    if (val == 't') {
                        t++;
                    } else {
                        f++;
                    }
                }
                stk.pop();
                char op = stk.top();
                stk.pop();
                switch (op) {
                case '!':
                    stk.push(f == 1 ? 't' : 'f');
                    break;
                case '&':
                    stk.push(f == 0 ? 't' : 'f');
                    break;
                case '|':
                    stk.push(t > 0 ? 't' : 'f');
                    break;
                default:
                    break;
                }
            }
        }
        return stk.top() == 't';
    }
};
```

```java
class Solution {
    public boolean parseBoolExpr(String expression) {
        Deque<Character> stack = new ArrayDeque<Character>();
        int n = expression.length();
        for (int i = 0; i < n; i++) {
            char c = expression.charAt(i);
            if (c == ',') {
                continue;
            } else if (c != ')') {
                stack.push(c);
            } else {
                int t = 0, f = 0;
                while (stack.peek() != '(') {
                    char val = stack.pop();
                    if (val == 't') {
                        t++;
                    } else {
                        f++;
                    }
                }
                stack.pop();
                char op = stack.pop();
                switch (op) {
                case '!':
                    stack.push(f == 1 ? 't' : 'f');
                    break;
                case '&':
                    stack.push(f == 0 ? 't' : 'f');
                    break;
                case '|':
                    stack.push(t > 0 ? 't' : 'f');
                    break;
                default:
                }
            }
        }
        return stack.pop() == 't';
    }
}
```

```python
class Solution:
    def parseBoolExpr(self, expression: str) -> bool:
        stk = []
        for c in expression:
            if c == ',':
                continue
            if c != ')':
                stk.append(c)
                continue
            t = f = 0
            while stk[-1] != '(':
                if stk.pop() == 't':
                    t += 1
                else:
                    f += 1
            stk.pop()
            op = stk.pop()
            if op == '!':
                stk.append('t' if f == 1 else 'f')
            elif op == '&':
                stk.append('t' if f == 0 else 'f')
            elif op == '|':
                stk.append('t' if t else 'f')
        return stk[-1] == 't'
```

给定的字符串$ \textit{expression}$是有效的布尔表达式，每个运算符后面都有一对括号，括号中有一个或多个表达式。其中，逻辑非运算符后面的括号中有一个表达式，逻辑与运算符和逻辑或运算符后面的括号中有两个或以上表达式。

可以使用栈实现布尔表达式的解析。从左到右遍历布尔表达式，对于每种类型的字符，执行相应的操作：

- 如果当前字符是逗号，则跳过该字符；

- 如果当前字符是除了逗号和右括号以外的任意字符，则将该字符添加到栈内；

- 如果当前字符是右括号，则一个表达式遍历结束，需要解析该表达式的值，并将结果添加到栈内：

  1. 将栈内字符依次弹出，直到栈顶字符是左括号，然后将左括号和运算符从栈内弹出，记录弹出的$ \text{'t'}$ 和 $\text{'f'}$ 的个数；

  2. 根据运算符以及 $\text{'t'}$ 和 $\text{'f'}$ 的个数计算表达式的值，并将表达式的值添加到栈内：

     - 如果运算符是 $\text{'!'}$，则是逻辑非运算符，表达式的值为括号内的值取反，因此当 $\text{'f'}$ 的个数等于 1 时表达式的值为 $\text{'t'}$，否则表达式的值为 $\text{'f'}$；

     - 如果运算符是 $\text{'\&'}$，则是逻辑与运算符，当括号内的所有值都是 $\text{'t'}$ 时结果是 $\text{'t'}$，否则结果是$ \text{'f'}$，因此当 $\text{'f'}$ 的个数等于 0 时表达式的值为 $\text{'t'}$，否则表达式的值为 $\text{'f'}$；

     - 如果运算符是 $\text{'|'}$，则是逻辑或运算符，当括号内至少有一个值都是 $\text{'t'}$ 时结果是 $\text{'t'}$，否则结果是 $\text{'f'}$，因此当 $\text{'t'}$ 的个数大于 0 时表达式的值为 $\text{'t'}$，否则表达式的值为 $\text{'f'}$；

遍历结束之后，栈内只有一个字符，该字符为 $\text{'t'} $或 $\text{'f'}$，如果字符为 $\text{'t'}$ 则返回 $\text{true}$，如果字符为 $\text{'f'} $则返回 $\text{false}$。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是布尔表达式 $\textit{expression}$的长度。需要遍历布尔表达式一次并解析。

- 空间复杂度：O(n)，其中 n 是布尔表达式 $\textit{expression}$的长度。空间复杂度主要取决于栈空间，栈内字符个数不超过 n。


