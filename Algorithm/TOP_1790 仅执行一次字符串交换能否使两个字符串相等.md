# 题目

给你长度相等的两个字符串 `s1` 和 `s2` 。一次 **字符串交换** 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。

如果对 **其中一个字符串** 执行 **最多一次字符串交换** 就可以使两个字符串相等，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：s1 = "bank", s2 = "kanb"
输出：true
解释：例如，交换 s2 中的第一个和最后一个字符可以得到 "bank"
```

**示例 2：**

```
输入：s1 = "attack", s2 = "defend"
输出：false
解释：一次字符串交换无法使两个字符串相等
```

**示例 3：**

```
输入：s1 = "kelb", s2 = "kelb"
输出：true
解释：两个字符串已经相等，所以不需要进行字符串交换
```

**示例 4：**

```
输入：s1 = "abcd", s2 = "dcba"
输出：false
```

**提示：**

- `1 <= s1.length, s2.length <= 100`
- `s1.length == s2.length`
- `s1` 和 `s2` 仅由小写英文字母组成

## 我的解法

思路清晰，代码应该还可以优化！

```python
class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        mark = []
        for char1, char2 in zip(s1, s2):
            if char1 != char2:
                mark.append((char1, char2))
        if len(mark) == 0:
            return True
        if len(mark) != 2:
            return False
        return mark[0][0] == mark[1][1] and mark[0][1] == mark[1][0]
```

## 其它解法

### 计数统计

```c++
class Solution {
public:
    bool areAlmostEqual(string s1, string s2) {
        int n = s1.size();
        vector<int> diff;
        for (int i = 0; i < n; ++i) {
            if (s1[i] != s2[i]) {
                if (diff.size() >= 2) {
                    return false;
                }
                diff.emplace_back(i);
            }
        }
        if (diff.size() == 0) {
            return true;
        }
        if (diff.size() != 2) {
            return false;
        }
        return s1[diff[0]] == s2[diff[1]] && s1[diff[1]] == s2[diff[0]];
    }
};
```

```java
class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        int n = s1.length();
        List<Integer> diff = new ArrayList<Integer>();
        for (int i = 0; i < n; ++i) {
            if (s1.charAt(i) != s2.charAt(i)) {
                if (diff.size() >= 2) {
                    return false;
                }
                diff.add(i);
            }
        }
        if (diff.isEmpty()) {
            return true;
        }
        if (diff.size() != 2) {
            return false;
        }
        return s1.charAt(diff.get(0)) == s2.charAt(diff.get(1)) && s1.charAt(diff.get(1)) == s2.charAt(diff.get(0));
    }
}
```

```python
class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        i = j = -1
        for idx, (x, y) in enumerate(zip(s1, s2)):
            if x != y:
                if i < 0:
                    i = idx
                elif j < 0:
                    j = idx
                else:
                    return False
        return i < 0 or j >= 0 and s1[i] == s2[j] and s1[j] == s2[i]
```

题目要求其中一个字符串执行最多一次字符交换使得两个字符串相等，意味着两个字符串中最多只存在两个位置 i,j 处字符不相等，此时我们交换 i,ji,j 处字符可使其相等。设两个字符串分别为 $s_1,s_2$：

- 如果两个字符串 $s_1,s_2$相等，则不需要进行交换即可满足相等；
- 如果两个字符串 $s_1,s_2$不相等，字符串一定存在两个位置 i,j 处的字符不相等，需要交换 i,j 处字符使其相等，此时一定满足 $s_1[i] = s_2[j], s_1[j] = s_2[i]$ ；如果两个字符中只存在一个或大于两个位置的字符不相等，则此时无法通过一次交换使其相等；

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 表示字符串的长度。我们只需遍历一遍字符串即可。

- 空间复杂度：O(C)。由于两个字符串中字符不同的数目大于 2 即可返回，因此最多只需要保存 C = 2个不同位置的索引即可。


