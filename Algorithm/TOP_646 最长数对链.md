# 题目

给出 `n` 个数对。 在每一个数对中，第一个数字总是比第二个数字小。

现在，我们定义一种跟随关系，当且仅当 `b < c` 时，数对`(c, d)` 才可以跟在 `(a, b)` 后面。我们用这种形式来构造一个数对链。

给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

**示例：**

```
输入：[[1,2], [2,3], [3,4]]
输出：2
解释：最长的数对链是 [1,2] -> [3,4]
```

 

**提示：**

- 给出数对的个数在 `[1, 1000]` 范围内。

## 我的解法

跟着直觉解题！

```python
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        newPairs = sorted(pairs, key=lambda x: x[1])
        pre = newPairs[0]
        n = len(pairs)
        ans = 1
        for i in range(1, n):
            if newPairs[i][0] > pre[1]:
                pre = newPairs[i]
                ans += 1
        return ans
```

## 其它解法

### 前言

这题和 TOP_435. 无重叠区间 类似，区别就是：

- 此题中，数对链中相邻的数对，前者的第二个数字必须小于后者的第一个数字。而在 TOP_435. 无重叠区间 中，相邻的区间，前者的结束时间需小于等于后者的开始时间。
- 此题返回最长数对链的长度，而  TOP_435. 无重叠区间 返回形成无重叠区间，最少需要删除多少区间（即原长度减去最长数对链的长度）。
  

### 动态规划

```c++
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        int n = pairs.size();
        sort(pairs.begin(), pairs.end());
        vector<int> dp(n, 1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (pairs[i][0] > pairs[j][1]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return dp[n - 1];
    }
};
```

```java
class Solution {
    public int findLongestChain(int[][] pairs) {
        int n = pairs.length;
        Arrays.sort(pairs, (a, b) -> a[0] - b[0]);
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (pairs[i][0] > pairs[j][1]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        return dp[n - 1];
    }
}
```

```python
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs.sort()
        dp = [1] * len(pairs)
        for i in range(len(pairs)):
            for j in range(i):
                if pairs[i][0] > pairs[j][1]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return dp[-1]
```

#### 思路

定义 $\textit{dp}[i]$ 为以 $\textit{pairs}[i]$ 为结尾的最长数对链的长度。计算 $\textit{dp}[i]$ 时，可以先找出所有的满足 $\textit{pairs}[i][0] > \textit{pairs}[j][1]$ 的 j，并求出最大的 $\textit{dp}[j]$，$\textit{dp}[i]$ 的值即可赋为这个最大值加一。这种动态规划的思路要求计算 $\textit{dp}[i]$ 时，所有潜在的 $\textit{dp}[j]$ 已经计算完成，可以先将 $\textit{pairs}$ 进行排序来满足这一要求。初始化时，$\textit{dp}$ 需要全部赋值为 1。

#### 复杂度分析

- 时间复杂度：$O(n^2)$，其中 n 为 $\textit{pairs}$的长度。排序的时间复杂度为 $O(n \log n)$，两层 $\texttt{for}$ 循环的时间复杂度为 $O(n^2)$。

- 空间复杂度：O(n)，数组 ￥的空间复杂度为 O(n)。


### 最长递增子序列

```c++
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end());
        vector<int> arr;
        for (auto p : pairs) {
            int x = p[0], y = p[1];
            if (arr.size() == 0 || x > arr.back()) {
                arr.emplace_back(y);
            } else {
                int idx = lower_bound(arr.begin(), arr.end(), x) - arr.begin();
                arr[idx] = min(arr[idx], y);
            }
        }
        return arr.size();
    }
};
```

```java
class Solution {
    public int findLongestChain(int[][] pairs) {
        Arrays.sort(pairs, (a, b) -> a[0] - b[0]);
        List<Integer> arr = new ArrayList<Integer>();
        for (int[] p : pairs) {
            int x = p[0], y = p[1];
            if (arr.isEmpty() || x > arr.get(arr.size() - 1)) {
                arr.add(y);
            } else {
                int idx = binarySearch(arr, x);
                arr.set(idx, Math.min(arr.get(idx), y));
            }
        }
        return arr.size();
    }

    public int binarySearch(List<Integer> arr, int x) {
        int low = 0, high = arr.size() - 1;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (arr.get(mid) >= x) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
}
```

```python
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs.sort()
        arr = []
        for x, y in pairs:
            i = bisect_left(arr, x)
            if i < len(arr):
                arr[i] = min(arr[i], y)
            else:
                arr.append(y)
        return len(arr)
```

#### 思路

方法一实际上是 TOP_300. 最长递增子序列 的动态规划解法，这个解法可以改造为贪心 + 二分查找的形式。用一个数组 $\textit{arr}$来记录当前最优情况，$\textit{arr}[i]$ 就表示长度为 i+1 的数对链的末尾可以取得的最小值，遇到一个新数对时，先用二分查找得到这个数对可以放置的位置，再更新$ \textit{arr}$。

#### 复杂度分析

- 时间复杂度：$O(n \log n)$，其中 n 为 $\textit{pairs}$的长度。排序的时间复杂度为 $O(n \log n)$，二分查找的时间复杂度为 $O(n \log n)$，二分的次数为 O(n)。

- 空间复杂度：O(n)，数组 $\textit{arr}$的长度最多为 O(n)。


### 贪心

```c++
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        int curr = INT_MIN, res = 0;
        sort(pairs.begin(), pairs.end(), [](const vector<int> &a, const vector<int> &b) {
            return a[1] < b[1];
        });
        for (auto &p : pairs) {
            if (curr < p[0]) {
                curr = p[1];
                res++;
            }
        }
        return res;
    }
};
```

```java
class Solution {
    public int findLongestChain(int[][] pairs) {
        int curr = Integer.MIN_VALUE, res = 0;
        Arrays.sort(pairs, (a, b) -> a[1] - b[1]);
        for (int[] p : pairs) {
            if (curr < p[0]) {
                curr = p[1];
                res++;
            }
        }
        return res;
    }
}
```

```python
class Solution(object):
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        cur, res = -inf, 0
        for x, y in sorted(pairs, key=lambda p: p[1]):
            if cur < x:
                cur = y
                res += 1
        return res
```

#### 思路

要挑选最长数对链的第一个数对时，最优的选择是挑选第二个数字最小的，这样能给挑选后续的数对留下更多的空间。挑完第一个数对后，要挑第二个数对时，也是按照相同的思路，是在剩下的数对中，第一个数字满足题意的条件下，挑选第二个数字最小的。按照这样的思路，可以先将输入按照第二个数字排序，然后不停地判断第一个数字是否能满足大于前一个数对的第二个数字即可。

#### 复杂度分析

时间复杂度：$O(n \log n)$，其中 n 为 ￥的长度。排序的时间复杂度为 ￥。

空间复杂度：$O(\log n)$，为排序的空间复杂度。

