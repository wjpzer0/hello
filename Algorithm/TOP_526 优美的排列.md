# 题目

假设有从 1 到 N 的 **N** 个整数，如果从这 **N** 个数字中成功构造出一个数组，使得数组的第 **i** 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：

1. 第 **i** 位的数字能被 **i** 整除
2. **i** 能被第 **i** 位上的数字整除

现在给定一个整数 N，请问可以构造多少个优美的排列？

**示例1:**

```
输入: 2
输出: 2
解释: 

第 1 个优美的排列是 [1, 2]:
  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除

第 2 个优美的排列是 [2, 1]:
  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除
```

**说明:**

1. **N** 是一个正整数，并且不会超过15。

## 我的解法

又划水，没写，思路应该是正确的，但是没有想到回溯的解法！

## 其他解法

### 回溯

```c++
class Solution {
public:
    vector<vector<int>> match;
    vector<int> vis;
    int num;

    void backtrack(int index, int n) {
        if (index == n + 1) {
            num++;
            return;
        }
        for (auto &x : match[index]) {
            if (!vis[x]) {
                vis[x] = true;
                backtrack(index + 1, n);
                vis[x] = false;
            }
        }
    }

    int countArrangement(int n) {
        vis.resize(n + 1);
        match.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (i % j == 0 || j % i == 0) {
                    match[i].push_back(j);
                }
            }
        }
        backtrack(1, n);
        return num;
    }
};
```

```java
class Solution {
    List<Integer>[] match;
    boolean[] vis;
    int num;

    public int countArrangement(int n) {
        vis = new boolean[n + 1];
        match = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            match[i] = new ArrayList<Integer>();
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (i % j == 0 || j % i == 0) {
                    match[i].add(j);
                }
            }
        }
        backtrack(1, n);
        return num;
    }

    public void backtrack(int index, int n) {
        if (index == n + 1) {
            num++;
            return;
        }
        for (int x : match[index]) {
            if (!vis[x]) {
                vis[x] = true;
                backtrack(index + 1, n);
                vis[x] = false;
            }
        }
    }
}
```

```python
class Solution:
    def countArrangement(self, n: int) -> int:
        match = defaultdict(list)
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                if i % j == 0 or j % i == 0:
                    match[i].append(j)
        
        num = 0
        vis = set()

        def backtrack(index: int) -> None:
            if index == n + 1:
                nonlocal num
                num += 1
                return
            
            for x in match[index]:
                if x not in vis:
                    vis.add(x)
                    backtrack(index + 1)
                    vis.discard(x)
                   
        backtrack(1)
        return num
```

#### 思路和算法

我们可以使用回溯法解决本题，从左向右依次向目标排列中放入数即可。

具体地，我们定义函数 $\textit{backtrack}(\textit{index}, n)$​，表示尝试向位置 $\textit{index}$ 放入数。其中 n 表示排列的长度。在当前函数中，我们首先找到一个符合条件的未被使用过的数，然后递归地执行 $\textit{backtrack}(\textit{index}+1, n)$，当该函数执行完毕，回溯到当前层，我们再尝试下一个符合条件的未被使用过的数即可。

回溯过程中，我们可以用 $\textit{vis}$ 数组标记哪些数被使用过，每次我们选中一个数 x，我们就将 $\textit{vis}[x]$ 标记为 $\texttt{true}$，回溯完成后，我们再将其置为 $\texttt{false}$。

特别地，为了优化回溯效率，我们可以预处理每个位置的符合条件的数有哪些，用二维数组 $\textit{match}$​ 保存。当我们尝试向位置 $\textit{index}$ 放入数时，我们只需要遍历 $\textit{match}[\textit{index}]$ 即可。

#### 复杂度分析

- 时间复杂度：O(n!)，其中 nn 为排列的长度。预处理 $\textit{match}$ 数组的时间复杂度为 $O(n^2)$​，回溯的时间复杂度为 O(n!)，因此总时间复杂度为 $O(n^2 + n!) = O(n!)$。
- 空间复杂度：$O(n^2)$，我们需要 $O(n^2)$​的空间保存 $\textit{match}$​​ 数组，递归的栈空间大小为 O(n)，因此总空间复杂度为 $O(n^2 + n) = O(n^2)$。


### 状态压缩 + 动态规划

```c++
class Solution {
public:
    int countArrangement(int n) {
        vector<int> f(1 << n);
        f[0] = 1;
        for (int mask = 1; mask < (1 << n); mask++) {
            int num = __builtin_popcount(mask);
            for (int i = 0; i < n; i++) {
                if (mask & (1 << i) && (num % (i + 1) == 0 || (i + 1) % num == 0)) {
                    f[mask] += f[mask ^ (1 << i)];
                }
            }
        }
        return f[(1 << n) - 1];
    }
};
```

```java
// 用 mask 的二进制表示选取状态，n 个数字用 n 位表示，第 i 位为 1 代表数字 i+1 已被选取（i从0开始），n 中 1 的个数 m 代表前 m 位已放置
// 例如：二进制 100110 共三个1，代表排列的前三位已放置数字，三个1分别在二进制第 1、2、5位置上(从右侧开始，从0开始计数）, 所以 2、3、6三个数字被选取，综合起来就是表示：2 3 6 这三个数字被放到了排列的前三位，三个数字完美排列方式未知，通过枚举 mask 进行计算

class Solution {
    public int countArrangement(int n) {
        // 用来存储中间结果，f[6] = f[000110] = 数字2、3在前两位时的完美排列数量
        int[] f = new int[1 << n];
        f[0] = 1;
        // 通过 mask 进行枚举，最终目的是为了得到二进制 mask = (11..11)n 时，总的完美排列数 
        for (int mask = 1; mask < (1 << n); mask++) {
            int num = Integer.bitCount(mask);
            // 遍历 mask 的每一位，仍以 mask = 100110 为例，此 mask 代表 2 3 6三个数字在排列的前三位
            // 求三个数字 2 3 6 的完美排列方式，则先确定2 3 6哪些数字能放到第三位，然后累加另外两个数字的完美排列数量来获得
            // 2 3 6，第三位可以为 6，则 f[100110] += f[000110] (2、3在前两位时的完美排列数量)
            // 2 3 6，第三位可以为 3，则 f[100110] += f[100010] (2、6在前两位时的完美排列数量)
            for (int i = 0; i < n; i++) {
                // mask & (1<<i) 用来判断 mask 第 i 位是否为 1，如果为 1，说明第 i+1 个数字被选取
                // ((num % (i + 1)) == 0 || (i + 1) % num == 0) 判断被选取的数字 i+1 能否放到位置 num 上，
                // 即：先从被选取的数字中找到能放到最高位 num 的数字，然后将剩余 num-1 个数字的完美排列方式累加到f[mask]中
                if ((mask & (1 << i)) != 0 && ((num % (i + 1)) == 0 || (i + 1) % num == 0)) {
                    // mask ^ (1 << i) 将 mask 第 i 位设置为 0
                    f[mask] += f[mask ^ (1 << i)];
                }
            }
        }
        return f[(1 << n) - 1];
    }
}
```

```python
class Solution:
    def countArrangement(self, n: int) -> int:
        f = [0] * (1 << n)
        f[0] = 1
        for mask in range(1, 1 << n):
            num = bin(mask).count("1")
            for i in range(n):
                if mask & (1 << i) and (num % (i + 1) == 0 or (i + 1) % num == 0):
                    f[mask] += f[mask ^ (1 << i)]
        
        return f[(1 << n) - 1]
```

#### 思路和算法

由于题目保证了排列的长度 n 至多为 15，因此我们可以用一个位数为 n 的二进制数 $\textit{mask}$ 表示排列中的数被选取的情况。若 $\textit{mask}$ 中的第 i 位为 1（从 0 开始编号），则数 i+1 已经被选取，否则就还未被选取。我们可以利用这样的二进制数表示选取数的过程的状态，以 $n = 4, \textit{mask} = (0110)_2$为例，这代表数 2,3 都已经被选取，并以任意顺序放置在排列中前两个位置。

令 $f[\textit{mask}]$ 表示状态为 $\textit{mask}$ 时的可行方案总数，这样答案即为 $f[2^n - 1]$。

这样我们可以得到状态间的转移方程：

$$
f[\textit{mask}] = \sum_{i \in \textit{mask} ~\wedge \big( i+1 \mid \textit{num}(\textit{mask}) ~\vee~ \textit{num}(\textit{mask}) \mid i+1 \big) } f[\textit{mask} - 2^i]
$$
其中 $\textit{num}(\textit{mask})$ 表示二进制数 $\textit{mask}$ 中 1 的个数，$x \mid y$ 表示 x 可以整除 y。

状态转移方程的含义为，当我们想要计算 $f[\textit{mask}]$ 时，我们只需要在前 $\textit{num}(\textit{mask}) - 1$​ 位都已经放置了数的情况下，考虑第 $\textit{num}(\textit{mask})$ 位要放置的数即可，我们枚举当前位的符合条件的数，并将方案数累加到 $f[\textit{mask}]$ 中即可。

#### 复杂度分析

- 时间复杂度：$O(n \times 2^n)$​，其中 n 为排列的长度。我们需要 $O(2^n)$​ 的时间枚举所有状态，每个状态需要 O(n) 的时间检查所有符合条件的数。因此总时间复杂度为 $O(n \times 2^n)$。

- 空间复杂度：$O(2^n)$，其中 n 为排列的长度。我们需要 $O(2^n)$ 的空间保存状态。

