# 题目

给你一个数组 `nums` ，请你完成两类查询。

1. 其中一类查询要求 **更新** 数组 `nums` 下标对应的值
2. 另一类查询要求返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ **包含** ）的nums元素的 **和** ，其中 `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 用整数数组 `nums` 初始化对象
- `void update(int index, int val)` 将 `nums[index]` 的值 **更新** 为 `val`
- `int sumRange(int left, int right)` 返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ **包含** ）的nums元素的 **和** （即，`nums[left] + nums[left + 1], ..., nums[right]`）

**示例 1：**

```
输入：
["NumArray", "sumRange", "update", "sumRange"]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
输出：
[null, 9, null, 8]

解释：
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1,2,5]
numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8
```

**提示：**

- $1 <= nums.length <= 3 * 10^4$
- `-100 <= nums[i] <= 100`
- `0 <= index < nums.length`
- `-100 <= val <= 100`
- `0 <= left <= right < nums.length`
- 调用 `update` 和 `sumRange` 方法次数不大于 $3 * 10^4$

## 我的解法

前缀和的解法，但仍然超时！

```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.preNums = [0]
        self.nums = nums
        self.n = len(nums)
        sumNum = 0
        for i in nums:
            sumNum += i
            self.preNums.append(sumNum)
        
    def update(self, index: int, val: int) -> None:
        diff = self.nums[index] - val 
        self.nums[index] = val
        for i in range(index + 1, self.n + 1):
            self.preNums[i] -= diff

    def sumRange(self, left: int, right: int) -> int:
        return self.preNums[right + 1] - self.preNums[left]

# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# obj.update(index,val)
# param_2 = obj.sumRange(left,right)
```

## 其他解法

### 分块处理

```c++
class NumArray {
private:
    vector<int> sum; // sum[i] 表示第 i 个块的元素和
    int size; // 块的大小
    vector<int> &nums;
public:
    NumArray(vector<int>& nums) : nums(nums) {
        int n = nums.size();
        size = sqrt(n);
        sum.resize((n + size - 1) / size); // n/size 向上取整
        for (int i = 0; i < n; i++) {
            sum[i / size] += nums[i];
        }
    }

    void update(int index, int val) {
        sum[index / size] += val - nums[index];
        nums[index] = val;
    }

    int sumRange(int left, int right) {
        int b1 = left / size, i1 = left % size, b2 = right / size, i2 = right % size;
        if (b1 == b2) { // 区间 [left, right] 在同一块中
            return accumulate(nums.begin() + b1 * size + i1, nums.begin() + b1 * size + i2 + 1, 0);
        }
        int sum1 = accumulate(nums.begin() + b1 * size + i1, nums.begin() + b1 * size + size, 0);
        int sum2 = accumulate(nums.begin() + b2 * size, nums.begin() + b2 * size + i2 + 1, 0);
        int sum3 = accumulate(sum.begin() + b1 + 1, sum.begin() + b2, 0);
        return sum1 + sum2 + sum3;
    }
};
```

```java
class NumArray {
    private int[] sum; // sum[i] 表示第 i 个块的元素和
    private int size; // 块的大小
    private int[] nums;

    public NumArray(int[] nums) {
        this.nums = nums;
        int n = nums.length;
        size = (int) Math.sqrt(n);
        sum = new int[(n + size - 1) / size]; // n/size 向上取整
        for (int i = 0; i < n; i++) {
            sum[i / size] += nums[i];
        }
    }

    public void update(int index, int val) {
        sum[index / size] += val - nums[index];
        nums[index] = val;
    }

    public int sumRange(int left, int right) {
        int b1 = left / size, i1 = left % size, b2 = right / size, i2 = right % size;
        if (b1 == b2) { // 区间 [left, right] 在同一块中
            int sum = 0;
            for (int j = i1; j <= i2; j++) {
                sum += nums[b1 * size + j];
            }
            return sum;
        }
        int sum1 = 0;
        for (int j = i1; j < size; j++) {
            sum1 += nums[b1 * size + j];
        }
        int sum2 = 0;
        for (int j = 0; j <= i2; j++) {
            sum2 += nums[b2 * size + j];
        }
        int sum3 = 0;
        for (int j = b1 + 1; j < b2; j++) {
            sum3 += sum[j];
        }
        return sum1 + sum2 + sum3;
    }
}
```

```python
class NumArray:
    def __init__(self, nums: List[int]):
        n = len(nums)
        size = int(n ** 0.5)
        sums = [0] * ((n + size - 1) // size)  # n/size 向上取整
        for i, num in enumerate(nums):
            sums[i // size] += num
        self.nums = nums
        self.sums = sums
        self.size = size

    def update(self, index: int, val: int) -> None:
        self.sums[index // self.size] += val - self.nums[index]
        self.nums[index] = val

    def sumRange(self, left: int, right: int) -> int:
        m = self.size
        b1, b2 = left // m, right // m
        if b1 == b2:  # 区间 [left, right] 在同一块中
            return sum(self.nums[left:right + 1])
        return sum(self.nums[left:(b1 + 1) * m]) + sum(self.sums[b1 + 1:b2]) + sum(self.nums[b2 * m:right + 1])
```

#### 思路与算法

设数组大小为 n，我们将数组 $\textit{nums}$ 分成多个块，每个块大小 $\textit{size}$，最后一个块的大小为剩余的不超过 $\textit{size}$ 的元素数目，那么块的总数为$ \Big \lceil \dfrac{n}{\textit{size}} \Big \rceil$，用一个数组 $\textit{sum}$ 保存每个块的元素和。

- 构造函数

  计算块大小 $\textit{size}$，初始化 $\textit{sum}$。

- $\textit{update}$ 函数

  下标 $\textit{index}$ 对应的块下标为 $\Big \lfloor \dfrac{\textit{index}}{\textit{size}} \Big \rfloor$，更新 $\textit{nums}$ 和 $\textit{sum}$。

- $\textit{sumRange}$ 函数

  设 $\textit{left}$ 位于第 $b_1$个块内的第 $i_1$个元素，$\textit{right}$ 位于第 $b_2$个块内的第 $i_2$个元素。如果 $b_1 = b_2$，那么直接返回第 $b_1$个块位于区间 $[i_1, i_2]$ 的元素之和；否则计算第 $b_1$个块位于区间 $[i_1, \textit{size} - 1)$的元素之和 $\textit{sum}_1$，第 $b_2$ 个块位于区间 $[0, i_2]$的元素之和 $\textit{sum}_2$，第 $b_1 + 1$ 个块到第 $b_2 - 1$ 个块的元素和的总和 $\textit{sum}_3$，返回 $\textit{sum}_1 + \textit{sum}_2 + \textit{sum}_3$。

对于块大小 $\textit{size}$ 的取值，我们从各个函数的时间复杂度入手。构造函数的时间复杂度为 O(n)，$\textit{update}$ 函数的时间复杂度为 O(1)，而 $\textit{sumRange}$ 函数的时间复杂度为 $O(\textit{size} + \dfrac{n}{size})$。因为 $\textit{size} + \dfrac{n}{\textit{size}} \ge 2\sqrt n$，仅当 $\textit{size} = \sqrt n$时等号成立。因此 $\textit{size}$ 取 $\lfloor \sqrt n \rfloor$，此时 $\textit{sumRange}$ 函数的时间复杂度为 $O(\sqrt n)$。

#### 复杂度分析

- 时间复杂度：构造函数为 O(n)，$\textit{update}$ 函数为 O(1)，$\textit{sumRange}$ 函数为 $O(\sqrt n)$，其中 n 为数组 $\textit{nums}$ 的大小。对于 $\textit{sumRange}$ 函数，我们最多遍历两个块以及 $\textit{sum}$ 数组，因此时间复杂度为 $O(\sqrt n)$。
- 空间复杂度：$O(\sqrt n)$。保存$ \textit{sum}$ 数组需要 $O(\sqrt n)$ 的空间。

### 线段树

```c++
class NumArray {
private:
    vector<int> segmentTree;
    int n;

    void build(int node, int s, int e, vector<int> &nums) {
        if (s == e) {
            segmentTree[node] = nums[s];
            return;
        }
        int m = s + (e - s) / 2;
        build(node * 2 + 1, s, m, nums);
        build(node * 2 + 2, m + 1, e, nums);
        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];
    }

    void change(int index, int val, int node, int s, int e) {
        if (s == e) {
            segmentTree[node] = val;
            return;
        }
        int m = s + (e - s) / 2;
        if (index <= m) {
            change(index, val, node * 2 + 1, s, m);
        } else {
            change(index, val, node * 2 + 2, m + 1, e);
        }
        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];
    }

    int range(int left, int right, int node, int s, int e) {
        if (left == s && right == e) {
            return segmentTree[node];
        }
        int m = s + (e - s) / 2;
        if (right <= m) {
            return range(left, right, node * 2 + 1, s, m);
        } else if (left > m) {
            return range(left, right, node * 2 + 2, m + 1, e);
        } else {
            return range(left, m, node * 2 + 1, s, m) + range(m + 1, right, node * 2 + 2, m + 1, e);
        }
    }

public:
    NumArray(vector<int>& nums) : n(nums.size()), segmentTree(nums.size() * 4) {
        build(0, 0, n - 1, nums);
    }

    void update(int index, int val) {
        change(index, val, 0, 0, n - 1);
    }

    int sumRange(int left, int right) {
        return range(left, right, 0, 0, n - 1);
    }
};
```

```java
class NumArray {
    private int[] segmentTree;
    private int n;

    public NumArray(int[] nums) {
        n = nums.length;
        segmentTree = new int[nums.length * 4];
        build(0, 0, n - 1, nums);
    }

    public void update(int index, int val) {
        change(index, val, 0, 0, n - 1);
    }

    public int sumRange(int left, int right) {
        return range(left, right, 0, 0, n - 1);
    }

    private void build(int node, int s, int e, int[] nums) {
        if (s == e) {
            segmentTree[node] = nums[s];
            return;
        }
        int m = s + (e - s) / 2;
        build(node * 2 + 1, s, m, nums);
        build(node * 2 + 2, m + 1, e, nums);
        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];
    }

    private void change(int index, int val, int node, int s, int e) {
        if (s == e) {
            segmentTree[node] = val;
            return;
        }
        int m = s + (e - s) / 2;
        if (index <= m) {
            change(index, val, node * 2 + 1, s, m);
        } else {
            change(index, val, node * 2 + 2, m + 1, e);
        }
        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];
    }

    private int range(int left, int right, int node, int s, int e) {
        if (left == s && right == e) {
            return segmentTree[node];
        }
        int m = s + (e - s) / 2;
        if (right <= m) {
            return range(left, right, node * 2 + 1, s, m);
        } else if (left > m) {
            return range(left, right, node * 2 + 2, m + 1, e);
        } else {
            return range(left, m, node * 2 + 1, s, m) + range(m + 1, right, node * 2 + 2, m + 1, e);
        }
    }
}
```

```python
class NumArray:
    def __init__(self, nums: List[int]):
        n = len(nums)
        self.n = n
        self.seg = [0] * (n * 4)
        self.build(nums, 0, 0, n - 1)

    def build(self, nums: List[int], node: int, s: int, e: int):
        if s == e:
            self.seg[node] = nums[s]
            return
        m = s + (e - s) // 2
        self.build(nums, node * 2 + 1, s, m)
        self.build(nums, node * 2 + 2, m + 1, e)
        self.seg[node] = self.seg[node * 2 + 1] + self.seg[node * 2 + 2]

    def change(self, index: int, val: int, node: int, s: int, e: int):
        if s == e:
            self.seg[node] = val
            return
        m = s + (e - s) // 2
        if index <= m:
            self.change(index, val, node * 2 + 1, s, m)
        else:
            self.change(index, val, node * 2 + 2, m + 1, e)
        self.seg[node] = self.seg[node * 2 + 1] + self.seg[node * 2 + 2]

    def range(self, left: int, right: int, node: int, s: int, e: int) -> int:
        if left == s and right == e:
            return self.seg[node]
        m = s + (e - s) // 2
        if right <= m:
            return self.range(left, right, node * 2 + 1, s, m)
        if left > m:
            return self.range(left, right, node * 2 + 2, m + 1, e)
        return self.range(left, m, node * 2 + 1, s, m) + self.range(m + 1, right, node * 2 + 2, m + 1, e)

    def update(self, index: int, val: int) -> None:
        self.change(index, val, 0, 0, self.n - 1)

    def sumRange(self, left: int, right: int) -> int:
        return self.range(left, right, 0, 0, self.n - 1)
```

#### 思路与算法

线段树 $\textit{segmentTree}$ 是一个二叉树，每个结点保存数组 $\textit{nums}$ 在区间 $[s, e]$ 的最小值、最大值或者总和等信息。线段树可以用树也可以用数组（堆式存储）来实现。对于数组实现，假设根结点的下标为 0，如果一个结点在数组的下标为 $\textit{node}$，那么它的左子结点下标为 $\textit{node} \times 2 + 1$，右子结点下标为 $\textit{node} \times 2 + 2$。

- 建树 $\textit{build}$ 函数

  我们在结点 $\textit{node}$ 保存数组 $\textit{nums}$ 在区间 $[s, e]$ 的总和。

  - s = e 时，结点 $\textit{node}$ 是叶子结点，它保存的值等于 $\textit{nums}[s]$。

  - s < e 时，结点 $\textit{node}$ 的左子结点保存区间 $\Big [ s, \Big \lfloor \dfrac{s + e}{2} \Big \rfloor \Big ]$ 的总和，右子结点保存区间 $\Big [ \Big \lfloor \dfrac{s + e}{2} \Big \rfloor + 1, e \Big ]$ 的总和，那么结点 $\textit{node}$ 保存的值等于它的两个子结点保存的值之和。

- 假设 $\textit{nums}$ 的大小为 n，我们规定根结点 $\textit{node} = 0$ 保存区间 $[0, n - 1]$ 的总和，然后自下而上递归地建树。

- 单点修改 $\textit{change}$ 函数

  当我们要修改 $\textit{nums}[\textit{index}]$ 的值时，我们找到对应区间 $[\textit{index}, \textit{index}]$ 的叶子结点，直接修改叶子结点的值为 $\textit{val}$，并自下而上递归地更新父结点的值。

- 范围求和 $\textit{range}$ 函数

  给定区间 $[\textit{left}, \textit{right}]$ 时，我们将区间 $[\textit{left}, \textit{right}]$ 拆成多个结点对应的区间。

  - 如果结点 $\textit{node}$ 对应的区间与$ [\textit{left}, \textit{right}]$ 相同，可以直接返回该结点的值，即当前区间和。

  - 如果结点 $\textit{node}$ 对应的区间与 $[\textit{left}, \textit{right}]$ 不同，设左子结点对应的区间的右端点为 m，那么将区间 $[\textit{left}, \textit{right}]$ 沿点 m 拆成两个区间，分别计算左子结点和右子结点。


我们从根结点开始递归地拆分区间 $[\textit{left}, \textit{right}]$。

#### 复杂度分析

- 时间复杂度：

  - 构造函数：O(n)，其中 n 是数组 $\textit{nums}$ 的大小。二叉树的高度不超过 $\lceil \log n \rceil + 1$，那么$ \textit{segmentTree}$的大小不超过 $2 ^ {\lceil \log n \rceil + 1} - 1 \le 4n$，所以 $\textit{build}$ 的时间复杂度为 O(n)。
  - $\textit{update}$ 函数：$O(\log n)$。因为树的高度不超过 $\lceil \log n \rceil + 1$，所以涉及更新的结点数不超过 $\lceil \log n \rceil + 1$。

  - $\textit{sumRange}$ 函数：$O(\log n)$。每层结点最多访问四个，总共访问的结点数不超过 $4 \times (\lceil \log n \rceil + 1)$。

- 空间复杂度：O(n)。保存 $\textit{segmentTree}$ 需要 O(n) 的空间。


### 树状数组

```c++
class NumArray {
private:
    vector<int> tree;
    vector<int> &nums;

    int lowBit(int x) {
        return x & -x;
    }

    void add(int index, int val) {
        while (index < tree.size()) {
            tree[index] += val;
            index += lowBit(index);
        }
    }

    int prefixSum(int index) {
        int sum = 0;
        while (index > 0) {
            sum += tree[index];
            index -= lowBit(index);
        }
        return sum;
    }

public:
    NumArray(vector<int>& nums) : tree(nums.size() + 1), nums(nums) {
        for (int i = 0; i < nums.size(); i++) {
            add(i + 1, nums[i]);
        }
    }

    void update(int index, int val) {
        add(index + 1, val - nums[index]);
        nums[index] = val;
    }

    int sumRange(int left, int right) {
        return prefixSum(right + 1) - prefixSum(left);
    }
};
```

```java
class NumArray {
    private int[] tree;
    private int[] nums;

    public NumArray(int[] nums) {
        this.tree = new int[nums.length + 1];
        this.nums = nums;
        for (int i = 0; i < nums.length; i++) {
            add(i + 1, nums[i]);
        }
    }

    public void update(int index, int val) {
        add(index + 1, val - nums[index]);
        nums[index] = val;
    }

    public int sumRange(int left, int right) {
        return prefixSum(right + 1) - prefixSum(left);
    }

    private int lowBit(int x) {
        return x & -x;
    }

    private void add(int index, int val) {
        while (index < tree.length) {
            tree[index] += val;
            index += lowBit(index);
        }
    }

    private int prefixSum(int index) {
        int sum = 0;
        while (index > 0) {
            sum += tree[index];
            index -= lowBit(index);
        }
        return sum;
    }
}
```

```python
class NumArray:
    def __init__(self, nums: List[int]):
        self.nums = nums
        self.tree = [0] * (len(nums) + 1)
        for i, num in enumerate(nums, 1):
            self.add(i, num)

    def add(self, index: int, val: int):
        while index < len(self.tree):
            self.tree[index] += val
            index += index & -index

    def prefixSum(self, index) -> int:
        s = 0
        while index:
            s += self.tree[index]
            index &= index - 1
        return s

    def update(self, index: int, val: int) -> None:
        self.add(index + 1, val - self.nums[index])
        self.nums[index] = val

    def sumRange(self, left: int, right: int) -> int:
        return self.prefixSum(right + 1) - self.prefixSum(left)
```

#### 思路与算法

关于树状数组的详细介绍可以参考百度百科  树状数组 ，本文不作过多介绍。

树状数组是一种可以动态维护序列前缀和的数据结构（序列下标从 1 开始），它的功能是：

- 单点修改 $\textit{add}(\textit{index}, \textit{val})$：把序列第 $\textit{index}$ 个数增加 $\textit{val}$；

- 区间查询 $\textit{prefixSum}(\textit{index})$：查询前 $\textit{index}$ 个元素的前缀和。


因为题目要求实现更新 $\textit{nums}$ 在某个位置的值，因此我们保存原始的 $\textit{nums}$ 数组。

- 构造函数

  树状数组初始对应一个零序列，因此我们遍历 $\textit{nums}$ 数组，调用 $\textit{add}$ 函数来更新树状数组。

- $\textit{update}$ 函数

  获取 $\textit{nums}$ 在 $\textit{index}$ 的增加值， 调用 $\textit{add}$ 函数更新树状数组，并更新 $\textit{nums}[\textit{index}] = \textit{val}$。

- $\textit{sumRange}$ 函数

  区间和 $[\textit{left}, \textit{right}]$ 可以转化为两个前缀和之差，调用树状数组的 $\textit{prefixSum}$ 函数获取前 $\textit{right} + 1$ 个元素的前缀和 $\textit{sum}_1$和前 $\textit{left}$ 个元素的前缀和 $\textit{sum}_2$，返回 $\textit{sum}_1 - \textit{sum}_2$ 。

#### 复杂度分析

- 时间复杂度：

  - 构造函数：$O(n \log n)$，其中 n 是数组 $\textit{nums}$ 的大小。$\textit{add}$ 函数的时间复杂度是 $O(\log n)$，总共调用 n 次。

  - $\textit{update}$ 函数：$O(\log n)$。\textit{add}add 函数的时间复杂度是 $O(\log n)$。

  - $\textit{sumRange}$ 函数：$O(\log n)$。$\textit{prefixSum}$ 函数的时间复杂度是 $O(\log n)$。

- 空间复杂度：O(n)。保存 $\textit{tree}$ 需要 O(n) 的空间。


