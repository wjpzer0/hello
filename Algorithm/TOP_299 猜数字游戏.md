# 题目

你在和朋友一起玩 [猜数字（Bulls and Cows）](https://baike.baidu.com/item/猜数字/83200?fromtitle=Bulls+and+Cows&fromid=12003488&fr=aladdin)游戏，该游戏规则如下：

写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：

- 猜测数字中有多少位属于数字和确切位置都猜对了（称为 "Bulls", 公牛），
- 有多少位属于数字猜对了但是位置不对（称为 "Cows", 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。

给你一个秘密数字 `secret` 和朋友猜测的数字 `guess` ，请你返回对朋友这次猜测的提示。

提示的格式为 `"xAyB"` ，`x` 是公牛个数， `y` 是奶牛个数，`A` 表示公牛，`B` 表示奶牛。

请注意秘密数字和朋友猜测的数字都可能含有重复数字。

**示例 1:**

```
输入: secret = "1807", guess = "7810"
输出: "1A3B"
解释: 数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。
"1807"
  |
"7810"
```

**示例 2:**

```
输入: secret = "1123", guess = "0111"
输出: "1A1B"
解释: 数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。
"1123"        "1123"
  |      or     |
"0111"        "0111"
注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。
```

**示例 3：**

```
输入：secret = "1", guess = "0"
输出："0A0B"
```

**示例 4：**

```
输入：secret = "1", guess = "1"
输出："1A0B"
```

**提示：**

- `1 <= secret.length, guess.length <= 1000`
- `secret.length == guess.length`
- `secret` 和 `guess` 仅由数字组成

## 我的解法

思路清晰， 代码可以优化！

```python
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        n = len(secret)
        numA = 0
        numB = 0
        listS = [0] * 10
        listG = [0] * 10
        for i in range(n):
            if secret[i] == guess[i]:
                numA += 1
            else:
                listG[int(secret[i])] += 1
                listS[int(guess[i])] += 1
        
        for i in range(10):
            numB += min(listG[i], listS[i])

        return str(numA) + "A" + str(numB) + "B"    
```

## 其他解法

### 遍历

```c++
class Solution {
public:
    string getHint(string secret, string guess) {
        int bulls = 0;
        vector<int> cntS(10), cntG(10);
        for (int i = 0; i < secret.length(); ++i) {
            if (secret[i] == guess[i]) {
                ++bulls;
            } else {
                ++cntS[secret[i] - '0'];
                ++cntG[guess[i] - '0'];
            }
        }
        int cows = 0;
        for (int i = 0; i < 10; ++i) {
            cows += min(cntS[i], cntG[i]);
        }
        return to_string(bulls) + "A" + to_string(cows) + "B";
    }
};
```

```java
class Solution {
    public String getHint(String secret, String guess) {
        int bulls = 0;
        int[] cntS = new int[10];
        int[] cntG = new int[10];
        for (int i = 0; i < secret.length(); ++i) {
            if (secret.charAt(i) == guess.charAt(i)) {
                ++bulls;
            } else {
                ++cntS[secret.charAt(i) - '0'];
                ++cntG[guess.charAt(i) - '0'];
            }
        }
        int cows = 0;
        for (int i = 0; i < 10; ++i) {
            cows += Math.min(cntS[i], cntG[i]);
        }
        return Integer.toString(bulls) + "A" + Integer.toString(cows) + "B";
    }
}
```

```python
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bulls = 0
        cntS, cntG = [0] * 10, [0] * 10
        for s, g in zip(secret, guess):
            if s == g:
                bulls += 1
            else:
                cntS[int(s)] += 1
                cntG[int(g)] += 1
        cows = sum(min(s, g) for s, g in zip(cntS, cntG))
        return f'{bulls}A{cows}B'
```

根据题意，对于公牛，需要满足数字和确切位置都猜对。我们可以遍历 $\textit{secret}$ 和 $\textit{guess}$，统计满足 $\textit{secret}[i]=\textit{guess}[i]$ 的下标个数，即为公牛的个数。

对于奶牛，需要满足数字猜对但是位置不对。我们可以在 $\textit{secret}[i]\ne\textit{guess}[i]$时，分别统计 $\textit{secret}$ 和 $\textit{guess}$ 的各个字符的出现次数，记在两个长度为 10 的数组中。根据题目所述的「这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字」，由于多余的数字无法匹配，对于 $\texttt{0}$ 到 $\texttt{9}$ 的每位数字，应取其在 $\textit{secret}$ 和 $\textit{guess}$ 中的出现次数的最小值。将每位数字出现次数的最小值累加，即为奶牛的个数。

#### 复杂度分析

时间复杂度：O(N)，其中 N 是字符串 $\textit{secret}$ 的长度。

空间复杂度：O(C)。需要常数个空间统计字符出现次数，由于我们统计的是数字字符，因此 C=10。
