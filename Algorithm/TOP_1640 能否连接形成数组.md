# 题目

给你一个整数数组 `arr` ，数组中的每个整数 **互不相同** 。另有一个由整数数组构成的数组 `pieces`，其中的整数也 **互不相同** 。请你以 **任意顺序** 连接 `pieces` 中的数组以形成 `arr` 。但是，**不允许** 对每个数组 `pieces[i]` 中的整数重新排序。

如果可以连接 `pieces` 中的数组形成 `arr` ，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：arr = [15,88], pieces = [[88],[15]]
输出：true
解释：依次连接 [15] 和 [88]
```

**示例 2：**

```
输入：arr = [49,18,16], pieces = [[16,18,49]]
输出：false
解释：即便数字相符，也不能重新排列 pieces[0]
```

**示例 3：**

```
输入：arr = [91,4,64,78], pieces = [[78],[4,64],[91]]
输出：true
解释：依次连接 [91]、[4,64] 和 [78]
```

**提示：**

- `1 <= pieces.length <= arr.length <= 100`
- `sum(pieces[i].length) == arr.length`
- `1 <= pieces[i].length <= arr.length`
- `1 <= arr[i], pieces[i][j] <= 100`
- `arr` 中的整数 **互不相同**
- `pieces` 中的整数 **互不相同**（也就是说，如果将 `pieces` 扁平化成一维数组，数组中的所有整数互不相同）

## 我的解法

思路较为清晰！

```python
class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        pieceMap = {}
        for i, piece in enumerate(pieces):
            pieceMap[piece[0]] = i 

        n = len(arr)
        i = 0
        while i < n:
            if arr[i] not in pieceMap:
                return False
            else:
                for num in pieces[pieceMap[arr[i]]]:
                    if num != arr[i]:
                        return False 
                    i += 1
        return True
```

## 其它解法

### 哈希表

```c++
class Solution {
public:
    bool canFormArray(vector<int> &arr, vector<vector<int>> &pieces) {
        unordered_map<int, int> index;
        for (int i = 0; i < pieces.size(); i++) {
            index[pieces[i][0]] = i;
        }
        for (int i = 0; i < arr.size();) {
            auto it = index.find(arr[i]);
            if (it == index.end()) {
                return false;
            }
            for (int x : pieces[it->second]) {
                if (arr[i++] != x) {
                    return false;
                }
            }
        }
        return true;
    }
};
```

```java
class Solution {
    public boolean canFormArray(int[] arr, int[][] pieces) {
        int n = arr.length, m = pieces.length;
        Map<Integer, Integer> index = new HashMap<Integer, Integer>();
        for (int i = 0; i < m; i++) {
            index.put(pieces[i][0], i);
        }
        for (int i = 0; i < n;) {
            if (!index.containsKey(arr[i])) {
                return false;
            }
            int j = index.get(arr[i]), len = pieces[j].length;
            for (int k = 0; k < len; k++) {
                if (arr[i + k] != pieces[j][k]) {
                    return false;
                }
            }
            i = i + len;
        }
        return true;
    }
}
```

```python
class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        index = {p[0]: i for i, p in enumerate(pieces)}
        i = 0
        while i < len(arr):
            if arr[i] not in index:
                return False
            p = pieces[index[arr[i]]]
            if arr[i: i + len(p)] != p:
                return False
            i += len(p)
        return True
```

因为数组 $\textit{arr}$每个整数互不相同，且 $\textit{pieces}$的整数也互不相同，所以我们可以通过 $\textit{arr}$固定 $\textit{pieces}$的放置。使用哈希表 $\textit{index}$记录$ \textit{pieces}$各个数组的首元素与数组下标的对应关系。

我们不断地将 $\textit{pieces}$中的数组与数组 $\textit{arr}$相对应，对于当前遍历的元素 $\textit{arr}[i]$，如果它不存在于哈希表中，说明我们无法将$ \textit{pieces}$与数组 $\textit{arr}$相对应，直接返回 $\text{false}$；否则我们找到对应的数组 $\textit{pieces}[j]$，然后将它与 $\textit{arr}[i]$ 及之后的整数进行比较（在比较过程中，如果判断相等不成立，直接返回 $\text{false}$），判断都相等后，将 i 相应地向后移。全部 $\textit{pieces}$都匹配成功后，返回 $\text{true}$。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是数组 $\textit{arr}$的长度。

- 空间复杂度：O(n)。保存哈希表需要 O(n) 的空间。


