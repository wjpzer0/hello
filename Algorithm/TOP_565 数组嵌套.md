# 题目

索引从`0`开始长度为`N`的数组`A`，包含`0`到`N - 1`的所有整数。找到最大的集合`S`并返回其大小，其中 `S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }`且遵守以下的规则。

假设选择索引为`i`的元素`A[i]`为`S`的第一个元素，`S`的下一个元素应该是`A[A[i]]`，之后是`A[A[A[i]]]...` 以此类推，不断添加直到`S`出现重复的元素。

**示例 1:**

```
输入: A = [5,4,0,3,1,6,2]
输出: 4
解释: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
```

**提示：**

1. `N`是`[1, 20,000]`之间的整数。
2. `A`中不含有重复的元素。
3. `A`中的元素大小在`[0, N-1]`之间。

## 我的解法

用集合进行排除！

```python
class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        mark = set()
        n = len(nums)
        ans = 0
        for i in range(n):
            if i in mark:
                continue
            mid = 1
            num = nums[i]
            mark.add(i)
            while num not in mark:
                mark.add(num)
                num = nums[num]
                mid += 1
            ans = max(ans, mid)
        return ans
```

## 其他解法

### 图

```c++
class Solution {
public:
    int arrayNesting(vector<int> &nums) {
        int ans = 0, n = nums.size();
        vector<int> vis(n);
        for (int i = 0; i < n; ++i) {
            int cnt = 0;
            while (!vis[i]) {
                vis[i] = true;
                i = nums[i];
                ++cnt;
            }
            ans = max(ans, cnt);
        }
        return ans;
    }
};
```

```java
class Solution {
    public int arrayNesting(int[] nums) {
        int ans = 0, n = nums.length;
        boolean[] vis = new boolean[n];
        for (int i = 0; i < n; ++i) {
            int cnt = 0;
            while (!vis[i]) {
                vis[i] = true;
                i = nums[i];
                ++cnt;
            }
            ans = Math.max(ans, cnt);
        }
        return ans;
    }
}
```

```python
class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        ans, n = 0, len(nums)
        vis = [False] * n
        for i in range(n):
            cnt = 0
            while not vis[i]:
                vis[i] = True
                i = nums[i]
                cnt += 1
            ans = max(ans, cnt)
        return ans
```

遍历数组，从 i 向 $\textit{nums}[i]$ 连边，我们可以得到一张有向图。

由于题目保证 $\textit{nums}$中不含有重复的元素，因此有向图中每个点的出度和入度均为 1。

在这种情况下，有向图必然由一个或多个环组成。我们可以遍历 $\textit{nums}$，找到节点个数最大的环。

代码实现时需要用一个 $\textit{vis}$数组来标记访问过的节点。

#### **复杂度分析**

- 时间复杂度：O(n)，其中 n 是数组 $\textit{nums}$ 的长度。
- 空间复杂度：O(n)*O*。

### 原地标记

```c++
class Solution {
public:
    int arrayNesting(vector<int> &nums) {
        int ans = 0, n = nums.size();
        for (int i = 0; i < n; ++i) {
            int cnt = 0;
            while (nums[i] < n) {
                int num = nums[i];
                nums[i] = n;
                i = num;
                ++cnt;
            }
            ans = max(ans, cnt);
        }
        return ans;
    }
};
```

```java
class Solution {
    public int arrayNesting(int[] nums) {
        int ans = 0, n = nums.length;
        for (int i = 0; i < n; ++i) {
            int cnt = 0;
            while (nums[i] < n) {
                int num = nums[i];
                nums[i] = n;
                i = num;
                ++cnt;
            }
            ans = Math.max(ans, cnt);
        }
        return ans;
    }
}
```

```python
class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        ans, n = 0, len(nums)
        for i in range(n):
            cnt = 0
            while nums[i] < n:
                num = nums[i]
                nums[i] = n
                i = num
                cnt += 1
            ans = max(ans, cnt)
        return ans
```

利用「$\textit{nums}$中的元素大小在$ [0, n-1]$ 之间」这一条件，我们可以省略 $\textit{vis}$数组，改为标记 $\textit{nums}[i] = n$，来实现和 $\textit{vis}$数组同样的功能。

#### 复杂度分析

时间复杂度：O(n)，其中 n 是数组 $\textit{nums}$的长度。

空间复杂度：O(1)，我们只需要常数的空间保存若干变量。

