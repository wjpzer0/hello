# 题目

现有一份 `n + m` 次投掷单个 **六面** 骰子的观测数据，骰子的每个面从 `1` 到 `6` 编号。观测数据中缺失了 `n` 份，你手上只拿到剩余 `m` 次投掷的数据。幸好你有之前计算过的这 `n + m` 次投掷数据的 **平均值** 。

给你一个长度为 `m` 的整数数组 `rolls` ，其中 `rolls[i]` 是第 `i` 次观测的值。同时给你两个整数 `mean` 和 `n` 。

返回一个长度为 `n` 的数组，包含所有缺失的观测数据，且满足这 `n + m` 次投掷的 **平均值** 是 `mean` 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。

`k` 个数字的 **平均值** 为这些数字求和后再除以 `k` 。

注意 `mean` 是一个整数，所以 `n + m` 次投掷的总和需要被 `n + m` 整除。

**示例 1：**

```
输入：rolls = [3,2,4,3], mean = 4, n = 2
输出：[6,6]
解释：所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4 。
```

**示例 2：**

```
输入：rolls = [1,5,6], mean = 3, n = 4
输出：[2,3,2,2]
解释：所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3 。
```

**示例 3：**

```
输入：rolls = [1,2,3,4], mean = 6, n = 4
输出：[]
解释：无论丢失的 4 次数据是什么，平均值都不可能是 6 。
```

**示例 4：**

```
输入：rolls = [1], mean = 3, n = 1
输出：[5]
解释：所有 n + m 次投掷的平均值是 (1 + 5) / 2 = 3 。
```

**提示：**

- `m == rolls.length`
- $1 <= n, m <= 10^5$
- `1 <= rolls[i], mean <= 6`

## 我的解法

思路没问题！理解其他思路的解法！

```python
class Solution:
    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        m = len(rolls)
        allN = m + n
        allSum = allN * mean
        mSum = sum(rolls)
        diff = allSum - mSum
        print(diff)
        ans = []
        while diff > 0:
            state = diff // n 
            if state > 6 or state == 0:
                return []
            diff -= state
            n -= 1
            ans.append(state)
        return ans
```

## 其他解法

### 模拟构造

```c++
class Solution {
public:
    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {
        int m = rolls.size();
        int sum = mean * (n + m);
        int missingSum = sum;
        for (int & roll : rolls) {
            missingSum -= roll;
        }
        if (missingSum < n || missingSum > 6 * n) {
            return {};
        }
        int quotient = missingSum / n, remainder = missingSum % n;
        vector<int> missing(n);
        for (int i = 0; i < n; i++) {
            missing[i] = quotient + (i < remainder ? 1 : 0);
        }
        return missing;
    }
};
```

```java
class Solution {
    public int[] missingRolls(int[] rolls, int mean, int n) {
        int m = rolls.length;
        int sum = mean * (n + m);
        int missingSum = sum;
        for (int roll : rolls) {
            missingSum -= roll;
        }
        if (missingSum < n || missingSum > 6 * n) {
            return new int[0];
        }
        int quotient = missingSum / n, remainder = missingSum % n;
        int[] missing = new int[n];
        for (int i = 0; i < n; i++) {
            missing[i] = quotient + (i < remainder ? 1 : 0);
        }
        return missing;
    }
}
```

```python
class Solution:
    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        missingSum = mean * (n + len(rolls)) - sum(rolls)
        if not n <= missingSum <= n * 6:
            return []
        quotient, remainder = divmod(missingSum, n)
        return [quotient + 1] * remainder + [quotient] * (n - remainder)
```

根据题目描述，数组 $\textit{rolls}$ 的长度为 m，记录了 m 个观测数据，还有 n 个观测数据缺失，共有 n + m 个观测数据。由于所有观测数据的平均值为 $\textit{mean}$，因此所有观测数据之和为 $\textit{mean} \times (n + m)$。

根据所有观测数据之和与数组 $\textit{rolls}$ 中的 m 个观测数据，可知缺失的 n 个观测数据之和。将缺失的 n 个观测数据之和记为 $\textit{missingSum}$。

由于每次观测数据的范围是 1 到 6，因此如果存在符合要求的答案，则一定有 $n \le \textit{missingSum} \le 6 \times n$。如果 $\textit{missingSum}$ 不在上述范围内，则不存在符合要求的答案，返回空数组。

当 $\textit{missingSum}$ 满足 $n \le \textit{missingSum} \le 6 \times n$ 时，一定存在一种符合要求的答案，由 n 个在$ [1, 6]$ 范围内的整数组成且这 n 个整数之和为 $\textit{missingSum}$。记 $\textit{quotient} = \Big\lfloor \dfrac{\textit{missingSum}}{n} \Big\rfloor$，$\textit{remainder} = \textit{missingSum} \bmod n$，则可以构造一种符合要求的答案：在缺失的 n 个观测数据中，有 $\textit{remainder}$ 个观测数据是$ \textit{quotient} + 1$，其余观测数据都是 $\textit{quotient}$。

#### 复杂度分析

时间复杂度：O(n + m)，其中 n 是缺失的观测数据个数，m 是数组 $\textit{rolls}$ 的长度，即已知的观测数据个数。需要 O(m) 的时间计算缺失的观测数据之和，需要 O(n) 的时间构造答案。

空间复杂度：O(1)。除了返回值以外，使用的额外空间为 O(1)。

