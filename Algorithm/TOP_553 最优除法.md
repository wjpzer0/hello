# 题目

给定一组**正整数，**相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -> 2 / 3 / 4 。

但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到**最大的**结果，并且返回相应的字符串格式的表达式。**你的表达式不应该含有冗余的括号。**

**示例：**

```
输入: [1000,100,10,2]
输出: "1000/(100/10/2)"
解释:
1000/(100/10/2) = 1000/((100/10)/2) = 200
但是，以下加粗的括号 "1000/((100/10)/2)" 是冗余的，
因为他们并不影响操作的优先级，所以你需要返回 "1000/(100/10/2)"。

其他用例:
1000/(100/10)/2 = 50
1000/(100/(10/2)) = 50
1000/100/10/2 = 0.5
1000/100/(10/2) = 2
```

**说明:**

1. 输入数组的长度在 [1, 10] 之间。
2. 数组中每个元素的大小都在 [2, 1000] 之间。
3. 每个测试用例只有一个最优除法解。

## 我的解法

查看评论后写出，跟着直觉写题，虽然有部分思路，但是没有用数学思想进行论证！

```python
class Solution:
    def optimalDivision(self, nums: List[int]) -> str:
        ans = ""
        ans += str(nums[0]) + "/("
        n = len(nums)
        if n == 1:
            return str(nums[0])
        if n == 2:
            return str(nums[0]) + "/" + str(nums[1])
        for i in range(1, n):
            ans += str(nums[i]) 
            if i != n - 1:
                ans += "/"
        ans += ")"
        return ans
```

## 其他解法

### 动态规划

```c++
struct Node {
    double maxVal, minVal;
    string minStr, maxStr;
    Node() {
        this->minVal = 10000.0;
        this->maxVal = 0.0;
    }
};

class Solution {
public:
    string optimalDivision(vector<int>& nums) {
        int n = nums.size();
        vector<vector<Node>> dp(n, vector<Node>(n));

        for (int i = 0; i < n; i++) {
            dp[i][i].minVal = nums[i];
            dp[i][i].maxVal = nums[i];
            dp[i][i].minStr = to_string(nums[i]);
            dp[i][i].maxStr = to_string(nums[i]);
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j + i < n; j++) {
                for (int k = j; k < j + i; k++) {
                    if (dp[j][j + i].maxVal < dp[j][k].maxVal / dp[k + 1][j + i].minVal) {
                        dp[j][j + i].maxVal = dp[j][k].maxVal / dp[k + 1][j + i].minVal;
                        if (k + 1 == j + i) {
                            dp[j][j + i].maxStr = dp[j][k].maxStr + "/" + dp[k + 1][j + i].minStr;
                        } else {
                            dp[j][j + i].maxStr = dp[j][k].maxStr + "/(" + dp[k + 1][j + i].minStr + ")";
                        }
                    }
                    if (dp[j][j + i].minVal > dp[j][k].minVal / dp[k + 1][j + i].maxVal) {
                        dp[j][j + i].minVal = dp[j][k].minVal / dp[k + 1][j + i].maxVal;
                        if (k + 1 == j + i) {
                            dp[j][j + i].minStr = dp[j][k].minStr + "/" + dp[k + 1][j + i].maxStr; 
                        } else {
                            dp[j][j + i].minStr = dp[j][k].minStr + "/(" + dp[k + 1][j + i].maxStr + ")"; 
                        }
                    }
                }
            }
        }
        return dp[0][n - 1].maxStr;
    }
};
```

```java
class Solution {
    public String optimalDivision(int[] nums) {
        int n = nums.length;
        Node[][] dp = new Node[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                dp[i][j] = new Node();
            }
        }

        for (int i = 0; i < n; i++) {
            dp[i][i].minVal = nums[i];
            dp[i][i].maxVal = nums[i];
            dp[i][i].minStr = String.valueOf(nums[i]);
            dp[i][i].maxStr = String.valueOf(nums[i]);
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j + i < n; j++) {
                for (int k = j; k < j + i; k++) {
                    if (dp[j][j + i].maxVal < dp[j][k].maxVal / dp[k + 1][j + i].minVal) {
                        dp[j][j + i].maxVal = dp[j][k].maxVal / dp[k + 1][j + i].minVal;
                        if (k + 1 == j + i) {
                            dp[j][j + i].maxStr = dp[j][k].maxStr + "/" + dp[k + 1][j + i].minStr;
                        } else {
                            dp[j][j + i].maxStr = dp[j][k].maxStr + "/(" + dp[k + 1][j + i].minStr + ")";
                        }
                    }
                    if (dp[j][j + i].minVal > dp[j][k].minVal / dp[k + 1][j + i].maxVal) {
                        dp[j][j + i].minVal = dp[j][k].minVal / dp[k + 1][j + i].maxVal;
                        if (k + 1 == j + i) {
                            dp[j][j + i].minStr = dp[j][k].minStr + "/" + dp[k + 1][j + i].maxStr; 
                        } else {
                            dp[j][j + i].minStr = dp[j][k].minStr + "/(" + dp[k + 1][j + i].maxStr + ")"; 
                        }
                    }
                }
            }
        }
        return dp[0][n - 1].maxStr;
    }
}

class Node {
    double maxVal, minVal;
    String minStr, maxStr;

    public Node() {
        this.minVal = 10000.0;
        this.maxVal = 0.0;
    }
}
```

#### 思路

设 $\textit{dp}[i][j]$表示数组 $\textit{nums}$ 索引区间 $[i,j]$ 通过添加不同的符号从而可以获取的最小值与最大值为 $\textit{minVal}_{(i,j)}$,$\textit{maxVal}_{(i,j)}$，以及它们对应的表达式字符串为 $\textit{minStr}_{(i,j)},\textit{maxStr}_{(i,j)}$。可以通过枚举不同的索引 k 且满足 $k \in [i,j]$，从而获取区间 $[i,j]$ 最大值与最小值以及对应的字符串表达式。

- 通过枚举 k 满足 $k \in [i,j)$ 将区间 $[i,j]$ 分为 $[i,k],[k+1,j]$ 左右两部分，则区间 $[i,j]$ 的最小值可以通过左边部分的最小值除以右边部分的最大值得到，最大值可以通过左边部分的最大值除以右边部分的最小值得到。

- 通过以上推论可以知道其中区间 $[i,j]$ 最大值与最小值动态规划的递推公式如下：

- $$
  \textit{minVal}_{(i,j)} = \min(\dfrac{\textit{minVal}_{(i,k)}}{\textit{maxVal}_{(k+1,j)}}) \qquad k \in [i,j) \\ \textit{maxVal}_{(i,j)} = \min(\dfrac{\textit{maxVal}_{(i,k)}}{\textit{minVal}_{(k+1,j)}}) \qquad k \in [i,j) \\
  $$

- 枚举不同的 k 时，当找到区间 [$i,j]$ 的最小值与最大值时，还需要同时记录最大值与最小值时对应的表达式字符串 $\textit{minStr}_{(i,j)},\textit{maxStr}_{(i,j)}$。由于除法运算是从左到右的，也就是最左边的除法默认先执行，所以不需要给左边部分添加括号，但需要给右边部分添加括号。比方假设左边部分是 $\texttt{"2"}$ ，右边部分是$ \texttt{"3/4"}$，那么结果字符串 $\texttt{"2/(3/4)"}$。如果右边部分只有一个数字，题目要求返回结果不含有冗余括号，此时也不需要添加括号。假如左边部分是$ \texttt{"2"}$ 且右边部分是 $\texttt{"3"}$ （只包含单个数字），那么答案应该是$ \texttt{"2/3"}$ 而不是 $\texttt{"2/(3)"}$。

#### 复杂度分析

- 时间复杂度：$O(n^3)$，其中 n 为数组的长度。$\textit{dp}$ 数组的大小为 $n^2$，计算 $\textit{dp}$ 中的每一项元素需要 O(n) 的时间复杂度。

- 空间复杂度：$O(n^3)$，其中 n 表示数组的长度。$\textit{dp}$ 数组的长度为 $n^2$ ，其中数组中元素的长度最长为 O(n)。

### 数学

```c++
class Solution {
public:
    string optimalDivision(vector<int>& nums) {
        int n = nums.size();        
        if (n == 1) {
            return to_string(nums[0]);
        }
        if (n == 2) {
            return to_string(nums[0]) + "/" + to_string(nums[1]);
        }
        string res = to_string(nums[0]) + "/(" + to_string(nums[1]);
        for (int i = 2; i < n; i++) {
            res.append("/" + to_string(nums[i]));
        }
        res.append(")");
        return res;
    }
};
```

```java
class Solution {
    public String optimalDivision(int[] nums) {
        int n = nums.length;        
        if (n == 1) {
            return String.valueOf(nums[0]);
        }
        if (n == 2) {
            return String.valueOf(nums[0]) + "/" + String.valueOf(nums[1]);
        }
        StringBuffer res = new StringBuffer();
        res.append(nums[0]);
        res.append("/(");
        res.append(nums[1]);
        for (int i = 2; i < n; i++) {
            res.append("/");
            res.append(nums[i]);
        }
        res.append(")");
        return res.toString();
    }
}
```

```python
class Solution:
    def optimalDivision(self, nums: List[int]) -> str:
        if len(nums) == 1:
            return str(nums[0])
        if len(nums) == 2:
            return str(nums[0]) + "/" + str(nums[1])
        return str(nums[0]) + "/(" + "/".join(map(str, nums[1:])) + ")"
```

#### 思路

使用一些简单的数学技巧，我们可以找到解决这个问题的简单解法。考虑到除法运算用分数 $\dfrac{x}{y}$ 来表示，其中分子 x 为被除数，分母 y 为除数，为了最大化 $\dfrac{x}{y} $，应该使分子 x 尽可能的大，分母 y 尽可能的小。

- 假设当前的整数序列为 $[\textit{nums}_0, \textit{nums}_1, \cdots , \textit{nums}_{n-1}]$，相邻元素相除形式为 $[\textit{nums}_0 \div \textit{nums}_1 \div \cdots \div \textit{nums}_{n-1}]$，最终的结果一定可以表达为分数的形式 $\dfrac{x}{y} $ ，不论如何添加括号改变优先级可以知道分子 x 的最大值为 $\textit{nums}_0$。通过添加括号使得剩余的表达式 $\textit{nums}_1 \div \textit{nums}_2 \div \cdots \div \textit{nums}_{n-1}$构成的分子 y 最小即可。由于数组 $\textit{nums}$ 中的每个元素都大于 1，因此通过直观的观察可以知道 $y = \textit{nums}_1 \div \textit{nums}_2 \div \cdots \div \textit{nums}_{n-1}$时值最小，由上述结论可以知道当满足$ \dfrac{x}{y} = \dfrac{\textit{nums}_0}{\textit{nums}_1 \div \textit{nums}_2 \div \cdots \div \textit{nums}_{n-1}} $时，数组构成的表达式计算结果为最大。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为数组的长度。只需要遍历一遍数组即可，所以时间复杂度为 O(n)。

- 空间复杂度：O(1)。除函数返回值以外，不需要额外的存储空间。


