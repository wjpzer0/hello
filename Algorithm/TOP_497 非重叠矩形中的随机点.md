# 题目

给定一个由非重叠的轴对齐矩形的数组 `rects` ，其中 `rects[i] = [ai, bi, xi, yi]` 表示 `(ai, bi)` 是第 `i` 个矩形的左下角点，`(xi, yi)` 是第 `i` 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。

在给定的矩形覆盖的空间内的任何整数点都有可能被返回。

**请注意** ，整数点是具有整数坐标的点。

实现 `Solution` 类:

- `Solution(int[][] rects)` 用给定的矩形数组 `rects` 初始化对象。
- `int[] pick()` 返回一个随机的整数点 `[u, v]` 在给定的矩形所覆盖的空间内。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/07/24/lc-pickrandomrec.jpg)

```
输入: 
["Solution", "pick", "pick", "pick", "pick", "pick"]
[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]
输出: 
[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]

解释：
Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);
solution.pick(); // 返回 [1, -2]
solution.pick(); // 返回 [1, -1]
solution.pick(); // 返回 [-1, -2]
solution.pick(); // 返回 [-2, -2]
solution.pick(); // 返回 [0, 0]
```

**提示：**

- `1 <= rects.length <= 100`
- `rects[i].length == 4`
- $-10^9 <= ai < xi <= 10^9$
- $-10^9 <= bi < yi <= 10^9$
- `xi - ai <= 2000`
- `yi - bi <= 2000`
- 所有的矩形不重叠。
- `pick` 最多被调用 `104` 次。

## 我的解法

查看大佬的提示后写出！

1. 先随机选一个矩形，再随机在选择的矩形内选一个点（用例无法完全通过）
2. 直接先计算出所有的点，然后随机返回（超时。。。）

方法1用例无法完全通过原因在于没能满足题目中条件“满足要求的点必须等概率被返回”，先等概率随机选一个矩形，再等概率随机在选择的矩形内选一个点就导致每个点并不是等概率返回，这样做的话含点越少的矩形中的点返回概率越大。方法2是太慢了。。。

知道了方法1的问题后顿悟，直接在 矩形采样时进行权重采样（含点数作为权重），再等概率随机在选择的矩形内选一个点即满足题目要求。

```python
class Solution:

    def __init__(self, rects: List[List[int]]):
        self.scope = []
        self.weight = []
        for rect in rects:
            xScope = [rect[0], rect[2]]
            yScope = [rect[1], rect[3]]
            line = rect[2] - rect[0] + 1
            row = rect[3] - rect[1] + 1
            self.weight.append(line * row)
            self.scope.append([xScope, yScope])

    def pick(self) -> List[int]:
        choiceScope = random.choices(self.scope, self.weight)[0]
        xScope = choiceScope[0]
        yScope = choiceScope[1]
        x = random.randint(xScope[0], xScope[1])
        y = random.randint(yScope[0], yScope[1])
        return [x, y]

# Your Solution object will be instantiated and called as such:
# obj = Solution(rects)
# param_1 = obj.pick()
```

## 其他解法

### 前缀和 + 二分查找

```c++
class Solution {
public:
    Solution(vector<vector<int>>& rects) : rects{rects} {
        this->arr.emplace_back(0);
        for (auto & rect : rects) {
            this->arr.emplace_back(arr.back() + (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1));
        }
    }
    
    vector<int> pick() {
        uniform_int_distribution<int> dis(0, arr.back() - 1);
        int k = dis(gen) % arr.back();
        int rectIndex = upper_bound(arr.begin(), arr.end(), k) - arr.begin() - 1;
        k = k - arr[rectIndex];
        int a = rects[rectIndex][0], b = rects[rectIndex][1];
        int y = rects[rectIndex][3];
        int col = y - b + 1;
        int da = k / col;
        int db = k - col * da;
        return {a + da, b + db};
    }    
private:
    vector<int> arr;
    vector<vector<int>>& rects;
    mt19937 gen{random_device{}()};
};
```

```java
class Solution {
    Random rand;
    List<Integer> arr;
    int[][] rects;

    public Solution(int[][] rects) {
        rand = new Random();
        arr = new ArrayList<Integer>();
        arr.add(0);
        this.rects = rects;
        for (int[] rect : rects) {
            int a = rect[0], b = rect[1], x = rect[2], y = rect[3];
            arr.add(arr.get(arr.size() - 1) + (x - a + 1) * (y - b + 1));
        }
    }

    public int[] pick() {
        int k = rand.nextInt(arr.get(arr.size() - 1));
        int rectIndex = binarySearch(arr, k + 1) - 1;
        k -= arr.get(rectIndex);
        int[] rect = rects[rectIndex];
        int a = rect[0], b = rect[1], y = rect[3];
        int col = y - b + 1;
        int da = k / col;
        int db = k - col * da;
        return new int[]{a + da, b + db};
    }

    private int binarySearch(List<Integer> arr, int target) {
        int low = 0, high = arr.size() - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            int num = arr.get(mid);
            if (num == target) {
                return mid;
            } else if (num > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
}
```

```python
class Solution:
    def __init__(self, rects: List[List[int]]):
        self.rects = rects
        self.sum = [0]
        for a, b, x, y in rects:
            self.sum.append(self.sum[-1] + (x - a + 1) * (y - b + 1))

    def pick(self) -> List[int]:
        k = randrange(self.sum[-1])
        rectIndex = bisect_right(self.sum, k) - 1
        a, b, _, y = self.rects[rectIndex]
        da, db = divmod(k - self.sum[rectIndex], y - b + 1)
        return [a + da, b + db]
```

#### 思路

记 $\textit{rects}$的长度为 n。矩形 $\textit{rects}[i]$ 的左下角点为 $(a_i, b_i)$, 右上角点为 $(x_i, y_i)$，则它覆盖的整数点有 $s_i = (x_i-a_i+1)\times(y_i-b_i+1)$ 个。数组 $\textit{rects}$表示的 n 个矩形一共覆盖 $S = \sum\limits_{i=0}^{n-1}$个整数点。我们将这些整数点进行编号为 0 至 S-1。其中 $\textit{rects}[0]$ 覆盖的点编号为 0 至 $s_0-1$，$\textit{rects}[1]$ 覆盖的整数点为接下去 $s_1$个，编号为 $s_0$至 $s_0+s_1-1$，依此类推。在同一个矩形中，整数点一共有 $(y_i-b_i+1)$ 行，$(x_i-a_i+1)$ 列。在同一个矩形中的编号，左下角为 0，并在同一行中，随着横坐标的增加，编号增加，右下角点 $(x_i, b_i)$在这个矩形中的编号为 $(x_i-a_i)$。接着逐行向上进行编号。

编号完成后，可以进行随机取点。在所有编号内等概率随机取整数 k，先确定它位于哪个矩形中，然后再确定它在矩形中的位置。确定矩形编号时，可以采用预处理前缀和和二分搜索的方式。前缀和可以记录某个矩形覆盖的整数点的编号范围。因为不同矩形覆盖的整数点编号是单调的，利用二分搜索根据整数点编号快速确定矩形编号。确定矩形编号后，原整数点编号可以转换为矩形内整数点编号，然后定位具体的点的坐标。

#### 复杂度分析

- 时间复杂度：构造函数复杂度为 O(n)，$\textit{pick}$函数复杂度为 $O(\log n)$，其中 n 为 $\textit{rects}$的长度。构造函数需要构造前缀和数组，$\textit{pick}$函数需要在前缀和数组内进行二分。

- 空间复杂度：构造函数复杂度为 O(n)，$\textit{pick}$函数复杂度为 O(1)，其中 n 为 $\textit{rects}$的长度。构造函数需要构造前缀和数组，$\textit{pick}$函数只需要使用常数空间。


