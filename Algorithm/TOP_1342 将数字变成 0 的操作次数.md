# 题目

给你一个非负整数 `num` ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。

**示例 1：**

```
输入：num = 14
输出：6
解释：
步骤 1) 14 是偶数，除以 2 得到 7 。
步骤 2） 7 是奇数，减 1 得到 6 。
步骤 3） 6 是偶数，除以 2 得到 3 。
步骤 4） 3 是奇数，减 1 得到 2 。
步骤 5） 2 是偶数，除以 2 得到 1 。
步骤 6） 1 是奇数，减 1 得到 0 。
```

**示例 2：**

```
输入：num = 8
输出：4
解释：
步骤 1） 8 是偶数，除以 2 得到 4 。
步骤 2） 4 是偶数，除以 2 得到 2 。
步骤 3） 2 是偶数，除以 2 得到 1 。
步骤 4） 1 是奇数，减 1 得到 0 。
```

**示例 3：**

```
输入：num = 123
输出：12
```

**提示：**

- $0 <= num <= 10^6$

## 我的解法

感觉有数学解法，但是想不出来！

```c++
class Solution {
public:
    int numberOfSteps(int num) {
        int ans = 0;
        while (num != 0)
        {
            if (num & 1 == 1)
            {
                num -= 1;
            }
            else
            {
                num >>= 1;
            }
            ans += 1;
        }
        return ans;
    }
};
```

```python
class Solution:
    def numberOfSteps(self, num: int) -> int:
        ans = 0
        while num != 0:
            if num % 2 == 0:
                num = num // 2
            else:
                num = num - 1
            ans += 1
        return ans
```

### 数学是思路大佬解析！

目的是使得最终结果的二进制表示均为 0，两种操作对二进制数的影响分别为「整体右移」和「消减最低位的 1」。

因此整个模拟过程其实是：如果当前的 num 最低位不为 1（偶数），则不断进行右移，直到最低位为 1（奇数），然后再对最低位的 1 进行消减，直到二进制表示中的所有 1 均被消减完（结果为 0），模拟过程结束。

换句话说，总的操作次数为 = 右移次数 + 消减次数 ：

- 右移次数：num 中最高位 1 的所在的位置；
- 消减次数：num 中 1 的个数。

## 其他解法

### 模拟

```c++
class Solution {
public:
    int numberOfSteps(int num) {
        int ret = 0;
        while (num) {
            ret += (num > 1 ? 1 : 0) + (num & 0x01);
            num >>= 1;
        }
        return ret;
    }
};
```

```java
class Solution {
    public int numberOfSteps(int num) {
        int ret = 0;
        while (num > 0) {
            ret += (num > 1 ? 1 : 0) + (num & 0x01);
            num >>= 1;
        }
        return ret;
    }
}
```

```python
class Solution:
    def numberOfSteps(self, num: int) -> int:
        ans = 0
        while num:
            ans += num & 1
            if num > 1:
                ans += 1
            num >>= 1
        return ans
```

#### 思路与算法

将 $\textit{num}$ 与 1 进行位运算来判断$ \textit{num}$ 的奇偶性。

记录操作次数时：

如果 $\textit{num}$ 是奇数，我们需要加上一次减 1 的操作。

如果 $\textit{num} > 1$，我们需要加上一次除以 2 的操作。

然后使 $\textit{num}$ 的值变成 $\Big\lfloor\dfrac{\textit{num}}{2}\Big\rfloor$。重复以上操作直到 $\textit{num} = 0$ 时结束操作。

#### 复杂度分析

- 时间复杂度：$O(\log \textit{num})$，其中 $\textit{num}$ 是输入数值。每次循环都将 num 的数值减半，因此时间复杂度为 $O(\log \textit{num})$。

- 空间复杂度：O(1)。只需要常数空间。


### 直接计算

```c++
class Solution {
public:
    int length(uint num) {
        uint clz = 0;
        if ((num >> 16) == 0) {
            clz += 16;
            num <<= 16;
        }
        if ((num >> 24) == 0) {
            clz += 8;
            num <<= 8;
        }
        if ((num >> 28) == 0) {
            clz += 4;
            num <<= 4;
        }
        if ((num >> 30) == 0) {
            clz += 2;
            num <<= 2;
        }
        if ((num >> 31) == 0) {
            clz += 1;
        }
        return 32 - clz;
    }

    int count(int num) {
        num = (num & 0x55555555) + ((num >> 1) & 0x55555555);
        num = (num & 0x33333333) + ((num >> 2) & 0x33333333);
        num = (num & 0x0F0F0F0F) + ((num >> 4) & 0x0F0F0F0F);
        num = (num & 0x00FF00FF) + ((num >> 8) & 0x00FF00FF);
        num = (num & 0x0000FFFF) + ((num >> 16) & 0x0000FFFF);
        return num;
    }

    int numberOfSteps(int num) {
        return num == 0 ? 0 : length(num) - 1 + count(num);
    }
};
```

```java
class Solution {
    public int numberOfSteps(int num) {
        return num == 0 ? 0 : length(num) - 1 + count(num);
    }

    public int length(int num) {
        int clz = 0;
        if ((num >> 16) == 0) {
            clz += 16;
            num <<= 16;
        }
        if ((num >> 24) == 0) {
            clz += 8;
            num <<= 8;
        }
        if ((num >> 28) == 0) {
            clz += 4;
            num <<= 4;
        }
        if ((num >> 30) == 0) {
            clz += 2;
            num <<= 2;
        }
        if ((num >> 31) == 0) {
            clz += 1;
        }
        return 32 - clz;
    }

    public int count(int num) { 
        num = (num & 0x55555555) + ((num >> 1) & 0x55555555);
        num = (num & 0x33333333) + ((num >> 2) & 0x33333333);
        num = (num & 0x0F0F0F0F) + ((num >> 4) & 0x0F0F0F0F);
        num = (num & 0x00FF00FF) + ((num >> 8) & 0x00FF00FF);
        num = (num & 0x0000FFFF) + ((num >> 16) & 0x0000FFFF);
        return num;
    }
}
```

```python
def length(num: int) -> int:
    clz = 0
    if (num >> 16) == 0:
        clz += 16
        num <<= 16
    if (num >> 24) == 0:
        clz += 8
        num <<= 8
    if (num >> 28) == 0:
        clz += 4
        num <<= 4
    if (num >> 30) == 0:
        clz += 2
        num <<= 2
    if (num >> 31) == 0:
        clz += 1
    return 32 - clz

def count(num: int) -> int:
    num = (num & 0x55555555) + ((num >> 1) & 0x55555555)
    num = (num & 0x33333333) + ((num >> 2) & 0x33333333)
    num = (num & 0x0F0F0F0F) + ((num >> 4) & 0x0F0F0F0F)
    num = (num & 0x00FF00FF) + ((num >> 8) & 0x00FF00FF)
    num = (num & 0x0000FFFF) + ((num >> 16) & 0x0000FFFF)
    return num

class Solution:
    def numberOfSteps(self, num: int) -> int:
        return length(num) - 1 + count(num) if num else 0
```

#### 思路与算法

由方法一的步骤可知，当 $\textit{num} > 0$ 时，总操作次数等于总减 1 的操作数与总除以 2 的操作数之和。总减 1 的操作数等于$ \textit{num}$ 二进制位 1 的个数，总除以 2 的操作数等于 $\textit{num}$ 二进制数长度减 1，即最高位右移到最低位的距离。

二进制数长度 $\textit{len}$ 可以通过前导零数目 $\textit{clz}$ 间接求解，即 $\textit{len} = W - clz$，其中$ W = 32$ 是 $\texttt{int}$t 类型的位数。

C++ 等语言可以用 `__builtin_clz` 和 `__builtin_popcount` 这类函数来求出二进制前导零数目和二进制位 1 的个数，下面介绍其原理及实现。

使用二分法加速求解前导零数目，算法如下：

> 首先判断 $\textit{num}$ 前半部分是否全为零，如果是，则将 $\textit{clz}$ 加上前半部分的长度，然后将后半部分作为处理对象，否则将前半部分作为处理对象。重复以上操作直到处理的对象长度为 1，直接判断是否有零，有则将 $\textit{clz}$ 加 1。
>

使用分治法来加速求解二进制数位 1 的个数，算法如下：

> 对二进制数 $\textit{num}$，它的位 1 的个数等于所有位的值相加的结果，比如 $10110101_{(2)} = 1 + 0 + 1 + 1 + 0 + 1 + 0 + 1$。我们可以将 88 个位的求和分解成 44 个相邻的位的求和，然后将 44 个中间结果分解成 22 个相邻的求和，即 $10110101_{(2)} = (1 + 0) + (1 + 1) + (0 + 1) + (0 + 1) = ((1 + 0) + (1 + 1)) + ((0 + 1) + (0 + 1)) = 5$。32 位数的求解过程同理。
>

#### 复杂度分析

- 时间复杂度：$O(\log W)$，其中 $W = 32$是 $\texttt{int}$ 类型的位数。计算二进制长度算法的时间复杂度为 $O(\log W)$；统计二进制数位 1 的个数算法的时间复杂度为 $O(\log W)$。

- 空间复杂度：O(1)。只需要常数空间。


