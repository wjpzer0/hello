# 题目

给你一个 `m x n` 的二元矩阵 `matrix` ，且所有值被初始化为 `0` 。请你设计一个算法，随机选取一个满足 `matrix[i][j] == 0` 的下标 `(i, j)` ，并将它的值变为 `1` 。所有满足 `matrix[i][j] == 0` 的下标 `(i, j)` 被选取的概率应当均等。

尽量最少调用内置的随机函数，并且优化时间和空间复杂度。

实现 `Solution` 类：

- `Solution(int m, int n)` 使用二元矩阵的大小 `m` 和 `n` 初始化该对象
- `int[] flip()` 返回一个满足 `matrix[i][j] == 0` 的随机下标 `[i, j]` ，并将其对应格子中的值变为 `1`
- `void reset()` 将矩阵中所有的值重置为 `0`

**示例：**

```
输入
["Solution", "flip", "flip", "flip", "reset", "flip"]
[[3, 1], [], [], [], [], []]
输出
[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]

解释
Solution solution = new Solution(3, 1);
solution.flip();  // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
solution.flip();  // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同
solution.flip();  // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]
solution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回
solution.flip();  // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
```

**提示：**

- $1 <= m, n <= 10^4$
- 每次调用`flip` 时，矩阵中至少存在一个值为 0 的格子。
- 最多调用 `1000` 次 `flip` 和 `reset` 方法。

## 我的解法

未解出！查看题解也有点没有理解！废物一个！

### 题目分析

由于题目中给出的 m 和 n 最大能达到 10000，因此我们在维护这个矩阵时，要注意以下两点：

我们不能使用 $O(m \times n)$ 的空间复杂度来维护这个矩阵，这样会超出空间限制。我们应当找到空间复杂度较低的数据结构来表示这个矩阵；
我们需要尽量少的调用语言内置的 $\texttt{random}()$ 函数来产生随机数，保证每次 $\texttt{flip}()$ 操作的时间复杂度尽可能低。

## 其他解法

### 数组映射

```c++
class Solution {
public:
    Solution(int m, int n) {
        this->m = m;
        this->n = n;
        this->total = m * n;
        srand(time(nullptr));
    }
    
    vector<int> flip() {
        int x = rand() % total;
        vector<int> ans;
        total--;   
        // 查找位置 x 对应的映射
        if (map.count(x)) {
            ans = {map[x] / n, map[x] % n};
        } else {
            ans = {x / n, x % n};
        }
        // 将位置 x 对应的映射设置为位置 total 对应的映射
        if (map.count(total)) {
            map[x] = map[total];
        } else {
            map[x] = total;
        }
        return ans;
    }
    
    void reset() {
        total = m * n;
        map.clear();
    }
private:
    int m;
    int n;
    int total;
    unordered_map<int, int> map;
};
```

```java
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    int m, n, total;
    Random rand = new Random();

    public Solution(int m, int n) {
        this.m = m;
        this.n = n;
        this.total = m * n;
    }
    
    public int[] flip() {
        int x = rand.nextInt(total);
        total--;
        // 查找位置 x 对应的映射
        int idx = map.getOrDefault(x, x);
        // 将位置 x 对应的映射设置为位置 total 对应的映射
        map.put(x, map.getOrDefault(total, total));
        return new int[]{idx / n, idx % n};
    }
    
    public void reset() {
        total = m * n;
        map.clear();
    }
}
```

```python
class Solution:

    def __init__(self, m: int, n: int):
        self.m = m
        self.n = n
        self.total = m * n
        self.map = {}

    def flip(self) -> List[int]:
        x = random.randint(0, self.total - 1)
        self.total -= 1
        # 查找位置 x 对应的映射
        idx = self.map.get(x, x)
        # 将位置 x 对应的映射设置为位置 total 对应的映射
        self.map[x] = self.map.get(self.total, self.total)
        return [idx // self.n, idx % self.n]
        
    def reset(self) -> None:
        self.total = self.m * self.n
        self.map.clear()
```

#### 解题思路

我们可以考虑将矩阵转换为一个长度为 $m \times n$ 的一维数组 $\textit{map}$，对于矩阵中的位置 $(i, j)$，它对应了 $\textit{map}$ 中的元素 $\textit{map}[i * n + j]$，这样就保证了矩阵和 $map$ 的元素映射。在经过 $m \times n-k$ 次翻转 $\texttt{flip}$ 后，我们会修改 $\textit{map}$ 与矩阵的映射，使得当前矩阵中有$m \times n-k$ 个 1 和 k 个 0。
此时我们可以利用数组中元素的交换，使得$ \textit{map}[0 \cdots k - 1]$ 映射到矩阵中的 0，而 $\textit{map}[k \cdots m \times n - 1]$ 映射到矩阵中的 1。这样的好处是，当我们进行下一次翻转操作时，我们只需要在 $[0, k-1)$ 这个区间生成随机数 x，并将 $\textit{map}[x]$ 映射到的矩阵的位置进行翻转即可。

在将 $\textit{map}[x]$ 进行翻转后，此时矩阵中有 $k - 1$ 个 0，所以我们需要保证 $\textit{map}[0 .. k - 2]$ 都映射到矩阵中的 0。由于此时 $\textit{map}[x]$映射到了矩阵中的 1，因此我们可以将 $\textit{map}[x]$ 与 $\textit{map}[k - 1]$ 的值进行交换，即将这个新翻转的 1 作为 $\textit{map}[k - 1]$ 的映射，而把原本 $\textit{map}[k - 1]$ 映射到的 0 交给 x。这样我们就保证了在每一次翻转操作后，$\textit{map}$ 中的前 k 个元素恰好映射到矩阵中的所有 k 个 0。

那么我们如何维护这个一维数组 $\textit{map}$ 呢？我们可以发现，$\textit{map}$ 中的大部分映射关系是不会改变的，即矩阵中的 $(i, j)$ 映射到 $A[i * n + j]$，因此我们可以使用一个 $\texttt{HashMap}$ 存储那些 $\textit{map}$ 中那些被修改了的映射。对于一个数 x，如果 x 不是 $\texttt{HashMap}$ 中的一个键，那么它直接映射到最开始的$ (x/n, x \%n)$；如果 x 是 $\texttt{HashMap}$ 中的一个键，那么它映射到其在 $\texttt{HashMap}$ 中对应的值。实际运行中 $\texttt{HashMap}$ 的大小仅和翻转次数成正比，因为每一次翻转操作我们会交换 $\textit{map}$ 中两个元素的映射，即最多有两个元素的映射关系被修改。

#### 复杂度分析

- 时间复杂度：$\texttt{flip}()$ 操作的时间复杂度为 O(1)，$\texttt{reset}()$ 操作的时间复杂度为 O(F)，其中 F 是在上一次 $\texttt{reset}()$ 之后执行 $\texttt{flip}()$ 的次数。

- 空间复杂度：O(F)，其中 F 代表执行函数 $\texttt{flip}()$ 的次数。


### 分块

```c++
class Solution {
public:
    Solution(int m, int n) {
        this->m = m;
        this->n = n;
        total = m * n;
        bucketSize = sqrt(m * n);
        for (int i = 0; i < total; i += bucketSize) {
            buckets.push_back({});
        }
        srand(time(nullptr));
    }

    vector<int> flip() {
        int x = rand() % total;
        int sumZero = 0;
        int curr = 0;
        total--;

        for (auto & bucket : buckets) {
            if (sumZero + bucketSize - bucket.size() > x) {
                for (int i = 0; i < bucketSize; ++i) {
                    if (!bucket.count(curr + i)) {
                        if (sumZero == x) {
                            bucket.emplace(curr + i);
                            return {(curr + i) / n, (curr + i) % n};
                        } 
                        sumZero++;
                    }
                }
            }
            curr += bucketSize;
            sumZero += bucketSize - bucket.size();
        }
        
        return {};
    }

    void reset() {
        for (auto & bucket : buckets) {
            bucket.clear();
        }
        total = m * n;
    }
private:
    int m;
    int n;
    int bucketSize;
    int total;
    vector<unordered_set<int>> buckets;
};
```

```java
class Solution {
    int m, n;
    int total, bucketSize;
    List<Set<Integer>> buckets = new ArrayList<>();
    Random rand = new Random();

    public Solution(int m, int n) {
        this.m = m;
        this.n = n;
        this.total = m * n;
        this.bucketSize = (int) Math.sqrt(total);
        for (int i = 0; i < total; i += bucketSize) {
            buckets.add(new HashSet<Integer>());
        }
    }
    
    public int[] flip() {
        int x = rand.nextInt(total);
        int sumZero = 0;
        int curr = 0;
        total--;

        for (Set<Integer> bucket : buckets) {
            if (sumZero + bucketSize - bucket.size() > x) {
                for (int i = 0; i < bucketSize; ++i) {
                    if (!bucket.contains(curr + i)) {
                        if (sumZero == x) {
                            bucket.add(curr + i);
                            return new int[]{(curr + i) / n, (curr + i) % n};
                        } 
                        sumZero++;
                    }
                }
            }
            curr += bucketSize;
            sumZero += bucketSize - bucket.size();
        }

        return null;
    }
    
    public void reset() {
        total = m * n;
        for (Set<Integer> bucket : buckets) {
            bucket.clear();
        }
    }
}
```

```python
class Solution:
    def __init__(self, m: int, n: int):
        self.m, self.n = m, n
        self.total = m * n
        self.bucketSize = math.floor(math.sqrt(m * n))
        self.buckets = [set() for _ in range(0, self.total, self.bucketSize)]

    def flip(self) -> List[int]:
        x = random.randint(0, self.total - 1)
        self.total -= 1
        sumZero = 0
        curr = 0

        for i in range(len(self.buckets)):
            if sumZero + self.bucketSize - len(self.buckets[i]) > x:
                for j in range(self.bucketSize):
                    if (curr + j) not in self.buckets[i]:
                        if sumZero == x:
                            self.buckets[i].add(curr + j)
                            return [(curr + j) // self.n, (curr + j) % self.n]
                        sumZero += 1
            curr += self.bucketSize
            sumZero += self.bucketSize - len(self.buckets[i])
        return []
        
    def reset(self) -> None:
        self.total = self.m * self.n
        for i in range(len(self.buckets)):
            self.buckets[i].clear()
```

#### 解题思路

我们可以考虑另一种方法来维护这个一维数组 $\textit{map}$。假设我们把这 $m \times n$ 个位置放到 k 个桶中，第一个桶对应 $map[0 \cdots a_{1}]$，第二个桶对应 $\textit{map}[a_{1} + 1 \cdots a_{2}]$，以此类推。我们用 $\textit{cnt}[i]$ 表示第 i 个桶中还剩余的 0 的个数，并给每个桶分配一个集合 $\texttt{HashSet}$ 存放桶中哪些位置对应的是 1（即被翻转过的位置）。

假设当前矩阵中还有 $\textit{total}$ 个 0，我们从 $[1, \textit{total}]$ 中随机出一个整数 x，并遍历所有的桶，根据所有的 $\textit{cnt}[i]$ 可以找出第 x 个 0 属于哪个桶。假设其属于第 i 个桶，那么 x 应该满足 $\textit{sum}[i - 1] < x <= \textit{sum}[i]$，其中 $\textit{sum}[i]$ 表示前 i 个桶的 $\textit{cnt}[i]$ 之和，即前 i 个桶中 0 的个数。随后我们令 $y = x - \textit{sum}[i - 1]$，即我们需要找到第 i 个桶中的第 y 个 0。我们可以依次遍历 $[d \times i + 1 \cdots d \times (i+1)]$ 中的数，根据第 i 个桶对应的集合，找出第 y 个 0 的位置。最后我们将这个 0 进行翻转。

由于 $\textit{map}$ 被分成了 k 个桶，因此每个桶的平均长度为 $\lfloor \frac{m \times n}{k} \rfloor$。在上述的方法中，遍历所有的桶的时间复杂度为 O(k)，而遍历第 i 个桶的时间复杂度为 $O(\frac{m \times n}{k})$，因此总时间复杂度为 $O(k + \frac{m \times n}{k})$。根据均值不等式，可以得知在 $k = \sqrt{m \times n}$，总的时间复杂度最小。

#### 复杂度分析

- 时间复杂度：$\texttt{flip}()$ 操作的时间复杂度为 $O(\sqrt{m \times n})$，其中 m 和 n 分别为矩阵的行数和列数；$\texttt{reset}()$ 操作的时间复杂度为 O(F)，其中 FF 是在上一次 $\texttt{reset}()$ 之后执行 $\texttt{flip}()$ 的次数。

- 空间复杂度：$O(\sqrt{m \times n} + F)$，其中 m 和 n 分别为矩阵的行数和列数，F 是执行 $\texttt{flip}()$ 的次数。


