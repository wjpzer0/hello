# 题目

给定一个字符串 `s` 和一个整数 `k` 。你可以从 `s` 的前 `k` 个字母中选择一个，并把它加到字符串的末尾。

返回 *在应用上述步骤的任意数量的移动后，字典上最小的字符串* 。

**示例 1：**

```
输入：s = "cba", k = 1
输出："acb"
解释：
在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。
在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。
```

**示例 2：**

```
输入：s = "baaca", k = 3
输出："aaabc"
解释：
在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。
在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。
```

**提示：**

- `1 <= k <= S.length <= 1000`
- `s` 只由小写字母组成。

## 我的解法

想到了如果k > 1的话必然能改动成为升序字符串！但是不知道如何证明！

```python
class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        if k > 1:
            slist = list(s)
            slist.sort()
            return "".join(slist)
        else:
            ans = s
            for i in range(len(s)):
                mid = s[i:] + s[:i]
                if mid < ans:
                    ans = mid 
            return ans
```

### 大佬的解题思路

- 首先考虑当 k = 1 的情况：我们只能将字符串第一个元素放到字符串最后，也就是轮转整个字符串，取字典序最小即可；
- 当 k = 2 时：
  - 我们将字符串第一个位置 s[0] 拎出来;
  - 剩下的所有位置看作一个轮盘，通过不断将字符串第二个位置 s[1] 放到字符串末尾，即可实现将轮盘转动起来；
  - 那么可以在适当的时候将 s[0] 插入轮盘，也可以在适当的时候将 s[1] 拎出来放到位置 s[0] 处，通过这么考虑我们即可实现对 s 字符串的排序。![899.有序队列.jpg](https://pic.leetcode-cn.com/1659494149-uaYvJj-899.%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97.jpg)
  - 当 k > 2 时同样可以看作 k = 2 的情况实现对字符串 s 的排序。

**核心思想**
当 k > 1 时将 [1, n - 1] 看作一个轮转转盘，s[0] 可以和轮盘上任意一个元素进行位置交换。

## 其他解法

### 分情况讨论

```c++
class Solution {
public:
    string orderlyQueue(string s, int k) {
        if (k == 1) {
            string smallest = s;
            int n = s.size();
            for (int i = 1; i < n; i++) {
                char c = s[0];
                s = s.substr(1);
                s.push_back(c);
                if (s < smallest) {
                    smallest = s;
                }
            }
            return smallest;
        } else {
            sort(s.begin(), s.end());
            return s;
        }
    }
};
```

```java
class Solution {
    public String orderlyQueue(String s, int k) {
        if (k == 1) {
            String smallest = s;
            StringBuilder sb = new StringBuilder(s);
            int n = s.length();
            for (int i = 1; i < n; i++) {
                char c = sb.charAt(0);
                sb.deleteCharAt(0);
                sb.append(c);
                if (sb.toString().compareTo(smallest) < 0) {
                    smallest = sb.toString();
                }
            }
            return smallest;
        } else {
            char[] arr = s.toCharArray();
            Arrays.sort(arr);
            return new String(arr);
        }
    }
}
```

```python
class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        if k == 1:
            ans = s
            for _ in range(len(s) - 1):
                s = s[1:] + s[0]
                ans = min(ans, s)
            return ans
        return ''.join(sorted(s))
```

计算字典序最小的字符串时，需要分别考虑 k = 1 和 k > 1 的两种情况。

当 k = 1 时，每次只能取 s 的首个字符并将其移动到末尾，因此对于给定的字符串，可能的移动方法是唯一的，移动后的结果也是唯一的。对于长度为 n 的字符串 s，经过 0 次到 n - 1 次移动之后分别得到 n 个字符串，这 nn 个字符串中的字典序最小的字符串即为答案。

当 k > 1 时，一定可以经过移动将 s 变成升序字符串，因此将字符串 s 升序排序之后得到的字符串即为答案。理由如下。

考虑 k = 2 的情况。假设 ss 的所有字符按照升序排序依次是 $c_0, c_1, \ldots, c_{n - 1}$。对于 s 的任意排列，总是可以经过若干次移动将 $c_{n - 1}$变成首个字符。

当 $c_{n - 1}$变成首个字符之后，可以将 $c_{n - 2}, c_{n - 1}$变成前两个字符：

1. 每次将首个字符移动到末尾，直到 $c_{n - 2}$变成首个字符；

2. 保持 $c_{n - 2}$位于首个字符，每次将 $c_{n - 2}$后面的字符移动到末尾，直到 $c_{n - 2}$ 后面的字符是 $c_{n - 1}$。

使用同样的方法，对于 $1 \le m < n$，如果 $c_{n - m}, c_{n - m + 1}, \ldots, c_{n - 1}$位于前 m 个字符，则可以经过若干次移动将 $c_{n - m - 1}, c_{n - m}, c_{n - m + 1}, \ldots, c_{n - 1}$变成前 m + 1 个字符：

每次将首个字符移动到末尾，直到 $c_{n - m - 1}$变成首个字符，此时 $c_{n - m}, c_{n - m + 1}, \ldots, c_{n - 1}$为字符串中连续的 m 个字符；

保持 $c_{n - m - 1}$ 位于首个字符，每次将 $c_{n - m - 1}$ 后面的字符移动到末尾，直到 $c_{n - m - 1}$后面的字符是 $c_{n - m}$，此时前 m + 1 个字符是$ c_{n - m - 1}, c_{n - m}, c_{n - m + 1}, \ldots, c_{n - 1}$。

因此，当 k = 2 时，一定可以经过移动将 s 变成升序字符串。

当 k > 2 时，同样可以对字符串的前两个字符执行移动操作将 s 变成升序字符串。

#### 复杂度分析

- 时间复杂度：$O(n^2)$，其中 n 是字符串 s 的长度。当 k = 1 时需要遍历 n 个可能的字符串，每个字符串需要 O(n) 的时间生成和判断是否字典序最小，时间复杂度是 $O(n^2)$；当 k > 1 时需要对字符串排序，时间复杂度是 $O(n \log n)$。最坏情况下时间复杂度是 $O(n^2)$。
- 空间复杂度：O(n) 或 $O(\log n)$，其中 n 是字符串 s 的长度。空间复杂度取决于具体实现的语言。对于字符串不可变的语言，当 k = 1 时生成每个字符串和当 k > 1 时生成排序后的字符串都需要 O(n) 的空间；对于字符串可变的语言，可以省略 O(n) 的空间，只有当 k > 1 时排序需要 $O(\log n)$ 的空间。


#### 结语

上述做法在 k = 1 时寻找字典序最小的字符串需要$ O(n^2)$ 的时间。如果使用最小表示法，则可以将时间复杂度降低到 O(n)。

[最小表示法 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/string/minimal-string/)

