# 题目

给定2D空间中四个点的坐标 `p1`, `p2`, `p3` 和 `p4`，如果这四个点构成一个正方形，则返回 `true` 。

点的坐标 `pi` 表示为 `[xi, yi]` 。输入 **不是** 按任何顺序给出的。

一个 **有效的正方形** 有四条等边和四个等角(90度角)。

**示例 1:**

```
输入: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]
输出: True
```

**示例 2:**

```
输入：p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]
输出：false
```

**示例 3:**

```
输入：p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]
输出：true
```

**提示:**

- `p1.length == p2.length == p3.length == p4.length == 2`
- $-10^4 <= xi, yi <= 10^4$

## 我的解法

我是菜鸡！正方形的数学证明都忘记了！代码极其离谱！

```python
class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
        def absVector(vector):
            return vector[0] ** 2 + vector[1] ** 2
        p12 = [p2[0] - p1[0], p2[1] - p1[1]]
        p13 = [p3[0] - p1[0], p3[1] - p1[1]]
        p14 = [p4[0] - p1[0], p4[1] - p1[1]]

        if absVector(p12) == 0 or absVector(p13) == 0 or absVector(p14) == 0:
            return False
        if p12[0] * p13[0] + p12[1] * p13[1] == 0:
            p42 = [p2[0] - p4[0], p2[1] - p4[1]]
            p43 = [p3[0] - p4[0], p3[1] - p4[1]]
            return absVector(p12) == absVector(p13) == absVector(p42) == absVector(p43)
        elif p12[0] * p14[0] + p12[1] * p14[1] == 0:
            p32 = [p2[0] - p3[0], p2[1] - p3[1]]
            p34 = [p4[0] - p3[0], p4[1] - p3[1]]
            return absVector(p12) == absVector(p14) == absVector(p32) == absVector(p34) 
        elif p13[0] * p14[0] + p13[1] * p14[1] == 0:
            p23 = [p3[0] - p2[0], p3[1] - p2[1]]
            p24 = [p4[0] - p2[0], p4[1] - p2[1]]
            return absVector(p13) == absVector(p14) == absVector(p24) == absVector(p23)
        else:
            return False
```

## 其他解法

### 数学

```c++
class Solution {
public:
    bool checkLength(vector<int>& v1, vector<int>& v2) {
        return (v1[0] * v1[0] + v1[1] * v1[1]) == (v2[0] * v2[0] + v2[1] * v2[1]);
    }

    bool checkMidPoint(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {
        return (p1[0] + p2[0]) == (p3[0] + p4[0]) && (p1[1] + p2[1]) == (p3[1] + p4[1]);
    }

    int calCos(vector<int>& v1, vector<int>& v2) {
        return (v1[0] * v2[0] + v1[1] * v2[1]) == 0;
    }

    bool help(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {
        vector<int> v1 = {p1[0] - p2[0], p1[1] - p2[1]};
        vector<int> v2 = {p3[0] - p4[0], p3[1] - p4[1]};
        if (checkMidPoint(p1, p2, p3, p4) && checkLength(v1, v2) && calCos(v1, v2)) {
            return true;
        } 
        return false;
    }

    bool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {
        if (p1 == p2) {
            return false;
        }
        if (help(p1, p2, p3, p4)) {
            return true;
        }
        if (p1 == p3) {
            return false;
        }
        if (help(p1, p3, p2, p4)) {
            return true;
        }
        if (p1 == p4) {
            return false;
        }
        if (help(p1, p4, p2, p3)) {
            return true;
        }
        return false;
    }
};
```

```java
class Solution {
    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {
        if (Arrays.equals(p1, p2)) {
            return false;
        }
        if (help(p1, p2, p3, p4)) {
            return true;
        }
        if (Arrays.equals(p1, p3)) {
            return false;
        }
        if (help(p1, p3, p2, p4)) {
            return true;
        }
        if (Arrays.equals(p1, p4)) {
            return false;
        }
        if (help(p1, p4, p2, p3)) {
            return true;
        }
        return false;
    }

    public boolean help(int[] p1, int[] p2, int[] p3, int[] p4) {
        int[] v1 = {p1[0] - p2[0], p1[1] - p2[1]};
        int[] v2 = {p3[0] - p4[0], p3[1] - p4[1]};
        if (checkMidPoint(p1, p2, p3, p4) && checkLength(v1, v2) && calCos(v1, v2)) {
            return true;
        } 
        return false;
    }

    public boolean checkLength(int[] v1, int[] v2) {
        return (v1[0] * v1[0] + v1[1] * v1[1]) == (v2[0] * v2[0] + v2[1] * v2[1]);
    }

    public boolean checkMidPoint(int[] p1, int[] p2, int[] p3, int[] p4) {
        return (p1[0] + p2[0]) == (p3[0] + p4[0]) && (p1[1] + p2[1]) == (p3[1] + p4[1]);
    }

    public boolean calCos(int[] v1, int[] v2) {
        return (v1[0] * v2[0] + v1[1] * v2[1]) == 0;
    }
}
```

```python
def checkLength(v1: Tuple[int, int], v2: Tuple[int, int]) -> bool:
    return v1[0] * v1[0] + v1[1] * v1[1] == v2[0] * v2[0] + v2[1] * v2[1]

def checkMidPoint(p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
    return p1[0] + p2[0] == p3[0] + p4[0] and p1[1] + p2[1] == p3[1] + p4[1]

def calCos(v1: Tuple[int, int], v2: Tuple[int, int]) -> int:
    return v1[0] * v2[0] + v1[1] * v2[1]

def help(p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
    v1 = (p1[0] - p2[0], p1[1] - p2[1])
    v2 = (p3[0] - p4[0], p3[1] - p4[1])
    return checkMidPoint(p1, p2, p3, p4) and checkLength(v1, v2) and calCos(v1, v2) == 0

class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
        if p1 == p2:
            return False
        if help(p1, p2, p3, p4):
            return True
        if p1 == p3:
            return False
        if help(p1, p3, p2, p4):
            return True
        if p1 == p4:
            return False
        if help(p1, p4, p2, p3):
            return True
        return False
```

#### 思路与算法

正方形判定定理是几何学里用于判定一个四边形是否为正方形的判定定理。判别正方形的一般顺序为先说明它是平行四边形；再说明它是菱形（或矩形）；最后说明它是矩形（或菱形）。那么我们可以从枚举四边形的两条斜边入手来进行判断：

- 如果两条斜边的中点相同：则说明以该两条斜边组成的四边形为「平行四边形」。
- 在满足「条件一」的基础上，如果两条斜边的长度相同：则说明以该两条斜边组成的四边形为「矩形」。
- 在满足「条件二」的基础上，如果两条斜边的相互垂直：则说明以该两条斜边组成的四边形为「正方形」。

#### **复杂度分析**

- 时间复杂度：O(1)。
- 空间复杂度：O(1)，仅使用常数变量。