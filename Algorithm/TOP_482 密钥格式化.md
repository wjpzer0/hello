# 题目

有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。其中， N 个 '-' 将字符串分成了 N+1 组。

给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。

给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。

**示例 1：**

```
输入：S = "5F3Z-2e-9-w", K = 4
输出："5F3Z-2E9W"
解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。
```

**示例 2：**

```
输入：S = "2-5g-3-J", K = 2
输出："2-5G-3J"
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
```

**提示:**

1. S 的长度可能很长，请按需分配大小。K 为正整数。
2. S 只包含字母数字（a-z，A-Z，0-9）以及破折号'-'
3. S 非空

## 我的解法

解法较为繁琐，需要经过预处理， 代码不够精简！

```python
class Solution:
    def licenseKeyFormatting(self, s: str, k: int) -> str:
        news = ""
        for i in s:
            if i != "-":
                if i.islower():
                    news += i.upper()
                else:
                    news += i
                    
        size = len(news)
        first = size % k
        ans = ""

        point = 0
        if k != 0:
            while point < first:
                ans += news[point]
                point += 1

        while point < size:
            if (point-first) % k == 0 and point != 0:
                ans += "-"
            ans += news[point]
            point += 1     

        return ans
```

## 其他解法

### 数学

```c++
class Solution {
public:
    string licenseKeyFormatting(string s, int k) {
        string ans;
        int cnt = 0;
        
        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] != '-') {
                ans.push_back(toupper(s[i]));
                cnt++;
                if (cnt % k == 0) {
                    ans.push_back('-');
                }  
            }
        }
        if (ans.size() > 0 && ans.back() == '-') {
            ans.pop_back();
        }
        reverse(ans.begin(), ans.end());
        
        return ans;
    }
};
```

```java
class Solution {
    public String licenseKeyFormatting(String s, int k) {
        StringBuilder ans = new StringBuilder();
        int cnt = 0;

        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) != '-') {
                cnt++;
                ans.append(Character.toUpperCase(s.charAt(i)));
                if (cnt % k == 0) {
                    ans.append("-");
                }
            }
        }
        if (ans.length() > 0 && ans.charAt(ans.length() - 1) == '-') {
            ans.deleteCharAt(ans.length() - 1);
        }
        
        return ans.reverse().toString();
    }
}
```

```python
class Solution:
    def licenseKeyFormatting(self, s: str, k: int) -> str:
        ans = list()
        cnt = 0

        for i in range(len(s) - 1, -1, -1):
            if s[i] != "-":
                ans.append(s[i].upper())
                cnt += 1
                if cnt % k == 0:
                    ans.append("-")
        
        if ans and ans[-1] == "-":
            ans.pop()
        
        return "".join(ans[::-1])
```

#### 思路及解法

首先我们取出所有不为破折号的字符，题目要求对取出的字符进行重新分组，使得每个分组恰好包含 k 个字符，且必须满足第一个分组包含的字符个数必须小于等于 k，但至少要包含 1 个字符。设已经取出的字符的总数为 n，只需满足第一个分组包含的字符数目刚好等于$ n \bmod k$，剩余的分组包含的字符数目刚好等于 k。

- 我们可以从字符串 s 的末尾开始往前取出字符构建新的字符串 $\textit{ans}$。每次取出字符时首先判断该字符是否为破折号，如果为破折号则跳过；否则将当前的字符计数 $\textit{cnt}$ 加 1，同时检查如果当前字符为小写字母则将其转化为大写字母，将当前字符加入到字符串 $\textit{ans}$ 的末尾。
- 对字符进行计数时，每隔 k 个字符就在字符串 $\textit{ans}$ 中添加一个破折号。特殊情况需要处理，字符串 $\textit{ans}$ 的最后一个字符为破折号则将其去掉。
- 我们对已经构建的字符串 $\textit{ans}$ 进行反转即为返回结果。

#### 复杂度分析

- 时间复杂度：O(N)，其中 N 为字符串的长度。一共需要两次遍历，第一次遍历字符串求得目标字符串，第二次遍历需要将目标字符串进行反转。

- 空间复杂度：O(1) 或 O(N)，其中 N 为字符串的长度。这里的空间复杂度统计的是存储返回值以外的空间。如果使用的语言可以修改字符串，那么反转前后的字符串可以存储在同一片区域，空间复杂度为 O(1)；如果不可以修改，那么反转前的字符串需要额外的空间进行存储，空间复杂度为 O(N)。


