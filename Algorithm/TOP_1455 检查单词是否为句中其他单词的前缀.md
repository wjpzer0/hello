# 题目

给你一个字符串 `sentence` 作为句子并指定检索词为 `searchWord` ，其中句子由若干用 **单个空格** 分隔的单词组成。请你检查检索词 `searchWord` 是否为句子 `sentence` 中任意单词的前缀。

如果 `searchWord` 是某一个单词的前缀，则返回句子 `sentence` 中该单词所对应的下标（**下标从 1 开始**）。如果 `searchWord` 是多个单词的前缀，则返回匹配的第一个单词的下标（**最小下标**）。如果 `searchWord` 不是任何单词的前缀，则返回 `-1` 。

字符串 `s` 的 **前缀** 是 `s` 的任何前导连续子字符串。

**示例 1：**

```
输入：sentence = "i love eating burger", searchWord = "burg"
输出：4
解释："burg" 是 "burger" 的前缀，而 "burger" 是句子中第 4 个单词。
```

**示例 2：**

```
输入：sentence = "this problem is an easy problem", searchWord = "pro"
输出：2
解释："pro" 是 "problem" 的前缀，而 "problem" 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。
```

**示例 3：**

```
输入：sentence = "i am tired", searchWord = "you"
输出：-1
解释："you" 不是句子中任何单词的前缀。
```

**提示：**

- `1 <= sentence.length <= 100`
- `1 <= searchWord.length <= 10`
- `sentence` 由小写英文字母和空格组成。
- `searchWord` 由小写英文字母组成。

## 我的解法

读题，过度依赖内置函数！

```python
class Solution:
    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
        senList = sentence.split()
        n = len(searchWord)
        for i, sen in enumerate(senList):
            if searchWord == sen[:n]:
                ans = i + 1
                return i + 1
        return -1
```

## 其它解法

### 双指针

```c++
class Solution {
public:
    bool isPrefix(const string &sentence, int start, int end, const string &searchWord) {
        for (int i = 0; i < searchWord.size(); i++) {
            if (start + i >= end || sentence[start + i] != searchWord[i]) {
                return false;
            }
        }
        return true;
    }

    int isPrefixOfWord(string sentence, string searchWord) {
        int n = sentence.size(), index = 1, start = 0, end = 0;
        while (start < n) {
            while (end < n && sentence[end] != ' ') {
                end++;
            }
            if (isPrefix(sentence, start, end, searchWord)) {
                return index;
            }

            index++;
            end++;
            start = end;
        }
        return -1;
    }
};
```

```java
class Solution {
    public int isPrefixOfWord(String sentence, String searchWord) {
        int n = sentence.length(), index = 1, start = 0, end = 0;
        while (start < n) {
            while (end < n && sentence.charAt(end) != ' ') {
                end++;
            }
            if (isPrefix(sentence, start, end, searchWord)) {
                return index;
            }

            index++;
            end++;
            start = end;
        }
        return -1;
    }

    public boolean isPrefix(String sentence, int start, int end, String searchWord) {
        for (int i = 0; i < searchWord.length(); i++) {
            if (start + i >= end || sentence.charAt(start + i) != searchWord.charAt(i)) {
                return false;
            }
        }
        return true;
    }
}
```

```python
class Solution:
    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
        i, index, n = 0, 1, len(sentence)
        while i < n:
            start = i
            while i < n and sentence[i] != ' ':
                i += 1
            end = i
            if sentence[start:end].startswith(searchWord):
                return index
            index += 1
            i += 1
        return -1
```

使用 $\textit{start}$记录单词的起始，$\textit{end}$记录单词结尾的下一个位置。我们遍历字符串 $\textit{sentence}$并不断地分割单词，对于区间 $[\textit{start}, \textit{end})$对应的单词，判断它是否存在某一前缀等于 $\textit{searchWord}$，如果存在直接返回该单词对应的下标 $\textit{index}$；如果遍历完所有单词都不符合条件，返回 -1。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是 $\textit{sentence}$的长度。遍历字符串 $\textit{sentence}$需要 O(n)，前缀判断函数 $\text{isPrefix}$的总时间复杂度为 O(n)。

- 空间复杂度：O(1)，只需要额外的常数级别的空间。


