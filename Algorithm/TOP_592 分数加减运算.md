# 题目

给定一个表示分数加减运算的字符串 `expression` ，你需要返回一个字符串形式的计算结果。 

这个结果应该是不可约分的分数，即[最简分数](https://baike.baidu.com/item/最简分数)。 如果最终结果是一个整数，例如 `2`，你需要将它转换成分数形式，其分母为 `1`。所以在上述例子中, `2` 应该被转换为 `2/1`。

**示例 1:**

```
输入: expression = "-1/2+1/2"
输出: "0/1"
```

 **示例 2:**

```
输入: expression = "-1/2+1/2+1/3"
输出: "1/3"
```

**示例 3:**

```
输入: expression = "1/3-1/2"
输出: "-1/6"
```

**提示:**

- 输入和输出字符串只包含 `'0'` 到 `'9'` 的数字，以及 `'/'`, `'+'` 和 `'-'`。 
- 输入和输出分数格式均为 `±分子/分母`。如果输入的第一个分数或者输出的分数是正数，则 `'+'` 会被省略掉。
- 输入只包含合法的**最简分数**，每个分数的**分子**与**分母**的范围是 [1,10]。 如果分母是1，意味着这个分数实际上是一个整数。
- 输入的分数个数范围是 [1,10]。
- **最终结果**的分子与分母保证是 32 位整数范围内的有效整数。

## 我的解法

对于最大公约数和最小公倍数的算法不熟悉！

```python
class Solution:
    def fractionAddition(self, expression: str) -> str:
        def lcm(x, y):
            a = x
            b = y
            while b:
                a, b = b, a % b
            return x * y // a

        def gcd(x, y):
            a = x
            b = y
            while b:
                a, b = b, a % b
            return a

        nums = []
        num = ""
        for s in expression:
            if s in ("-", "+") and num:
                nums.append(num)
                num = ""
            num += s
        nums.append(num)

        mid = "0/1"
        for num in nums:
            molecular1, denominator1 = map(int, mid.split('/'))
            molecular2, denominator2 = map(int, num.split('/'))
            denominator = lcm(denominator1, denominator2)
            molecular = molecular1 * (denominator // denominator1) + molecular2 * (denominator // denominator2)
            mid = str(molecular) + '/' + str(denominator)
        
        molecular = abs(molecular)
        factor = gcd(molecular, denominator)
        molecular = molecular // factor
        denominator = denominator // factor
        ans = str(molecular) + '/' + str(denominator)
        if mid[0] == '-':
            return '-' + ans
        else:
            return ans
```

## 其他解法

### 模拟

```c++
class Solution {
public:
    string fractionAddition(string expression) {
        long long denominator = 0, numerator = 1; // 分子，分母
        int index = 0, n = expression.size();
        while (index < n) {
            // 读取分子
            long long denominator1 = 0, sign = 1;
            if (expression[index] == '-' || expression[index] == '+') {
                sign = expression[index] == '-' ? -1 : 1;
                index++;
            }
            while (index < n && isdigit(expression[index])) {
                denominator1 = denominator1 * 10 + expression[index] - '0';
                index++;
            }
            denominator1 = sign * denominator1;
            index++;

            // 读取分母
            long long numerator1 = 0;
            while (index < n && isdigit(expression[index])) {
                numerator1 = numerator1 * 10 + expression[index] - '0';
                index++;
            }

            denominator = denominator * numerator1 + denominator1 * numerator;
            numerator *= numerator1;
        }
        if (denominator == 0) {
            return "0/1";
        }
        long long g = gcd(abs(denominator), numerator); // 获取最大公约数
        return to_string(denominator / g) + "/" + to_string(numerator / g);
    }
};
```

```java
class Solution {
    public String fractionAddition(String expression) {
        long denominator = 0, numerator = 1; // 分子，分母
        int index = 0, n = expression.length();
        while (index < n) {
            // 读取分子
            long denominator1 = 0, sign = 1;
            if (expression.charAt(index) == '-' || expression.charAt(index) == '+') {
                sign = expression.charAt(index) == '-' ? -1 : 1;
                index++;
            }
            while (index < n && Character.isDigit(expression.charAt(index))) {
                denominator1 = denominator1 * 10 + expression.charAt(index) - '0';
                index++;
            }
            denominator1 = sign * denominator1;
            index++;

            // 读取分母
            long numerator1 = 0;
            while (index < n && Character.isDigit(expression.charAt(index))) {
                numerator1 = numerator1 * 10 + expression.charAt(index) - '0';
                index++;
            }

            denominator = denominator * numerator1 + denominator1 * numerator;
            numerator *= numerator1;
        }
        if (denominator == 0) {
            return "0/1";
        }
        long g = gcd(Math.abs(denominator), numerator); // 获取最大公约数
        return Long.toString(denominator / g) + "/" + Long.toString(numerator / g);
    }

    public long gcd(long a, long b) {
        long remainder = a % b;
        while (remainder != 0) {
            a = b;
            b = remainder;
            remainder = a % b;
        }
        return b;
    }
}
```

```python
class Solution:
    def fractionAddition(self, expression: str) -> str:
        denominator, numerator = 0, 1  # 分子，分母
        i, n = 0, len(expression)
        while i < n:
            # 读取分子
            denominator1, sign = 0, 1
            if expression[i] == '-' or expression[i] == '+':
                if expression[i] == '-':
                    sign = -1
                i += 1
            while i < n and expression[i].isdigit():
                denominator1 = denominator1 * 10 + int(expression[i])
                i += 1
            denominator1 = sign * denominator1
            i += 1

            # 读取分母
            numerator1 = 0
            while i < n and expression[i].isdigit():
                numerator1 = numerator1 * 10 + int(expression[i])
                i += 1

            denominator = denominator * numerator1 + denominator1 * numerator
            numerator *= numerator1
        if denominator == 0:
            return "0/1"
        g = gcd(abs(denominator), numerator)
        return f"{denominator // g}/{numerator // g}"
```

对于两个分数 $\dfrac{x_1}{y_1} $和 $\dfrac{x_2}{y_2} $，它们相加的结果为：
$$
\dfrac{x_1 \times y_2 + x_2 \times y_1}{y_1 \times y_2}
$$
初始分数的分子为 $\textit{denominator} = 0$，分母为 $\textit{numerator} = 1$。我们不断从字符串中获取下一个分数，它的分子为$ \textit{denominator}_1$，分母为 $\textit{numerator}_1$，将它加到初始分数上，有：
$$
\begin{cases} \textit{denominator} = \textit{denominator} \times \textit{numerator}_1 + \textit{denominator}_1 \times \textit{numerator} \\ \textit{numerator} = \textit{numerator} \times \textit{numerator}_1 \end{cases}
$$
最后如果 $\textit{denominator} = 0$，说明结果为零，直接返回 $\text{"0/1"}$；否则计算分子分母的最大公约数，返回约简后分数的字符串表示。

#### 复杂度分析

- 时间复杂度：$O(n + \log C)$，其中 n 是字符串 $\textit{expression}$的长度，C 为化简前结果分子分母的最大值。求最大公约数需要 $O(\log C)$。

- 空间复杂度：O(1)。


