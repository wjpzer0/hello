# 题目

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：

- `MyCircularQueue(k)`: 构造器，设置队列长度为 k 。
- `Front`: 从队首获取元素。如果队列为空，返回 -1 。
- `Rear`: 获取队尾元素。如果队列为空，返回 -1 。
- `enQueue(value)`: 向循环队列插入一个元素。如果成功插入则返回真。
- `deQueue()`: 从循环队列中删除一个元素。如果成功删除则返回真。
- `isEmpty()`: 检查循环队列是否为空。
- `isFull()`: 检查循环队列是否已满。

 

**示例：**

```
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
```

**提示：**

- 所有的值都在 0 至 1000 的范围内；
- 操作数将在 1 至 1000 的范围内；
- 请不要使用内置的队列库。

## 我的解法

自己的解法太过依赖内置函数！

```python
class MyCircularQueue:

    def __init__(self, k: int):
        self.length = k
        self.qu = []

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.qu.append(value)
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        del self.qu[0]
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.qu[0]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.qu[-1]

    def isEmpty(self) -> bool:
        if len(self.qu) == 0:
            return True
        return False

    def isFull(self) -> bool:
        if len(self.qu) == self.length:
            return True
        return False

# Your MyCircularQueue object will be instantiated and called as such:
# obj = MyCircularQueue(k)
# param_1 = obj.enQueue(value)
# param_2 = obj.deQueue()
# param_3 = obj.Front()
# param_4 = obj.Rear()
# param_5 = obj.isEmpty()
# param_6 = obj.isFull()
```

## 其他解法

### 数组

```c++
class MyCircularQueue {
private:
    int front;
    int rear;
    int capacity;
    vector<int> elements;

public:
    MyCircularQueue(int k) {
        this->capacity = k + 1;
        this->elements = vector<int>(capacity);
        rear = front = 0;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        elements[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return elements[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return elements[(rear - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return rear == front;
    }

    bool isFull() {
        return ((rear + 1) % capacity) == front;
    }
};
```

```java
class MyCircularQueue {
    private int front;
    private int rear;
    private int capacity;
    private int[] elements;

    public MyCircularQueue(int k) {
        capacity = k + 1;
        elements = new int[capacity];
        rear = front = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        elements[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return elements[front];
    }

    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return elements[(rear - 1 + capacity) % capacity];
    }

    public boolean isEmpty() {
        return rear == front;
    }

    public boolean isFull() {
        return ((rear + 1) % capacity) == front;
    }
}
```

```python
class MyCircularQueue:
    def __init__(self, k: int):
        self.front = self.rear = 0
        self.elements = [0] * (k + 1)

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.elements[self.rear] = value
        self.rear = (self.rear + 1) % len(self.elements)
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % len(self.elements)
        return True

    def Front(self) -> int:
        return -1 if self.isEmpty() else self.elements[self.front]

    def Rear(self) -> int:
        return -1 if self.isEmpty() else self.elements[(self.rear - 1) % len(self.elements)]

    def isEmpty(self) -> bool:
        return self.rear == self.front

    def isFull(self) -> bool:
        return (self.rear + 1) % len(self.elements) == self.front
```

关于循环队列的概念可以参考：「循环队列」，我们可以通过一个数组进行模拟，通过操作数组的索引构建一个虚拟的首尾相连的环。在循环队列结构中，设置一个队尾 $\textit{rear}$与队首 $\textit{front}$，且大小固定，结构如下图所示:

![1](https://assets.leetcode-cn.com/solution-static/622/622_1.png)

在循环队列中，当队列为空，可知$ \textit{front}=\textit{rear}$；而当所有队列空间全占满时，也有 $\textit{front}=\textit{rear}$。为了区别这两种情况，假设队列使用的数组有 $\textit{capacity}$个存储空间，则此时规定循环队列最多只能有$\textit{capacity} - 1$ 个队列元素，当循环队列中只剩下一个空存储单元时，则表示队列已满。根据以上可知，队列判空的条件是 $\textit{front}=\textit{rear}$，而队列判满的条件是 $\textit{front} = (\textit{rear} + 1) \bmod \textit{capacity}$。
对于一个固定大小的数组，只要知道队尾 $\textit{rear}$与队首 $\textit{front}$，即可计算出队列当前的长度：
$$
(\textit{rear} - \textit{front} + \textit{capacity}) \bmod \textit{capacity}
$$
循环队列的属性如下:

- $\textit{elements}$：一个固定大小的数组，用于保存循环队列的元素。
- $\textit{capacity}$：循环队列的容量，即队列中最多可以容纳的元素数量。
- $\textit{front}$：队列首元素对应的数组的索引。
- $\textit{rear}$：队列尾元素对应的索引的下一个索引。

循环队列的接口方法如下：

- $\texttt{MyCircularQueue(int k)}$: 初始化队列，同时$\textit{base}$数组的空间初始化大小为 k + 1。$\textit{front}, \textit{rear}$ 全部初始化为 0。
- $\texttt{enQueue(int value)}$：在队列的尾部插入一个元素，并同时将队尾的索引 $\textit{rear}$更新为 
- $(\textit{rear} + 1) \bmod capacity$。
- $\texttt{deQueue()}$：从队首取出一个元素，并同时将队首的索引 $\textit{front}$更新为 $(\textit{front} + 1) \bmod capacity$。
- $\texttt{Front()}$：返回队首的元素，需要检测队列是否为空。
- $\texttt{Rear()}$：返回队尾的元素，需要检测队列是否为空。
- $\texttt{isEmpty()}$：检测队列是否为空，根据之前的定义只需判断 $\textit{rear}$是否等于 $\textit{front}$。
- $\texttt{isFull()}$：检测队列是否已满，根据之前的定义只需判断 $\textit{front}$是否等于 $(\textit{rear} + 1) \bmod \textit{capacity}$。

#### **复杂度分析**

- 时间复杂度：初始化和每项操作的时间复杂度均为 O(1)。
- 空间复杂度：O(k)，其中 k 为给定的队列元素数目。

### 链表

```c++
class MyCircularQueue {
private:
    ListNode *head;
    ListNode *tail;
    int capacity;
    int size;

public:
    MyCircularQueue(int k) {
        this->capacity = k;
        this->size = 0;
        this->head = this->tail = nullptr;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        ListNode *node = new ListNode(value);
        if (!head) {
            head = tail = node;
        } else {
            tail->next = node;
            tail = node;
        }
        size++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        ListNode *node = head;
        head = head->next;  
        size--;
        delete node;
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return head->val;
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return tail->val;
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == capacity;
    }
};
```

```java
class MyCircularQueue {
    private ListNode head;
    private ListNode tail;
    private int capacity;
    private int size;

    public MyCircularQueue(int k) {
        capacity = k;
        size = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        ListNode node = new ListNode(value);
        if (head == null) {
            head = tail = node;
        } else {
            tail.next = node;
            tail = node;
        }
        size++;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        ListNode node = head;
        head = head.next;  
        size--;
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return head.val;
    }

    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return tail.val;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```

```python
class MyCircularQueue:
    def __init__(self, k: int):
        self.head = self.tail = None
        self.capacity = k
        self.size = 0

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        node = ListNode(value)
        if self.head is None:
            self.head = node
            self.tail = node
        else:
            self.tail.next = node
            self.tail = node
        self.size += 1
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.head = self.head.next
        self.size -= 1
        return True

    def Front(self) -> int:
        return -1 if self.isEmpty() else self.head.val

    def Rear(self) -> int:
        return -1 if self.isEmpty() else self.tail.val

    def isEmpty(self) -> bool:
        return self.size == 0

    def isFull(self) -> bool:
        return self.size == self.capacity
```

我们同样可以用链表实现队列，用链表实现队列则较为简单，因为链表可以在 O(1) 时间复杂度完成插入与删除。入队列时，将新的元素插入到链表的尾部；出队列时，将链表的头节点返回，并将头节点指向下一个节点。

循环队列的属性如下:

- $\textit{head}$：链表的头节点，队列的头节点。
- $\textit{tail}$：链表的尾节点，队列的尾节点。
- $\textit{capacity}$：队列的容量，即队列可以存储的最大元素数量。
- $\textit{size}$：队列当前的元素的数量。

#### **复杂度分析**

- 时间复杂度：初始化和每项操作的时间复杂度均为 O(1)。
- 空间复杂度：O(k)，其中 k 为给定的队列元素数目。