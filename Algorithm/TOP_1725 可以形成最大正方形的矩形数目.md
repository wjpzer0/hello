# 题目

给你一个数组 `rectangles` ，其中 `rectangles[i] = [li, wi]` 表示第 `i` 个矩形的长度为 `li` 、宽度为 `wi` 。

如果存在 `k` 同时满足 `k <= li` 和 `k <= wi` ，就可以将第 `i` 个矩形切成边长为 `k` 的正方形。例如，矩形 `[4,6]` 可以切成边长最大为 `4` 的正方形。

设 `maxLen` 为可以从矩形数组 `rectangles` 切分得到的 **最大正方形** 的边长。

请你统计有多少个矩形能够切出边长为 `maxLen` 的正方形，并返回矩形 **数目** 。

**示例 1：**

```
输入：rectangles = [[5,8],[3,9],[5,12],[16,5]]
输出：3
解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。
最大正方形的边长为 5 ，可以由 3 个矩形切分得到。
```

**示例 2：**

```
输入：rectangles = [[2,3],[3,7],[4,3],[3,7]]
输出：3
```

 

**提示：**

- `1 <= rectangles.length <= 1000`
- `rectangles[i].length == 2`
- $1 <= li, wi <= 10^9$
- `li != wi`

## 我的解法

我的解法，代码有些冗余，而且还循环了两次！

```python
class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        ans = 0
        maxLen = {}
        for l, w in rectangles:
            square = min(l, w)
            if square in maxLen:
                maxLen[square] += 1
            else:
                maxLen[square] = 1
        
        maxSquare = 0
        for k in maxLen.keys():
            if k > maxSquare:
                maxSquare = k

        return maxLen[maxSquare]
```

## 其他解法

### 一次遍历

```c++
class Solution {
public:
    int countGoodRectangles(vector<vector<int>>& rectangles) {
        int res = 0, maxLen = 0;
        for (auto & rectangle : rectangles) {
            int l = rectangle[0], w = rectangle[1];
            int k = min(l, w);
            if (k == maxLen) {
                ++res;
            } else if (k > maxLen) {
                res = 1;
                maxLen = k;
            }
        }
        return res;
    }
};
```

```java
class Solution {
    public int countGoodRectangles(int[][] rectangles) {
        int res = 0, maxLen = 0;
        for (int[] rectangle : rectangles) {
            int l = rectangle[0], w = rectangle[1];
            int k = Math.min(l, w);
            if (k == maxLen) {
                ++res;
            } else if (k > maxLen) {
                res = 1;
                maxLen = k;
            }
        }
        return res;
    }
}
```

```python
class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        res, maxLen = 0, 0
        for l, w in rectangles:
            k = min(l, w)
            if k == maxLen:
                res += 1
            elif k > maxLen:
                res = 1
                maxLen = k
        return res
```

#### 思路

记 l 和 w 为某个矩形的长度和宽度，设 k 为可以从这个矩形中切出的最大正方形的边长，则有 $k = \min(l, w)$。我们遍历输入数组，维护两个变量，$\textit{maxLen}$表示遍历到当前矩形时的所有可以切出的最大正方形的边长的最大值，$\textit{res}$ 表示可以切出边长为 $\textit{maxLen}$ 的正方形的个数。计算当前的 k，当 $k = \textit{maxLen}$ 时，对 $\textit{res}$ 进行加 1 操作；当$ k > \textit{maxLen}$ 时，则更新 $\textit{maxLen}$ 为 kk，并把 $\textit{res}$ 重置为 1。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为输入数组 $\textit{rectangles}$ 的长度。我们仅需一次遍历即可得到答案。

- 空间复杂度：O(1)。我们仅需要常数空间来存储变量。


