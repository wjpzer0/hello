# 题目

字符串轮转。给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成（比如，`waterbottle`是`erbottlewat`旋转后的字符串）。

**示例1:**

```
 输入：s1 = "waterbottle", s2 = "erbottlewat"
 输出：True
```

**示例2:**

```
 输入：s1 = "aa", s2 = "aba"
 输出：False
```

**提示：**

1. 字符串长度在[0, 100000]范围内。

**说明:**

1. 你能只调用一次检查子串的方法吗？

## 我的解法

一点反应暴力破解

```python
class Solution:
    def isFlipedString(self, s1: str, s2: str) -> bool:
        if len(s1) != len(s2):
            return False
        if s1 == s2:
            return True
        n = len(s1)
        for i in range(n):
            mid = s1[i:] + s1[:i]
            if mid == s2:
                return True
        return False
```

看到题解后才写出

```python
class Solution:
    def isFlipedString(self, s1: str, s2: str) -> bool:
        if len(s1) != len(s2):
            return False
        mid = s1 + s1
        return s2 in mid
```

## 其它解法

### 模拟

```c++
class Solution {
public:
    bool isFlipedString(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        if (m != n) {
            return false;
        }
        if (n == 0) {
            return true;
        }
        for (int i = 0; i < n; i++) {
            bool flag = true;
            for (int j = 0; j < n; j++) {
                if (s1[(i + j) % n] != s2[j]) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                return true;
            }
        }
        return false;
    }
};
```

```java
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        if (m != n) {
            return false;
        }
        if (n == 0) {
            return true;
        }
        for (int i = 0; i < n; i++) {
            boolean flag = true;
            for (int j = 0; j < n; j++) {
                if (s1.charAt((i + j) % n) != s2.charAt(j)) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                return true;
            }
        }
        return false;
    }
}
```

```python
class Solution:
    def isFlipedString(self, s1: str, s2: str) -> bool:
        m, n = len(s1), len(s2)
        if m != n:
            return False
        if n == 0:
            return True
        for i in range(n):
            for j in range(n):
                if s1[(i + j) % n] != s2[j]:
                    break
            else:
                return True
        return False
```

#### 思路

首先，如果 $s_1$ 和 $s_2$ 的长度不一样，那么无论怎么轮转，$s_1$ 都不能得到 $s_2$，返回 $\text{false}$。在长度一样（都为 n）的前提下，假设 $s_1$ 轮转 i 位，则与 $s_2$中的某一位字符 $s_2[j]$ 对应的原 $s_1$  中的字符应该为$ s_1[(i+j) \bmod n]$。在固定 i 的情况下，遍历所有 j，若对应字符都相同，则返回 $\text{true}$。否则，继续遍历其他候选的 i。若所有的 i 都不能使 $s_1$ 变成 $s_2$，则返回 $\text{false}$。

#### 复杂度分析

- 时间复杂度：$O(n^2)$，其中 n 是字符串 $s_1$ 的长度。我们需要双重循环来判断。

- 空间复杂度：O(1)。仅使用常数空间。


### 搜索子字符串

```c++
class Solution {
public:
    bool isFlipedString(string s1, string s2) {
        return s1.size() == s2.size() && (s1 + s1).find(s2) != string::npos;
    }
};
```

```java
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        return s1.length() == s2.length() && (s1 + s1).contains(s2);
    }
}
```

```python
class Solution:
    def isFlipedString(self, s1: str, s2: str) -> bool:
        return len(s1) == len(s2) and s2 in s1 + s1
```

#### 思路

首先，如果 $s_1$ 和 $s_2$ 的长度不一样，那么无论怎么轮转，$s_1$ 都不能得到 $s_2$，返回 $\text{false}$。字符串 s + s 包含了所有$ s_1$ 可以通过轮转操作得到的字符串，只需要检查 $s_2$ 是否为 s + s 的子字符串即可。具体可以参考「28. 实现 strStr() 的官方题解」的实现代码，本题解中采用直接调用库函数的方法。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是字符串 $s_1$ 的长度。$\text{KMP}$算法搜索子字符串的时间复杂度为 O(n)，其他搜索子字符串的方法会略有差异。

- 空间复杂度：O(n)，其中 n 是字符串 $s_1$ 的长度。$\text{KMP}$算法搜索子字符串的空间复杂度为 O(n)，其他搜索子字符串的方法会略有差异。


