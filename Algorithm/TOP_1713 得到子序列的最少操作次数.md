# 题目



给你一个数组 `target` ，包含若干 **互不相同** 的整数，以及另一个整数数组 `arr` ，`arr` **可能** 包含重复元素。

每一次操作中，你可以在 `arr` 的任意位置插入任一整数。比方说，如果 `arr = [1,4,1,2]` ，那么你可以在中间添加 `3` 得到 [1,4,**3**,1,2]。你可以在数组最开始或最后面添加整数。

请你返回 **最少** 操作次数，使得 `target` 成为 `arr` 的一个子序列。

一个数组的 **子序列** 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，`[2,7,4]` 是 [4,**2**,3,**7**,2,1,**4**]的子序列（加粗元素），但 `[2,4,2]` 不是子序列。

**示例 1：**

```
输入：target = [5,1,3], arr = [9,4,2,3,4]
输出：2
解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。
```

**示例 2：**

```
输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]
输出：3
```

**提示：**

- $1 <= target.length, arr.length <= 10^5$
- $1 <= target[i], arr[i] <= 10^9$
- `target` 不包含任何重复元素。

## 我的解法

未解出，想到最长公共子序列的解法动态规划，但是写不出来！

## 其他解法

### 贪心 + 二分查找

```c++
class Solution {
public:
    int minOperations(vector<int> &target, vector<int> &arr) {
        int n = target.size();
        unordered_map<int, int> pos;
        for (int i = 0; i < n; ++i) {
            pos[target[i]] = i;
        }
        vector<int> d;
        for (int val : arr) {
            if (pos.count(val)) {
                int idx = pos[val];
                auto it = lower_bound(d.begin(), d.end(), idx);
                if (it != d.end()) {
                    *it = idx;
                } else {
                    d.push_back(idx);
                }
            }
        }
        return n - d.size();
    }
};
```

```java
class Solution {
    public int minOperations(int[] target, int[] arr) {
        int n = target.length;
        Map<Integer, Integer> pos = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; ++i) {
            pos.put(target[i], i);
        }
        List<Integer> d = new ArrayList<Integer>();
        for (int val : arr) {
            if (pos.containsKey(val)) {
                int idx = pos.get(val);
                int it = binarySearch(d, idx);
                if (it != d.size()) {
                    d.set(it, idx);
                } else {
                    d.add(idx);
                }
            }
        }
        return n - d.size();
    }

    public int binarySearch(List<Integer> d, int target) {
        int size = d.size();
        if (size == 0 || d.get(size - 1) < target) {
            return size;
        }
        int low = 0, high = size - 1;
        while (low < high) {
            int mid = (high - low) / 2 + low;
            if (d.get(mid) < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }
}
```

```python
class Solution:
    def minOperations(self, target: List[int], arr: List[int]) -> int:
        n = len(target)
        pos = {}
        for i,t in enumerate(target):
            pos[t] = i

        d = []
        for val in arr:
            if val in pos:
                idx = pos[val]
                site = bisect.bisect_left(d, idx)
                if site < len(d):
                    d[site] = idx
                else:
                    d.append(idx)
        
        return n-len(d)
```

记数组 $\textit{target}$​​ 的长度为 n，数组$\textit{arr}$​​ 的长度为 m。

根据题意，$\textit{target}$ 和 $\textit{arr}$ 这两个数组的公共子序列越长，需要添加的元素个数也就越少。因此最少添加的元素个数为 nn 减去两数组的最长公共子序列的长度。

求最长公共子序列是一个经典问题，可参考**TOP_1143 最长公共子序列**。但是，这一做法的时间复杂度是 O(nm) 的，在本题的数据范围下无法承受，我们需要改变思路。

由于 $\textit{target}$ 的元素互不相同，我们可以用一个哈希表记录 $\textit{target}$ 的每个元素所处的下标，并将 $\textit{arr}$ 中的元素映射到下标上，对于不存在于 $\textit{target}$ 中的元素，由于其必然不会在最长公共子序列中，可将其忽略。

我们使用示例 2 来说明，将 $\textit{arr}$ 中的元素转换成该元素在 $\textit{target}$ 中的下标（去掉不在 $\textit{target}$ 中的元素 7），可以得到一个新数组

$$
\textit{arr}' = [1,0,5,4,2,0,3]
$$
若将 $\textit{target}$ 也做上述转换，这相当于将每个元素变为其下标，得

$$
\textit{target}' = [0,1,2,3,4,5]
$$
则求原数组的最长公共子序列等价于求上述转换后的两数组的最长公共子序列。

注意到 $\textit{target}'$是严格单调递增的，因此 $\textit{arr}'$在最长公共子序列中的部分也必须是严格单调递增的，因此问题可进一步地转换成求 $\textit{arr}'$的最长递增子序列的长度。这也是一个经典问题，可以参考**TOP_300. 最长递增子序列**，使用贪心和二分查找的方法得到最长递增子序列的长度。

#### 复杂度分析

- 时间复杂度：$O(n+m\log m)$，其中 n 是数组 $\textit{target}$ 的长度，m 是数组 $\textit{arr}$ 的长度。遍历 $\textit{target}$ 需要 O(n) 的时间，求 $\textit{arr}'$的最长递增子序列需要 $O(m\log m)$的时间。

- 空间复杂度：O(n+m)。需要 O(n) 大小的哈希表存储 $\textit{target}$ 的元素的下标，以及 O(m) 的空间求最长递增子序列。


