# 题目

给定两个字符串 `s1` 和 `s2`，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

**示例 1：**

```
输入: s1 = "abc", s2 = "bca"
输出: true 
```

**示例 2：**

```
输入: s1 = "abc", s2 = "bad"
输出: false
```

**说明：**

- `0 <= len(s1) <= 100`
- `0 <= len(s2) <= 100`

## 我的解法

第一反应就是字典！

```python
class Solution:
    def CheckPermutation(self, s1: str, s2: str) -> bool:
        mapChar = {}
        for ch in s1:
            if ch in mapChar:
                mapChar[ch] += 1
            else:
                mapChar[ch] = 1
        
        for ch in s2:
            if ch in mapChar:
                mapChar[ch] -= 1
                if mapChar[ch] == 0:
                    del mapChar[ch]
            else:
                return False
        
        return len(mapChar) == 0
```

## 其他解法

### 排序

```c++
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        sort(s1.begin(), s1.end());
        sort(s2.begin(), s2.end());
        return s1 == s2;
    }
};
```

```java
class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        Arrays.sort(str1);
        Arrays.sort(str2);
        return Arrays.equals(str1, str2);
    }
}
```

字符串 $s_1$ 和 $s_2$ 互为字符重排等价于「两个字符串排序后相等」。因此我们可以对字符串 $s_1$ 和 $s_2$ 分别排序，看排序后的字符串是否相等即可判断。此外，如果 $s_1$ 和 $s_2$ 的长度不同，$s_2$ 必然不是 $s_1$ 的异位词。

#### 复杂度分析

- 时间复杂度：$O(n \log n)$，其中 n 为 $s_1$ 的长度。排序的时间复杂度为 $O(n\log n)$，比较两个字符串是否相等时间复杂度为 O(n)，因此总体时间复杂度为 $O(n \log n+n)=O(n\log n)$。
- 空间复杂度：$O(\log n)$。排序需要 $O(\log n)$ 的空间复杂度。注意，在某些语言（比如 Java & JavaScript）中字符串是不可变的，因此我们需要额外的 O(n) 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：

  - 这依赖于语言的细节；
  - 这取决于函数的设计方式，例如，可以将函数参数类型更改为 char[]。

### 哈希表

```c++
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        vector<int> table(128, 0);
        for (auto& ch: s1) {
            table[ch]++;
        }
        for (auto& ch: s2) {
            table[ch]--;
            if (table[ch] < 0) {
                return false;
            }
        }
        return true;
    }
};
```

```java
class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        int[] table = new int[128];
        for (int i = 0; i < s1.length(); i++) {
            table[s1.charAt(i)]++;
        }
        for (int i = 0; i < s2.length(); i++) {
            table[s2.charAt(i)]--;
            if (table[s2.charAt(i)] < 0) {
                return false;
            }
        }
        return true;
    }
}
```

从另一个角度考虑，字符串 $s_1$ 和 $s_2$ 互为字符重排等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含 128 种不同的字符，因此我们可以维护一个长度为 128 的频次数组 $\textit{table}$，先遍历记录字符串 $s_1$ 中字符出现的频次，然后遍历字符串 $s_2$，减去$ \textit{table}$中对应的频次，如果出现 $\textit{table}[i]<0$，则说明$ s_2$ 包含一个不在 $s_1$ 中的额外字符，返回 $\text{false}$即可。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为 $s_1$的长度。
- 空间复杂度：O(S)，其中 S 为字符集大小，此处 S=128。


