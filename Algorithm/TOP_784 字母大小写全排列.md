# 题目

给定一个字符串 `s` ，通过将字符串 `s` 中的每个字母转变大小写，我们可以获得一个新的字符串。

返回 *所有可能得到的字符串集合* 。以 **任意顺序** 返回输出。

**示例 1：**

```
输入：s = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]
```

**示例 2:**

```
输入: s = "3z4"
输出: ["3z4","3Z4"]
```

**提示:**

- `1 <= s.length <= 12`
- `s` 由小写英文字母、大写英文字母和数字组成

## 我的解法

第一反应dfs，理解其他更优秀的解法！

```python
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        ans = []
        sList = list(s)
        def dfs(sList, i):
            if len(sList) == i:
                ans.append("".join(sList))
                return
            if sList[i].isalpha():
                dfs(sList, i + 1)
                if sList[i].islower():
                    sList[i] =  sList[i].upper()
                    dfs(sList, i + 1)
                else:
                    sList[i] =  sList[i].lower()
                    dfs(sList, i + 1)
            else:
                dfs(sList, i + 1)
        dfs(sList, 0)
        return ans
```

## 其它解法

### 广度优先搜索

```c++
class Solution {
public:
    vector<string> letterCasePermutation(string s) {
        vector<string> ans;
        queue<string> qu;
        qu.emplace("");
        while (!qu.empty()) {
            string &curr = qu.front();
            if (curr.size() == s.size()) {
                ans.emplace_back(curr);
                qu.pop();
            } else {
                int pos = curr.size();
                if (isalpha(s[pos])) {
                    string next = curr;
                    next.push_back(s[pos] ^ 32);
                    qu.emplace(next);
                }
                curr.push_back(s[pos]);                
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    public List<String> letterCasePermutation(String s) {
        List<String> ans = new ArrayList<String>();
        Queue<StringBuilder> queue = new ArrayDeque<StringBuilder>();
        queue.offer(new StringBuilder());
        while (!queue.isEmpty()) {
            StringBuilder curr = queue.peek();
            if (curr.length() == s.length()) {
                ans.add(curr.toString());
                queue.poll();
            } else {
                int pos = curr.length();
                if (Character.isLetter(s.charAt(pos))) {
                    StringBuilder next = new StringBuilder(curr);
                    next.append((char) (s.charAt(pos) ^ 32));
                    queue.offer(next);
                }
                curr.append(s.charAt(pos));
            }
        }
        return ans;
    }
}
```

```python
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        ans = []
        q = deque([''])
        while q:
            cur = q[0]
            pos = len(cur)
            if pos == len(s):
                ans.append(cur)
                q.popleft()
            else:
                if s[pos].isalpha():
                    q.append(cur + s[pos].swapcase())
                q[0] += s[pos]
        return ans
```

从左往右依次遍历字符，在队列中存储当前为已遍历过字符的字母大小全排列。例如当前字符串为:
$$
s = \text{"abc"}
$$
假设我们当前已经遍历到字符的第 2 个字符 $\text{'b'}$ 时，则此时队列中已经存储的序列为:

$$
\text{"ab"},\text{"Ab"}, \text{"aB"}, \text{"AB"}
$$
当我们遍历下一个字符 c 时：

- 如果 c 为一个数字，则队列中所有的序列的末尾均加上 c，将修改后的序列再次进入到队列中；
- 如果 c 为一个字母，此时我们在上述序列的末尾依次分别加上 c 的小写形式 $\text{lowercase}(c)$ 和 c 的大写形式 $\textit{uppercase}(c)$后，再次将上述数列放入队列；
- 如果队列中当前序列的长度等于 s 的长度，则表示当前序列已经搜索完成，该序列为全排列中的一个合法序列；

由于每个字符的大小写形式刚好差了 32，因此在大小写转换时可以用 $c \oplus 32$ 来进行转换。

#### 复杂度分析

- 时间复杂度：$O(n \times 2^n)$，其中 n 表示字符串的长度。全排列的数目最多为 $2^n$个，每次生成一个新的序列的时间为 O(n)，因此时间复杂度为 $O(n \times 2^n)$。

- 空间复杂度：$O(n \times 2^n)$。其中 n 表示字符串的长度。队列中的元素数目最多为 $2^n$个，每个序列需要的空间为 O(n)，因此空间复杂度为 $O(n \times 2^n)$。


### 回溯

```c++
class Solution {
public:
    void dfs(string &s, int pos, vector<string> &res) {
        while (pos < s.size() && isdigit(s[pos])) {
            pos++;
        }
        if (pos == s.size()) {
            res.emplace_back(s);
            return;
        }
        s[pos] ^= 32;
        dfs(s, pos + 1, res);
        s[pos] ^= 32;
        dfs(s, pos + 1, res);
    }

    vector<string> letterCasePermutation(string s) {
        vector<string> ans;
        dfs(s, 0, ans);
        return ans;
    }
};
```

```java
class Solution {
    public List<String> letterCasePermutation(String s) {
        List<String> ans = new ArrayList<String>();
        dfs(s.toCharArray(), 0, ans);
        return ans;
    }

    public void dfs(char[] arr, int pos, List<String> res) {
        while (pos < arr.length && Character.isDigit(arr[pos])) {
            pos++;
        }
        if (pos == arr.length) {
            res.add(new String(arr));
            return;
        }
        arr[pos] ^= 32;
        dfs(arr, pos + 1, res);
        arr[pos] ^= 32;
        dfs(arr, pos + 1, res);
    }
}
```

```python
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        ans = []
        def dfs(s: List[str], pos: int) -> None:
            while pos < len(s) and s[pos].isdigit():
                pos += 1
            if pos == len(s):
                ans.append(''.join(s))
                return
            dfs(s, pos + 1)
            s[pos] = s[pos].swapcase()
            dfs(s, pos + 1)
            s[pos] = s[pos].swapcase()
        dfs(list(s), 0)
        return ans
```

同样的思路我们还可以采用回溯的思想，从左往右依次遍历字符，当在进行搜索时，搜索到字符串 s 的第 i 个字符 c 时:

- 如果 c 为一个数字，则我们继续检测下一个字符；
- 如果 c 为一个字母，我们将字符中的第 i 个字符 c 改变大小写形式后，往后继续搜索，完成改写形式的子状态搜索后，我们将 c 进行恢复，继续往后搜索；
- 如果当前完成字符串搜索后，则表示当前的子状态已经搜索完成，该序列为全排列中的一个；

由于每个字符的大小写形式刚好差了 32，因此在大小写装换时可以用 $c \oplus 32$ 来进行转换和恢复。

#### 复杂度分析

- 时间复杂度：$O(n \times 2^n)$，其中 n 表示字符串的长度。递归深度最多为 n，所有可能的递归子状态最多为 $2^n$ 个，每次个子状态的搜索时间为 O(n)，因此时间复杂度为 $O(n \times 2^n)$。

- 空间复杂度：$O(n \times 2^n)$。递归深度最多为 n，所有可能的递归子状态最多为 $2^n$ 个，每次个子状态的搜索时间为 O(n)，因此时间复杂度为 $O(n \times 2^n)$。

### 二进制位图

```c++
class Solution {
public:
    vector<string> letterCasePermutation(string s) {
        int n = s.size();
        int m = 0;
        for (auto c : s) {
            if (isalpha(c)) {
                m++;
            }
        }
        vector<string> ans;
        for (int mask = 0; mask < (1 << m); mask++) {
            string str;
            for (int j = 0, k = 0; j < n; j++) {
                if (isalpha(s[j]) && (mask & (1 << k++))) {
                    str.push_back(toupper(s[j]));
                } else {
                    str.push_back(tolower(s[j]));
                }
            }
            ans.emplace_back(str);
        }
        return ans;
    }
};
```

```java
class Solution {
    public List<String> letterCasePermutation(String s) {
        int n = s.length();
        int m = 0;
        for (int i = 0; i < n; i++) {
            if (Character.isLetter(s.charAt(i))) {
                m++;
            }
        }
        List<String> ans = new ArrayList<String>();
        for (int mask = 0; mask < (1 << m); mask++) {
            StringBuilder sb = new StringBuilder();
            for (int j = 0, k = 0; j < n; j++) {
                if (Character.isLetter(s.charAt(j)) && (mask & (1 << k++)) != 0) {
                    sb.append(Character.toUpperCase(s.charAt(j)));
                } else {
                    sb.append(Character.toLowerCase(s.charAt(j)));
                }
            }
            ans.add(sb.toString());
        }
        return ans;
    }
}
```

```python
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        ans = []
        m = sum(c.isalpha() for c in s)
        for mask in range(1 << m):
            t, k = [], 0
            for c in s:
                if c.isalpha():
                    t.append(c.upper() if mask >> k & 1 else c.lower())
                    k += 1
                else:
                    t.append(c)
            ans.append(''.join(t))
        return ans
```

假设字符串 s 有 m 个字母，那么全排列就有 $2^m$个字符串序列，且可以用位掩码 $\textit{bits}$ 唯一地表示一个字符串。

- $\textit{bits}$的第 i 为 0 表示字符串 s 中从左往右第 i 个字母为小写形式；
- $\textit{bits}$的第 i 为 1 表示字符串 s 中从左往右第 i 个字母为大写形式；

我们采用的位掩码只计算字符串 s 中的字母，对于数字则直接跳过，通过位图计算从而构造正确的全排列。我们依次检测字符串第 i 个字符串 c：

- 如果字符串 c 为数字，则我们直接在当前的序列中添加字符串 c；
- 如果字符串 c 为字母，且 c 为字符串中的第 k 个字母，如果掩码 bits 中的第 k 位为 0，则添加字符串 c 的小写形式；如果掩码 bits 中的第 k 位为 1，则添加字符串 c 的大写形式；

#### 复杂度分析

- 时间复杂度：$O(n \times 2^n)$，其中 n 表示字符串的长度。最多有 $2^n$个序列，生成每个序列的时间为 O(n)，总的时间复杂度为 $O(n \times 2^n)$。
- 空间复杂度：O(1)。除返回值以外不需要额外的空间


