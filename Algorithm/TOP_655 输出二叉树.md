# 题目

给你一棵二叉树的根节点 `root` ，请你构造一个下标从 **0** 开始、大小为 `m x n` 的字符串矩阵 `res` ，用以表示树的 **格式化布局** 。构造此格式化布局矩阵需要遵循以下规则：

- 树的 **高度** 为 `height` ，矩阵的行数 `m` 应该等于 `height + 1` 。
- 矩阵的列数 `n` 应该等于 `2height+1 - 1` 。
- **根节点** 需要放置在 **顶行** 的 **正中间** ，对应位置为 `res[0][(n-1)/2]` 。
- 对于放置在矩阵中的每个节点，设对应位置为 `res[r][c]` ，将其左子节点放置在 `res[r+1][c-2height-r-1]` ，右子节点放置在 `res[r+1][c+2height-r-1]` 。
- 继续这一过程，直到树中的所有节点都妥善放置。
- 任意空单元格都应该包含空字符串 `""` 。

返回构造得到的矩阵 `res` 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg)

```
输入：root = [1,2]
输出：
[["","1",""],
 ["2","",""]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg)

```
输入：root = [1,2,3,null,4]
输出：
[["","","","1","","",""],
 ["","2","","","","3",""],
 ["","","4","","","",""]]
```

**提示：**

- 树中节点数在范围 $[1, 2^{10}]$ 内
- `-99 <= Node.val <= 99`
- 树的深度在范围 `[1, 10]` 内

## 我的解法

思路较为清晰！

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def printTree(self, root: Optional[TreeNode]) -> List[List[str]]:
        treeList = []
        q = deque()
        q.append(root)
        m = 0
        while q:
            m += 1
            for i in range(len(q)):
                node = q.popleft()
                print(node)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
        n = 2 ** m - 1
        res = [[""] * n for i in range(m)]

        r = 0
        c = (n - 1) // 2
        res[r][c] = str(root.val)
        q = deque()
        q.append([root, r, c])
        while q:
            for i in range(len(q)):
                node, r, c = q.popleft()
                if node.left:
                    newR = r + 1
                    newC = c - 2 ** (m - r - 2)
                    res[newR][newC] = str(node.left.val)
                    q.append([node.left, newR, newC])
                if node.right:
                    newR = r + 1
                    newC = c + 2 ** (m - r - 2)
                    res[newR][newC] = str(node.right.val)
                    q.append([node.right, newR, newC])
        return res
```

## 其它解法

### 深度优先搜索

```c++
class Solution {
public:
    int calDepth(TreeNode* root) {
        int h = 0;
        if (root->left) {
            h = max(h, calDepth(root->left) + 1);
        }
        if (root->right) {
            h = max(h, calDepth(root->right) + 1);
        }
        return h;
    }

    void dfs(vector<vector<string>>& res, TreeNode* root, int r, int c, const int& height) {
        res[r][c] = to_string(root->val);
        if (root->left) {
            dfs(res, root->left, r + 1, c - (1 << (height - r - 1)), height);
        }
        if (root->right) {
            dfs(res, root->right, r + 1, c + (1 << (height - r - 1)), height);
        }
    }

    vector<vector<string>> printTree(TreeNode* root) {
        int height = calDepth(root);
        int m = height + 1;
        int n = (1 << (height + 1)) - 1;
        vector<vector<string>> res(m, vector<string>(n, ""));
        dfs(res, root, 0, (n - 1) / 2, height);
        return res;
    }
};
```

```java
class Solution {
    public List<List<String>> printTree(TreeNode root) {
        int height = calDepth(root);
        int m = height + 1;
        int n = (1 << (height + 1)) - 1;
        List<List<String>> res = new ArrayList<List<String>>();
        for (int i = 0; i < m; i++) {
            List<String> row = new ArrayList<String>();
            for (int j = 0; j < n; j++) {
                row.add("");
            }
            res.add(row);
        }
        dfs(res, root, 0, (n - 1) / 2, height);
        return res;
    }

    public int calDepth(TreeNode root) {
        int h = 0;
        if (root.left != null) {
            h = Math.max(h, calDepth(root.left) + 1);
        }
        if (root.right != null) {
            h = Math.max(h, calDepth(root.right) + 1);
        }
        return h;
    }

    public void dfs(List<List<String>> res, TreeNode root, int r, int c, int height) {
        res.get(r).set(c, Integer.toString(root.val));
        if (root.left != null) {
            dfs(res, root.left, r + 1, c - (1 << (height - r - 1)), height);
        }
        if (root.right != null) {
            dfs(res, root.right, r + 1, c + (1 << (height - r - 1)), height);
        }
    }
}
```

```python
class Solution:
    def printTree(self, root: Optional[TreeNode]) -> List[List[str]]:
        def calDepth(node: Optional[TreeNode]) -> int:
            return max(calDepth(node.left) + 1 if node.left else 0, calDepth(node.right) + 1 if node.right else 0)
        height = calDepth(root)

        m = height + 1
        n = 2 ** m - 1
        ans = [[''] * n for _ in range(m)]
        def dfs(node: Optional[TreeNode], r: int, c: int) -> None:
            ans[r][c] = str(node.val)
            if node.left:
                dfs(node.left, r + 1, c - 2 ** (height - r - 1))
            if node.right:
                dfs(node.right, r + 1, c + 2 ** (height - r - 1))
        dfs(root, 0, (n - 1) // 2)
        return ans
```

#### 思路与算法

我们可以通过深度优先搜索来解决此题。首先通过深度优先搜索来得到二叉树的高度 $\textit{height}$（注意高度从 0 开始），然后创建一个行数为 $m = \textit{height} + 1$，列数为 $n = 2^{\textit{height} + 1} - 1$ 的答案数组 $\textit{res}$放置节点的值（字符串形式）。根节点的值应当放在当前空间的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分），然后递归地将左子树输出在左下部分空间，右子树输出在右下部分空间即可。

#### 复杂度分析

- 时间复杂度：$O(\textit{height} \times 2^\textit{height})$，其中 $\textit{height}$是二叉树的高度。需要填充 $(\textit{height} + 1) \times (2^{\textit{height} + 1} - 1)$ 的数组。
- 空间复杂度：$O(\textit{height})$，其中 $\textit{height}$是二叉树的高度。空间复杂度主要是递归调用的栈空间，取决于二叉树的高度。注意返回值不计入空间复杂度。


### 广度优先搜索

```c++
class Solution {
public:
    int calDepth(TreeNode* root) {
        int res = -1;
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int len = q.size();
            res++;
            while (len) {
                len--;
                auto t = q.front();
                q.pop();
                if (t->left) {
                    q.push(t->left);
                }
                if (t->right) {
                    q.push(t->right);
                }
            }
        }
        return res;
    }

    vector<vector<string>> printTree(TreeNode* root) {
        int height = calDepth(root);
        int m = height + 1;
        int n = (1 << (height + 1)) - 1;
        vector<vector<string>> res(m, vector<string>(n, ""));
        queue<tuple<TreeNode*, int, int>> q;
        q.push({root, 0, (n - 1) / 2});
        while (!q.empty()) {
            auto t = q.front();
            q.pop();
            int r = get<1>(t), c = get<2>(t);
            res[r][c] = to_string(get<0>(t)->val);
            if (get<0>(t)->left) {
                q.push({get<0>(t)->left, r + 1, c - (1 << (height - r - 1))});
            }
            if (get<0>(t)->right) {
                q.push({get<0>(t)->right, r + 1, c + (1 << (height - r - 1))});
            }
        }
        return res;
    }
};
```

```java
class Solution {
    class Tuple {
        TreeNode node;
        int r;
        int c;

        public Tuple(TreeNode node, int r, int c) {
            this.node = node;
            this.r = r;
            this.c = c;
        }
    }

    public List<List<String>> printTree(TreeNode root) {
        int height = calDepth(root);
        int m = height + 1;
        int n = (1 << (height + 1)) - 1;
        List<List<String>> res = new ArrayList<List<String>>();
        for (int i = 0; i < m; i++) {
            List<String> row = new ArrayList<String>();
            for (int j = 0; j < n; j++) {
                row.add("");
            }
            res.add(row);
        }
        Queue<Tuple> queue = new ArrayDeque<Tuple>();
        queue.offer(new Tuple(root, 0, (n - 1) / 2));
        while (!queue.isEmpty()) {
            Tuple t = queue.poll();
            TreeNode node = t.node;
            int r = t.r, c = t.c;
            res.get(r).set(c, Integer.toString(node.val));
            if (node.left != null) {
                queue.offer(new Tuple(node.left, r + 1, c - (1 << (height - r - 1))));
            }
            if (node.right != null) {
                queue.offer(new Tuple(node.right, r + 1, c + (1 << (height - r - 1))));
            }
        }
        return res;
    }

    public int calDepth(TreeNode root) {
        int res = -1;
        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int len = queue.size();
            res++;
            while (len > 0) {
                len--;
                TreeNode t = queue.poll();
                if (t.left != null) {
                    queue.offer(t.left);
                }
                if (t.right != null) {
                    queue.offer(t.right);
                }
            }
        }
        return res;
    }
}
```

```python
class Solution:
    def printTree(self, root: Optional[TreeNode]) -> List[List[str]]:
        def calDepth(root: Optional[TreeNode]) -> int:
            h = -1
            q = [root]
            while q:
                h += 1
                tmp = q
                q = []
                for node in tmp:
                    if node.left:
                        q.append(node.left)
                    if node.right:
                        q.append(node.right)
            return h
        height = calDepth(root)

        m = height + 1
        n = 2 ** m - 1
        ans = [[''] * n for _ in range(m)]
        q = deque([(root, 0, (n - 1) // 2)])
        while q:
            node, r, c = q.popleft()
            ans[r][c] = str(node.val)
            if node.left:
                q.append((node.left, r + 1, c - 2 ** (height - r - 1)))
            if node.right:
                q.append((node.right, r + 1, c + 2 ** (height - r - 1)))
        return ans
```

#### 思路与算法

我们也可以通过广度优先搜索来解决此题。首先通过广度优先搜索来得到二叉树的高度 $\textit{height}$，然后创建一个行数为$ m = \textit{height} + 1$，列数为 $n = 2^{\textit{height} + 1} - 1$ 的答案数组 $\textit{res}$放置节点的值（字符串形式）。使用广度优先搜索遍历每一个节点时，记录每一个节点对应的放置空间，每一个节点的值放置在对应空间的第一行正中间，然后其所在的行和列会将剩余空间划分为两部分（左下部分和右下部分），并把它的非空左子节点和非空右子节点以及它们的对应的放置空间放入队列即可。特别地，根节点的放置空间为整个$ \textit{res}$数组。

#### 复杂度分析

- 时间复杂度：$O(\textit{height} \times 2^\textit{height})$，其中 $\textit{height}$是二叉树的高度。需要填充 $(\textit{height} + 1) \times (2^{\textit{height} + 1} - 1)$ 的数组。
- 空间复杂度：$O(2^\textit{height})$，其中 $\textit{height}$是二叉树的高度。空间复杂度主要是队列空间，队列中的元素个数不超过二叉树的节点个数，为 $O(2^\textit{height})$。注意返回值不计入空间复杂度。

