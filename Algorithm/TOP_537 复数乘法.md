# 题目

[复数](https://baike.baidu.com/item/复数/254365?fr=aladdin) 可以用字符串表示，遵循 `"**实部**+**虚部**i"` 的形式，并满足下述条件：

- `实部` 是一个整数，取值范围是 `[-100, 100]`
- `虚部` 也是一个整数，取值范围是 `[-100, 100]`
- `i2 == -1`

给你两个字符串表示的复数 `num1` 和 `num2` ，请你遵循复数表示形式，返回表示它们乘积的字符串。

**示例 1：**

```
输入：num1 = "1+1i", num2 = "1+1i"
输出："0+2i"
解释：(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。
```

**示例 2：**

```
输入：num1 = "1+-1i", num2 = "1+-1i"
输出："0+-2i"
解释：(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 
```

**提示：**

- `num1` 和 `num2` 都是有效的复数表示。

## 我的解法

有思路，但是没有认真读题，把题目复杂化了！

```python
class Solution:
    def complexNumberMultiply(self, num1: str, num2: str) -> str:
        real1, plural1 = map(int, num1[:-1].split('+'))
        real2, plural2 = map(int, num2[:-1].split('+'))
        return f'{real1 * real2 - plural1 * plural2}+{real1 * plural2 + plural1 * real2}i'
```

## 其他解法

### 模拟

```c++
class Solution {
public:
    string complexNumberMultiply(string num1, string num2) {
        regex re("\\+|i"); 
        vector<string> complex1(sregex_token_iterator(num1.begin(), num1.end(), re, -1), std::sregex_token_iterator());
        vector<string> complex2(sregex_token_iterator(num2.begin(), num2.end(), re, -1), std::sregex_token_iterator());
        int real1 = stoi(complex1[0]);
        int imag1 = stoi(complex1[1]);
        int real2 = stoi(complex2[0]);
        int imag2 = stoi(complex2[1]);
        return to_string(real1 * real2 - imag1 * imag2) + "+" + to_string(real1 * imag2 + imag1 * real2) + "i";
    }
};
```

```java
class Solution {
    public String complexNumberMultiply(String num1, String num2) {
        String[] complex1 = num1.split("\\+|i");
        String[] complex2 = num2.split("\\+|i");
        int real1 = Integer.parseInt(complex1[0]);
        int imag1 = Integer.parseInt(complex1[1]);
        int real2 = Integer.parseInt(complex2[0]);
        int imag2 = Integer.parseInt(complex2[1]);
        return String.format("%d+%di", real1 * real2 - imag1 * imag2, real1 * imag2 + imag1 * real2);
    }
}
```

```python
class Solution:
    def complexNumberMultiply(self, num1: str, num2: str) -> str:
        real1, imag1 = map(int, num1[:-1].split('+'))
        real2, imag2 = map(int, num2[:-1].split('+'))
        return f'{real1 * real2 - imag1 * imag2}+{real1 * imag2 + imag1 * real2}i'
```

复数可以写成 $a + b\mathrm{i}$ 的形式，其中 $a,b \in \mathbb{R}$，a 是实部，b 是虚部，$\mathrm{i}$ 是虚数单位，$\mathrm{i}^2 = -1$。

对于给定的两个复数 $\textit{num}_1$和 $\textit{num}_2$，首先分别得到两个复数的实部和虚部，然后计算两个复数的乘法。用 $\textit{real}_1$ 和 $\textit{imag}_1$分别表示 $\textit{num}_1$的实部和虚部，用 $\textit{real}_2$和 $\textit{imag}_2$分别表示 $\textit{num}_2$的实部和虚部，则两个复数的乘法计算如下：
$$
\begin{aligned} \quad~ &~(\textit{real}_1 + \textit{imag}_1 \times \mathrm{i}) \times (\textit{real}_2 + \textit{imag}_2 \times \mathrm{i}) \\ = &~\textit{real}_1 \times \textit{real}_2 + \textit{real}_1 \times \textit{imag}_2 \times \mathrm{i} + \textit{imag}_1 \times \textit{real}_2 \times \mathrm{i} + \textit{imag}_1 \times \textit{imag}_2 \times \mathrm{i}^2 \\ = &~\textit{real}_1 \times \textit{real}_2 + \textit{real}_1 \times \textit{imag}_2 \times \mathrm{i} + \textit{imag}_1 \times \textit{real}_2 \times \mathrm{i} - \textit{imag}_1 \times \textit{imag}_2 \\ = &~(\textit{real}_1 \times \textit{real}_2 - \textit{imag}_1 \times \textit{imag}_2) + (\textit{real}_1 \times \textit{imag}_2 + \textit{imag}_1 \times \textit{real}_2) \times \mathrm{i} \end{aligned}
$$
得到两个复数的乘积之后，将乘积转换成复数格式的字符串并返回。

#### **复杂度分析**

- 时间复杂度：O(1)。由于两个复数字符串的长度都很小，因此可以将字符串处理的时间视为常数。
- 空间复杂度：O(1)。

## 大佬的解法

```c++
class Solution {
public:
    string complexNumberMultiply(string a, string b) {
        
        int a1, b1, a2, b2;
        sscanf(a.c_str(), "%d+%di", &a1, &b1);
        sscanf(b.c_str(), "%d+%di", &a2, &b2);
        
        int aa = a1 * a2 - b1 * b2;
        int bb = a1 * b2 + a2 * b1;
        
        return string(to_string(aa) + "+" + to_string(bb) + "i");
    }
};
```

