# 题目

你有一个单词列表 `words` 和一个模式 `pattern`，你想知道 `words` 中的哪些单词与模式匹配。

如果存在字母的排列 `p` ，使得将模式中的每个字母 `x` 替换为 `p(x)` 之后，我们就得到了所需的单词，那么单词与模式是匹配的。

*（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）*

返回 `words` 中与给定模式匹配的单词列表。

你可以按任何顺序返回答案。

**示例：**

```
输入：words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
输出：["mee","aqq"]
解释：
"mee" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。
"ccc" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。
因为 a 和 b 映射到同一个字母。
```

**提示：**

- `1 <= words.length <= 50`
- `1 <= pattern.length = words[i].length <= 20`

## 我的解法

将所有的单词转换成唯一的数字特征，查看特征是否一致！

```python
class Solution:
    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        def numPatter(p):
            map = {}
            num = 1
            s = []
            for i in p:
                if i in map:
                    s.append(map[i])
                else:
                    map[i] = str(num)
                    s.append(map[i])
                    num += 1
            return s 
        pat = numPatter(pattern)
        print(pat)
        ans = []
        for word in words:
            print(numPatter(word))
            if numPatter(word) == pat:
                ans.append(word)
        return ans
```

## 其他解法

### 构造双射

```c++
class Solution {
    bool match(string &word, string &pattern) {
        unordered_map<char, char> mp;
        for (int i = 0; i < word.length(); ++i) {
            char x = word[i], y = pattern[i];
            if (!mp.count(x)) {
                mp[x] = y;
            } else if (mp[x] != y) { // word 中的同一字母必须映射到 pattern 中的同一字母上
                return false;
            }
        }
        return true;
    }

public:
    vector<string> findAndReplacePattern(vector<string> &words, string &pattern) {
        vector<string> ans;
        for (auto &word: words) {
            if (match(word, pattern) && match(pattern, word)) {
                ans.emplace_back(word);
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    public List<String> findAndReplacePattern(String[] words, String pattern) {
        List<String> ans = new ArrayList<String>();
        for (String word : words) {
            if (match(word, pattern) && match(pattern, word)) {
                ans.add(word);
            }
        }
        return ans;
    }

    public boolean match(String word, String pattern) {
        Map<Character, Character> map = new HashMap<Character, Character>();
        for (int i = 0; i < word.length(); ++i) {
            char x = word.charAt(i), y = pattern.charAt(i);
            if (!map.containsKey(x)) {
                map.put(x, y);
            } else if (map.get(x) != y) { // word 中的同一字母必须映射到 pattern 中的同一字母上
                return false;
            }
        }
        return true;
    }
}
```

```python
class Solution:
    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        def match(word: str, pattern: str) -> bool:
            mp = {}
            for x, y in zip(word, pattern):
                if x not in mp:
                    mp[x] = y
                elif mp[x] != y:  # word 中的同一字母必须映射到 pattern 中的同一字母上
                    return False
            return True
        return [word for word in words if match(word, pattern) and match(pattern, word)]
```

我们可以逐个判断 $\textit{words}$中的每个单词 $\textit{word}$是否与 $\textit{pattern}$匹配。

根据题意，我们需要构造从字母到字母的双射，即 $\textit{word}$的每个字母需要映射到 $\textit{pattern}$的对应字母，并且 $\textit{pattern}$的每个字母也需要映射到 $\textit{word}$的对应字母。

我们可以编写一个函数 $\text{match}(\textit{word},\textit{pattern})$，仅当 $\textit{word}$中相同字母映射到 $\textit{pattern}$中的相同字母时返回 $\texttt{true}$。我们可以在遍历这两个字符串的同时，用一个哈希表记录 $\textit{word}$的每个字母 x 需要映射到 $\textit{pattern}$的哪个字母上，如果 x 已有映射，则需要检查对应字母是否相同。

如果 $\text{match}(\textit{word},\textit{pattern})$ 和 $\text{match}(\textit{pattern},\textit{word})$均为 $\texttt{true}$，则表示 $\textit{word}$与 $\textit{pattern}$匹配。

#### 复杂度分析

- 时间复杂度：O(nm)，其中 n 是数组$ \textit{words}$的长度，m 是 $\textit{pattern}$的长度。对于每个 $\textit{word}$需要 O(m) 的时间检查其是否与 $\textit{pattern}$匹配。

- 空间复杂度：O(m)。哈希表需要 O(m)的空间。


