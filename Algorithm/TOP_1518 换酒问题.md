# 	题目

小区便利店正在促销，用 `numExchange` 个空酒瓶可以兑换一瓶新酒。你购入了 `numBottles` 瓶酒。

如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。

请你计算 **最多** 能喝到多少瓶酒。

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/sample_1_1875.png)**

```
输入：numBottles = 9, numExchange = 3
输出：13
解释：你可以用 3 个空酒瓶兑换 1 瓶酒。
所以最多能喝到 9 + 3 + 1 = 13 瓶酒。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/sample_2_1875.png)

```
输入：numBottles = 15, numExchange = 4
输出：19
解释：你可以用 4 个空酒瓶兑换 1 瓶酒。
所以最多能喝到 15 + 3 + 1 = 19 瓶酒。
```

**示例 3：**

```
输入：numBottles = 5, numExchange = 5
输出：6
```

**示例 4：**

```
输入：numBottles = 2, numExchange = 3
输出：2
```

**提示：**

- `1 <= numBottles <= 100`
- `2 <= numExchange <= 100`

## 我的解法

代码有些冗余！

```python
class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        ans = 0
        ans += numBottles
        empty = numBottles
        while empty // numExchange:
            ans += empty // numExchange
            mid = empty // numExchange
            empty = empty % numExchange
            empty += mid
        return ans
```

## 其他解法

记一开始有 *b* 瓶酒，*e* 个空瓶换一瓶酒。

### 模拟

```c++
class Solution {
public:
    int numWaterBottles(int numBottles, int numExchange) {
        int bottle = numBottles, ans = numBottles;
        while (bottle >= numExchange) {
            bottle -= numExchange;
            ++ans;
            ++bottle;
        }
        return ans;
    }
};
```

```java
class Solution {
    public int numWaterBottles(int numBottles, int numExchange) {
        int bottle = numBottles, ans = numBottles;
        while (bottle >= numExchange) {
            bottle -= numExchange;
            ++ans;
            ++bottle;
        }
        return ans;
    }
}
```

```python
class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        bottle, ans = numBottles, numBottles
        while bottle >= numExchange:
            bottle -= numExchange
            ans += 1
            bottle += 1
        return ans
```

#### 思路与算法

首先我们一定可以喝到 b 瓶酒，剩下 b 个空瓶。接下来我们可以拿瓶子换酒，每次拿出 e 个瓶子换一瓶酒，然后再喝完这瓶酒，得到一个空瓶。以此类推，我们可以统计得到答案。

#### 复杂度分析

- 时间复杂度：$O\Big(\dfrac{b}{e}\Big)$。因为 $e \geq 2$，而循环迭代时，每次 b 的变化为 $e - 1$，故这里的渐进上界为 $O\Big(\dfrac{b}{e}\Big)$。
- 空间复杂度：O(1)。


### 数学

```c++
class Solution {
public:
    int numWaterBottles(int numBottles, int numExchange) {
        return numBottles >= numExchange ? (numBottles - numExchange) / (numExchange - 1) + 1 + numBottles : numBottles;
    }
};
```

```java
class Solution {
    public int numWaterBottles(int numBottles, int numExchange) {
        return numBottles >= numExchange ? (numBottles - numExchange) / (numExchange - 1) + 1 + numBottles : numBottles;
    }
}
```

```python
class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        return (numBottles - numExchange) // (numExchange - 1) + 1 + numBottles if numBottles >= numExchange else numBottles
```

#### 思路与算法

第一步，首先我们一定可以喝到 b 瓶酒，剩下 b 个空瓶。

第二步，接下来我们来考虑空瓶换酒，换完再喝，喝完再换的过程——每次换到一瓶酒就意味着多一个空瓶，所以每次损失的瓶子的数量为 $e - 1$，我们要知道这个过程能得到多少瓶酒，即希望知道第一个打破下面这个条件的 n 是多少：

$$
b - n(e - 1) \geq e
$$
即我们要找到最小的 n 使得：

$$
b - n(e - 1) < e
$$
我们得到 $n_{\min} = \lfloor \dfrac{b - e}{e - 1} + 1\rfloor$。

当然我们要特别注意这里的前提条件是 $b \geq e$，试想如果 b < e，没有足够的瓶子再换酒了，就不能进行第二步了。

#### 复杂度分析

- 时间复杂度：O(1)。
- 空间复杂度：O(1)。