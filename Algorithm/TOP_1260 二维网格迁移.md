# 题目

给你一个 `m` 行 `n` 列的二维网格 `grid` 和一个整数 `k`。你需要将 `grid` 迁移 `k` 次。

每次「迁移」操作将会引发下述活动：

- 位于 `grid[i][j]` 的元素将会移动到 `grid[i][j + 1]`。
- 位于 `grid[i][n - 1]` 的元素将会移动到 `grid[i + 1][0]`。
- 位于 `grid[m - 1][n - 1]` 的元素将会移动到 `grid[0][0]`。

请你返回 `k` 次迁移操作后最终得到的 **二维网格**。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e1-1.png)

```
输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[9,1,2],[3,4,5],[6,7,8]]
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e2-1.png)

```
输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
```

**示例 3：**

```
输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
输出：[[1,2,3],[4,5,6],[7,8,9]]
```

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m <= 50`
- `1 <= n <= 50`
- `-1000 <= grid[i][j] <= 1000`
- `0 <= k <= 100`

## 我的解法

用了较为麻烦的思路解了简单的题目，思路还差点没有理清楚！

```python
class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m = len(grid)
        n = len(grid[0])
        row = k // n % m
        col = k % n
        ans = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if (j + col) % n >= col:
                    ans[(i + row) % m][(j + col) % n] = grid[i][j]
                else:
                    ans[(i + row + 1) % m][(j + col) % n] = grid[i][j]
        return ans
```

## 其他解法

### 一维展开

```c++
class Solution {
public:
    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> ret(m, vector<int>(n));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int index1 = (i * n + j + k) % (m * n);
                ret[index1 / n][index1 % n] = grid[i][j];
            }
        }
        return ret;
    }
};
```

```java
class Solution {
    public List<List<Integer>> shiftGrid(int[][] grid, int k) {
        int m = grid.length, n = grid[0].length;
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        for (int i = 0; i < m; i++) {
            List<Integer> row = new ArrayList<Integer>();
            for (int j = 0; j < n; j++) {
                row.add(0);
            }
            ret.add(row);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int index1 = (i * n + j + k) % (m * n);
                ret.get(index1 / n).set(index1 % n, grid[i][j]);
            }
        }
        return ret;
    }
}
```

```python
class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        ans = [[0] * n for _ in range(m)]
        for i, row in enumerate(grid):
            for j, v in enumerate(row):
                index1 = (i * n + j + k) % (m * n)
                ans[index1 // n][index1 % n] = v
        return ans
```

设 m 和 n 分别为网格的行列数，我们将网格 $\textit{grid}$想象成由多个一维数组 $\big \{\textit{grid}[i]; 0 \le i \lt n \big \}$按顺序拼接而成的一维数组，那么元素 $\textit{grid}[i][j]$ 在该一维数组的下标为 $\textit{index} = i \times n + j$。

每次迁移操作都相当于将该一维数组向右循环移动一次，那么 k 次迁移操作之后，元素 $\textit{grid}[i][j]$在该一维数组的下标变为$ \textit{index}_1 = (\textit{index} + k) \bmod (m \times n)$，在网格的位置变为 $\textit{grid}[\Big \lfloor \dfrac{\textit{index}_1}{n} \Big \rfloor][\textit{index}_1 \bmod n]$。

#### **复杂度分析**

- 时间复杂度：O(mn)*O*(*m**n*)，其中 m*m* 和 n*n* 分别为网格的行列数。
- 空间复杂度：O(1)*O*(1)。返回值不计入空间复杂度。