# 题目

给定一个二叉树的根 `root` 和两个整数 `val` 和 `depth` ，在给定的深度 `depth` 处添加一个值为 `val` 的节点行。

注意，根节点 `root` 位于深度 `1` 。

加法规则如下:

- 给定整数 `depth`，对于深度为 `depth - 1` 的每个非空树节点 `cur` ，创建两个值为 `val` 的树节点作为 `cur` 的左子树根和右子树根。
- `cur` 原来的左子树应该是新的左子树根的左子树。
- `cur` 原来的右子树应该是新的右子树根的右子树。
- 如果 `depth == 1 `意味着 `depth - 1` 根本没有深度，那么创建一个树节点，值 `val `作为整个原始树的新根，而原始树就是新根的左子树。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg)

```
输入: root = [4,2,6,3,1,5], val = 1, depth = 2
输出: [4,1,1,2,null,null,6,3,1,5]
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg)

```
输入: root = [4,2,null,3,1], val = 1, depth = 3
输出:  [4,2,null,1,1,3,null,null,1]
```

**提示:**

- 节点数在 `[1, 104]` 范围内
- 树的深度在 `[1, 104]`范围内
- `-100 <= Node.val <= 100`
- `-105 <= val <= 105`
- `1 <= depth <= the depth of tree + 1`

## 我的解法

想了半天，思路不够清晰！

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def addOneRow(self, root: Optional[TreeNode], val: int, depth: int) -> Optional[TreeNode]:
        def insert(node, dep):
            if dep == depth - 1:
                midL = TreeNode(val)
                midL.left = node.left
                node.left = midL
                midR = TreeNode(val)
                midR.right = node.right
                node.right = midR
            else:
                if node.left:
                    insert(node.left, dep + 1)
                if node.right:
                    insert(node.right, dep + 1)
        if depth == 1:
            ans = TreeNode(val)
            ans.left = root
            return ans
        else:
            insert(root, 1)
        return root
```

## 其他句法

### 深度优先搜索

```c++
class Solution {
public:
    TreeNode* addOneRow(TreeNode* root, int val, int depth) {
        if (root == nullptr) {
            return nullptr;
        }
        if (depth == 1) {
            return new TreeNode(val, root, nullptr);
        }
        if (depth == 2) {
            root->left = new TreeNode(val, root->left, nullptr);
            root->right = new TreeNode(val, nullptr, root->right);
        } else {
            root->left = addOneRow(root->left, val, depth - 1);
            root->right = addOneRow(root->right, val, depth - 1);
        }
        return root;
    }
};
```

```java
class Solution {
    public TreeNode addOneRow(TreeNode root, int val, int depth) {
        if (root == null) {
            return null;
        }
        if (depth == 1) {
            return new TreeNode(val, root, null);
        }
        if (depth == 2) {
            root.left = new TreeNode(val, root.left, null);
            root.right = new TreeNode(val, null, root.right);
        } else {
            root.left = addOneRow(root.left, val, depth - 1);
            root.right = addOneRow(root.right, val, depth - 1);
        }
        return root;
    }
}
```

```python
class Solution:
    def addOneRow(self, root: TreeNode, val: int, depth: int) -> TreeNode:
        if root == None:
            return
        if depth == 1:
            return TreeNode(val, root, None)
        if depth == 2:
            root.left = TreeNode(val, root.left, None)
            root.right = TreeNode(val, None, root.right)
        else:
            root.left = self.addOneRow(root.left, val, depth - 1)
            root.right = self.addOneRow(root.right, val, depth - 1)
        return root
```

#### 思路

当输入$ \textit{depth} $为 1 时，需要创建一个新的 $\textit{root}$，并将原 $\textit{root}$作为新 $\textit{root} $的左子节点。当 $\textit{depth}$为 2 时，需要在 $\textit{root}$下新增两个节点 $\textit{left}$和 $\textit{right}$作为 $\textit{root}$的新子节点，并把原左子节点作为 $\textit{left}$的左子节点，把原右子节点作为 $\textit{right}$的右子节点。当$ \textit{depth}$大于 2 时，需要继续递归往下层搜索，并将 $\textit{depth}$减去 1，直到搜索到 $\textit{depth}$为 2。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为输入的树的节点数。最坏情况下，需要遍历整棵树。

- 空间复杂度：O(n)，递归的深度最多为 O(n)。


### 广度优先搜索

```c++
class Solution {
public:
    TreeNode* addOneRow(TreeNode* root, int val, int depth) {
        if (depth == 1) {
            return new TreeNode(val, root, nullptr);
        }
        vector<TreeNode *> curLevel(1, root);
        for (int i = 1; i < depth - 1; i++) {
            vector<TreeNode *> tmpt;
            for (auto &node : curLevel) {
                if (node->left != nullptr) {
                    tmpt.emplace_back(node->left);
                }
                if (node->right != nullptr) {
                    tmpt.emplace_back(node->right);
                }
            }
            curLevel = move(tmpt);
        }
        for (auto &node : curLevel) {
            node->left = new TreeNode(val, node->left, nullptr);
            node->right = new TreeNode(val, nullptr, node->right);
        }
        return root;
    }
};
```

```java
class Solution {
    public TreeNode addOneRow(TreeNode root, int val, int depth) {
        if (depth == 1) {
            return new TreeNode(val, root, null);
        }
        List<TreeNode> curLevel = new ArrayList<TreeNode>();
        curLevel.add(root);
        for (int i = 1; i < depth - 1; i++) {
            List<TreeNode> tmpt = new ArrayList<TreeNode>();
            for (TreeNode node : curLevel) {
                if (node.left != null) {
                    tmpt.add(node.left);
                }
                if (node.right != null) {
                    tmpt.add(node.right);
                }
            }
            curLevel = tmpt;
        }
        for (TreeNode node : curLevel) {
            node.left = new TreeNode(val, node.left, null);
            node.right = new TreeNode(val, null, node.right);
        }
        return root;
    }
}
```

```python
class Solution:
    def addOneRow(self, root: TreeNode, val: int, depth: int) -> TreeNode:
        if depth == 1:
            return TreeNode(val, root, None)
        curLevel = [root]
        for _ in range(1, depth - 1):
            tmpt = []
            for node in curLevel:
                if node.left:
                    tmpt.append(node.left)
                if node.right:
                    tmpt.append(node.right)
            curLevel = tmpt
        for node in curLevel:
            node.left = TreeNode(val, node.left, None)
            node.right = TreeNode(val, None, node.right)
        return root
```

#### 思路

与深度优先搜索类似，我们用广度优先搜索找到要加的一行的上一行，然后对这一行的每个节点 $\textit{node}$，都新增两个节点 $\textit{left}$和 $\textit{right}$作为 $\textit{node}$的新子节点，并把原左子节点作为 $\textit{left}$的左子节点，把原右子节点作为 $\textit{right}$的右子节点。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为输入的树的节点数。最坏情况下，需要遍历整棵树。

- 空间复杂度：O(n)，数组空间开销最多为 O(n)。


