# 题目

有个内含单词的超大文本文件，给定任意两个`不同的`单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?

**示例：**

```
输入：words = ["I","am","a","student","from","a","university","in","a","city"], word1 = "a", word2 = "student"
输出：1
```

提示：

- `words.length <= 100000`

## 我的解法

快速解决，于题解高度一致！

```python
class Solution:
    def findClosest(self, words: List[str], word1: str, word2: str) -> int:
        p1 = -1
        p2 = -1
        ans = float('inf')
        for i, word in enumerate(words):
            if word == word1:
                p1 = i 
            if word == word2:
                p2 = i 
            if p1 >=0 and p2 >= 0:
                mid = abs(p1 - p2)
                ans = min(ans, mid)
        return ans
```

```python
class Solution:
    def findClosest(self, words: List[str], word1: str, word2: str) -> int:
        wordMap = defaultdict(list)
        for i, word in enumerate(words):
                wordMap[word].append(i)

        print(wordMap)
        ans = len(words)
        l1 = wordMap[word1]
        l2 = wordMap[word2]
        p1 = 0
        p2 = 0
        while p1 < len(l1) and p2 < len(l2):
            print(l1[p1], l2[p2])
            mid = abs(l1[p1] - l2[p2])
            ans = min(ans, mid)
            if l1[p1] < l2[p2]:
                p1 += 1
            elif l1[p1] > l2[p2]:
                p2 += 1
        return ans
```

## 其他解法

### 一次遍历

```c++
class Solution {
public:
    int findClosest(vector<string>& words, string word1, string word2) {
        int length = words.size();
        int ans = length;
        int index1 = -1, index2 = -1;
        for (int i = 0; i < length; i++) {
            string word = words[i];
            if (words[i] == word1) {
                index1 = i;
            } else if (words[i] == word2) {
                index2 = i;
            }
            if (index1 >= 0 && index2 >= 0) {
                ans = min(ans, abs(index1 - index2));
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    public int findClosest(String[] words, String word1, String word2) {
        int length = words.length;
        int ans = length;
        int index1 = -1, index2 = -1;
        for (int i = 0; i < length; i++) {
            String word = words[i];
            if (word.equals(word1)) {
                index1 = i;
            } else if (word.equals(word2)) {
                index2 = i;
            }
            if (index1 >= 0 && index2 >= 0) {
                ans = Math.min(ans, Math.abs(index1 - index2));
            }
        }
        return ans;
    }
}
```

```python
class Solution:
    def findClosest(self, words: List[str], word1: str, word2: str) -> int:
        ans = len(words)
        index1, index2 = -1, -1
        for i, word in enumerate(words):
            if word == word1:
                index1 = i
            elif word == word2:
                index2 = i
            if index1 >= 0 and index2 >= 0:
                ans = min(ans, abs(index1 - index2))
        return ans
```

最直观的做法是遍历数组 $\textit{words}$，对于数组中的每个 $\textit{word}_1$，遍历数组 $\textit{words}$找到每个 $\textit{word}_2$并计算距离。该做法在最坏情况下的时间复杂度是 $O(n^2)$，需要优化。

为了降低时间复杂度，需要考虑其他的做法。从左到右遍历数组$ \textit{words}$，当遍历到 $\textit{word}_1$时，如果已经遍历的单词中存在 $\textit{word}_2$，为了计算最短距离，应该取最后一个已经遍历到的 $\textit{word}_2$所在的下标，计算和当前下标的距离。同理，当遍历到$ \textit{word}_2$时，应该取最后一个已经遍历到的 $\textit{word}_1$所在的下标，计算和当前下标的距离。

基于上述分析，可以遍历数组一次得到最短距离，将时间复杂度降低到 O(n)。

用 $\textit{index}_1$和 $\textit{index}_2$分别表示数组 $\textit{words}$已经遍历的单词中的最后一个 $\textit{word}_1$的下标和最后一个 $\textit{word}_2$的下标，初始时 $\textit{index}_1 = \textit{index}_2 = -1$。遍历数组 $\textit{words}$，当遇到 $\textit{word}_1$或 $\textit{word}_2$ 时，执行如下操作：

1. 如果遇到 $\textit{word}_1$，则将 $\textit{index}_1$更新为当前下标；如果遇到 $\textit{word}_2$，则将 $\textit{index}_2$更新为当前下标。
2. 如果 $\textit{index}_1$和 $\textit{index}_2$都非负，则计算两个下标的距离 $|\textit{index}_1 - \textit{index}_2|$，并用该距离更新最短距离。

遍历结束之后即可得到 $\textit{word}_1$和 $\textit{word}_2$ 的最短距离。

#### 复杂度分析

时间复杂度：O(n)，其中 n 是数组 $\textit{words}$的长度。需要遍历数组一次计算 $\textit{word}_1$和 $\textit{word}_2$的最短距离，每次更新下标和更新最短距离的时间都是 O(1)。这里将字符串的长度视为常数。

空间复杂度：O(1)。

#### 进阶问题

如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，则可以维护一个哈希表记录每个单词的下标列表。遍历一次文件，按照下标递增顺序得到每个单词在文件中出现的所有下标。在寻找单词时，只要得到两个单词的下标列表，使用双指针遍历两个下标链表，即可得到两个单词的最短距离。

