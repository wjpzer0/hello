# 题目

给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。

**注意：**
数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。

**示例:**

```
int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。
solution.pick(3);

// pick(1) 应该返回 0。因为只有nums[0]等于1。
solution.pick(1);
```

## 我的解法

嗯！字典！理解水塘抽样！

```python
class Solution:

    def __init__(self, nums: List[int]):
        self.map = defaultdict(list)
        for i, num in enumerate(nums):
            self.map[num].append(i)


    def pick(self, target: int) -> int:
        ls = self.map[target]
        n = len(ls)
        choice = random. randint(0, n - 1)
        return ls[choice]

# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.pick(target) 
```

## 其他解法

### 哈希表

```c++
class Solution {
    unordered_map<int, vector<int>> pos;
public:
    Solution(vector<int> &nums) {
        for (int i = 0; i < nums.size(); ++i) {
            pos[nums[i]].push_back(i);
        }
    }

    int pick(int target) {
        auto &indices = pos[target];
        return indices[rand() % indices.size()];
    }
};
```

```java
class Solution {
    Map<Integer, List<Integer>> pos;
    Random random;

    public Solution(int[] nums) {
        pos = new HashMap<Integer, List<Integer>>();
        random = new Random();
        for (int i = 0; i < nums.length; ++i) {
            pos.putIfAbsent(nums[i], new ArrayList<Integer>());
            pos.get(nums[i]).add(i);
        }
    }

    public int pick(int target) {
        List<Integer> indices = pos.get(target);
        return indices.get(random.nextInt(indices.size()));
    }
}
```

```python
class Solution:
    def __init__(self, nums: List[int]):
        self.pos = defaultdict(list)
        for i, num in enumerate(nums):
            self.pos[num].append(i)

    def pick(self, target: int) -> int:
        return choice(self.pos[target])
```

如果不考虑数组的大小，我们可以在构造函数中，用一个哈希表 $\textit{pos}$记录 $\textit{nums}$中相同元素的下标。

对于 $\text{pick}$操作，我们可以从 $\textit{pos}$中取出 $\textit{target}$对应的下标列表，然后随机选择其中一个下标并返回。

#### 复杂度分析

- 时间复杂度：初始化为 O(n)，$\text{pick}$为 O(1)，其中 n 是 $\textit{nums}$的长度。

- 空间复杂度：O(n)。我们需要 O(n) 的空间存储 n 个下标。


### 水塘抽样

```c++
class Solution {
    vector<int> &nums;
public:
    Solution(vector<int> &nums) : nums(nums) {}

    int pick(int target) {
        int ans;
        for (int i = 0, cnt = 0; i < nums.size(); ++i) {
            if (nums[i] == target) {
                ++cnt; // 第 cnt 次遇到 target
                if (rand() % cnt == 0) {
                    ans = i;
                }
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    int[] nums;
    Random random;

    public Solution(int[] nums) {
        this.nums = nums;
        random = new Random();
    }

    public int pick(int target) {
        int ans = 0;
        for (int i = 0, cnt = 0; i < nums.length; ++i) {
            if (nums[i] == target) {
                ++cnt; // 第 cnt 次遇到 target
                if (random.nextInt(cnt) == 0) {
                    ans = i;
                }
            }
        }
        return ans;
    }
}
```

```python
class Solution:
    def __init__(self, nums: List[int]):
        self.nums = nums

    def pick(self, target: int) -> int:
        ans = cnt = 0
        for i, num in enumerate(self.nums):
            if num == target:
                cnt += 1  # 第 cnt 次遇到 target
                if randrange(cnt) == 0:
                    ans = i
        return ans
```

如果数组以文件形式存储（读者可假设构造函数传入的是个文件路径），且文件大小远超内存大小，我们是无法通过读文件的方式，将所有下标保存在内存中的，因此需要找到一种空间复杂度更低的算法。

我们可以设计如下算法实现 $\text{pick}$操作：

遍历 $\textit{nums}$，当我们第 i 次遇到值为 $\textit{target}$的元素时，随机选择区间 [0,i) 内的一个整数，如果其等于 0，则将返回值置为该元素的下标，否则返回值不变。

设 $\textit{nums}$中有 k 个值为 $\textit{target}$的元素，该算法会保证这 k 个元素的下标成为最终返回值的概率均为 $\dfrac{1}{k}$  ，证明如下：

$$
\begin{aligned} &P(第\ i\ 次遇到值为\ \textit{target}\ \ 的元素的下标成为最终返回值)\\ =&P(第\ i\ 次随机选择的值= 0) \times P(第\ i+1\ 次随机选择的值\ne 0) \times \cdots \times P(第\ k\ 次随机选择的值\ne 0)\\ =&\dfrac{1}{i} \times (1-\dfrac{1}{i+1}) \times \cdots \times (1-\dfrac{1}{k})\\ =&\dfrac{1}{i} \times \dfrac{i}{i+1} \times \cdots \times \dfrac{k-1}{k}\\ =&\dfrac{1}{k} \end{aligned}
$$

#### **复杂度分析**

- 时间复杂度：初始化为 O(1)，$\text{pick}$为 O(n)，其中 n 是 $\textit{nums}$的长度。
- 空间复杂度：O(1)。我们只需要常数的空间保存若干变量。


