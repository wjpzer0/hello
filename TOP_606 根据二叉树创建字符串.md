# 题目

你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。

空节点则用一对空括号 "()" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

**示例 1:**

```
输入: 二叉树: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

输出: "1(2(4))(3)"

解释: 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。
```

**示例 2:**

```
输入: 二叉树: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

输出: "1(2()(4))(3)"

解释: 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。
```

## 我的解法

没毛病，代码可以优化！

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def tree2str(self, root: Optional[TreeNode]) -> str:
        self.ans = "" 
        def dfs(node):
            if node == None:
                return
            self.ans += "(" + str(node.val)
            if node.left == None and node.right != None:
                self.ans += "()"
            dfs(node.left)
            dfs(node.right)
            self.ans += ")"
            return 
        dfs(root)
        n = len(self.ans)
        return self.ans[1:n - 1]
```

## 其他解法

### 递归

```c++
class Solution {
public:
    string tree2str(TreeNode *root) {
        if (root == nullptr) {
            return "";
        }
        if (root->left == nullptr && root->right == nullptr) {
            return to_string(root->val);
        }
        if (root->right == nullptr) {
            return to_string(root->val) + "(" + tree2str(root->left) + ")";
        }
        return to_string(root->val) + "(" + tree2str(root->left) + ")(" + tree2str(root->right) + ")";
    }
};
```

```java
class Solution {
    public String tree2str(TreeNode root) {
        if (root == null) {
            return "";
        }
        if (root.left == null && root.right == null) {
            return Integer.toString(root.val);
        }
        if (root.right == null) {
            return new StringBuffer().append(root.val).append("(").append(tree2str(root.left)).append(")").toString();
        }
        return new StringBuffer().append(root.val).append("(").append(tree2str(root.left)).append(")(").append(tree2str(root.right)).append(")").toString();
    }
}
```

```python
class Solution:
    def tree2str(self, root: Optional[TreeNode]) -> str:
        if root is None:
            return ""
        if root.left is None and root.right is None:
            return str(root.val)
        if root.right is None:
            return f"{root.val}({self.tree2str(root.left)})"
        return f"{root.val}({self.tree2str(root.left)})({self.tree2str(root.right)})"
```

我们可以使用递归的方法得到二叉树的前序遍历，并在递归时加上额外的括号。

会有以下 4 种情况：

- 如果当前节点有两个孩子，那我们在递归时，需要在两个孩子的结果外都加上一层括号；

- 如果当前节点没有孩子，那我们不需要在节点后面加上任何括号；

  ![No_child](https://pic.leetcode-cn.com/Figures/606/606_Case2.PNG)

- 如果当前节点只有左孩子，那我们在递归时，只需要在左孩子的结果外加上一层括号，而不需要给右孩子加上任何括号；

  ![Left_child](https://pic.leetcode-cn.com/Figures/606/606_Case3.PNG)

- 如果当前节点只有右孩子，那我们在递归时，需要先加上一层空的括号 $\text{`()`}$ 表示左孩子为空，再对右孩子进行递归，并在结果外加上一层括号。

  ![Right_child](https://pic.leetcode-cn.com/Figures/606/606_Case4.PNG)


考虑完上面的 4 种情况，我们就可以得到最终的字符串。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是二叉树中的节点数目。

- 空间复杂度：O(n)。在最坏情况下会递归 n 层，需要 O(n) 的栈空间。

### 迭代

```c++
class Solution {
public:
    string tree2str(TreeNode *root) {
        string ans = "";
        stack<TreeNode *> st;
        st.push(root);
        unordered_set<TreeNode *> vis;
        while (!st.empty()) {
            auto node = st.top();
            if (vis.count(node)) {
                if (node != root) {
                    ans += ")";
                }
                st.pop();
            } else {
                vis.insert(node);
                if (node != root) {
                    ans += "(";
                }
                ans += to_string(node->val);
                if (node->left == nullptr && node->right != nullptr) {
                    ans += "()";
                }
                if (node->right != nullptr) {
                    st.push(node->right);
                }
                if (node->left != nullptr) {
                    st.push(node->left);
                }
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    public String tree2str(TreeNode root) {
        StringBuffer ans = new StringBuffer();
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        stack.push(root);
        Set<TreeNode> visited = new HashSet<TreeNode>();
        while (!stack.isEmpty()) {
            TreeNode node = stack.peek();
            if (!visited.add(node)) {
                if (node != root) {
                    ans.append(")");
                }
                stack.pop();
            } else {
                if (node != root) {
                    ans.append("(");
                }
                ans.append(node.val);
                if (node.left == null && node.right != null) {
                    ans.append("()");
                }
                if (node.right != null) {
                    stack.push(node.right);
                }
                if (node.left != null) {
                    stack.push(node.left);
                }
            }
        }
        return ans.toString();
    }
}
```

```python
class Solution:
    def tree2str(self, root: Optional[TreeNode]) -> str:
        ans = ""
        st = [root]
        vis = set()
        while st:
            node = st[-1]
            if node in vis:
                if node != root:
                    ans += ")"
                st.pop()
            else:
                vis.add(node)
                if node != root:
                    ans += "("
                ans += str(node.val)
                if node.left is None and node.right:
                    ans += "()"
                if node.right:
                    st.append(node.right)
                if node.left:
                    st.append(node.left)
        return ans
```

我们也可以使用迭代的方法得到二叉树的前序遍历，并在迭代时加上额外的括号。

用一个栈来存储树中的一些节点，其中栈顶的元素为当前遍历到的节点，从栈底到栈顶的节点为从根到当前节点的唯一路径上的节点。和迭代得到前序遍历的方法略有不同，由于这里需要输出额外的括号，因此我们还需要用一个集合存储所有遍历过的节点，理由见下文。

首先我们把根节点入栈。对于当前栈顶的元素，如果它没有遍历过，那么就把它加入到集合中，并开始对以它为根的子树进行前序遍历。我们先在答案末尾添加一个 \text{`('}‘(’，表示一个节点的开始，然后判断该节点的子节点个数。

和方法一相同，这里会出现四种情况：

如果当前节点有两个孩子，那么我们先将右孩子入栈，再将左孩子入栈，从而保证前序遍历的顺序；

如果当前节点没有孩子，我们什么都不做；

如果当前节点只有左孩子，那么我们将左孩子入栈；

如果当前节点只有右孩子，那么需要在答案末尾添加一对 $\text{`()`}$表示空的左孩子，再将右孩子入栈。

注意这四种情况中，我们都不会将当前节点出栈，原因是我们一开始添加了 $\text{`(`}$ 表示节点的开始，在以当前节点为根的子树中所有节点遍历完成之后，我们才会在答案末尾添加 $\text{`)`}$ 表示节点的结束。因此我们需要用上面提到的集合来存储遍历过的节点，如果当前栈顶的元素遍历过，那么就需要在答案末尾添加$ \text{`)`}$ ，并将这个节点出栈。

![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide1.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide2.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide3.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide4.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide5.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide6.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide7.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide8.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide9.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide10.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide11.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide12.PNG)
![img](https://pic.leetcode-cn.com/Figures/606/Construct_Binary_Tree_stackSlide13.PNG)

#### **复杂度分析**

- 时间复杂度：O(n)，其中 n 是二叉树中的节点数目。
- 空间复杂度：O(n)。哈希表和栈需要 O(n)的空间。