# 题目

给你一个整数数组 `nums`，将 `nums` 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。

返回满足此条件的 **任一数组** 作为答案。

**示例 1：**

```
输入：nums = [3,1,2,4]
输出：[2,4,3,1]
解释：[4,2,3,1]、[2,4,1,3] 和 [4,2,1,3] 也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0]
输出：[0]
```

**提示：**

- `1 <= nums.length <= 5000`
- `0 <= nums[i] <= 5000`

## 我的解法

思路正确，解法优雅，代码不够优雅！

```python
class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        n = len(nums)
        left = 0
        right = n -1
        while left < right:
            if nums[left] % 2 == 0:
                left += 1
            else:
                if nums[right] % 2 == 0:
                    nums[right], nums[left] = nums[left], nums[right]
                else:
                    right -= 1
        return nums
```

## 其他解法

### 两次遍历

```c++
class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& nums) {
        vector<int> res;
        for (auto & num : nums) {
            if (num % 2 == 0) {
                res.push_back(num);
            }
        }
        for (auto & num : nums) {
            if (num % 2 == 1) {
                res.push_back(num);
            }
        }
        return res;
    }
};
```

```java
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int n = nums.length, index = 0;
        int[] res = new int[n];
        for (int num : nums) {
            if (num % 2 == 0) {
                res[index++] = num;
            }
        }
        for (int num : nums) {
            if (num % 2 == 1) {
                res[index++] = num;
            }
        }
        return res;
    }
}
```

```python
class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        return [num for num in nums if num % 2 == 0] + [num for num in nums if num % 2 == 1]
```

#### 思路

新建一个数组 $\textit{res}$用来保存排序完毕的数组。遍历两次 $\textit{nums}$，第一次遍历时把所有偶数依次追加到 $\textit{res}$中，第二次遍历时把所有奇数依次追加到 $\textit{res}$中。

#### 复杂度分析

时间复杂度：O(n)，其中 n 为数组 $\textit{nums}$的长度。需遍历 $\textit{nums}$两次次。

空间复杂度：O(1)。结果不计入空间复杂度。

### 双指针 + 一次遍历

```c++
class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        int left = 0, right = n - 1;
        for (auto & num : nums) {
            if (num % 2 == 0) {
                res[left++] = num;
            } else {
                res[right--] = num;
            }
        }
        return res;
    }
};
```

```java
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        int left = 0, right = n - 1;
        for (int num : nums) {
            if (num % 2 == 0) {
                res[left++] = num;
            } else {
                res[right--] = num;
            }
        }
        return res;
    }
}
```

```python
class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res, left, right = [0] * n, 0, n - 1
        for num in nums:
            if num % 2 == 0:
                res[left] = num
                left += 1
            else:
                res[right] = num
                right -= 1
        return res
```

#### 思路

记数组 $\textit{nums}$的长度为 n。方法一需要遍历两次 $\textit{nums}$，第一次遍历时遇到奇数会跳过，第二次遍历时遇到偶数会跳过，这部分可以优化。

新建一个长度为 n 的数组 $\textit{res}$用来保存排完序的数组。遍历一遍 $\textit{nums}$，遇到偶数则从 $\textit{res}$左侧开始替换元素，遇到奇数则从 $\textit{res}$右侧开始替换元素。遍历完成后，$\textit{res}$就保存了排序完毕的数组。

#### 复杂度分析

时间复杂度：O(n)，其中 n 为数组 $\textit{nums}$的长度。只需遍历 $\textit{nums}$一次。

空间复杂度：O(1)。结果不计入空间复杂度。

### 原地交换

```c++
class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            while (left < right and nums[left] % 2 == 0) {
                left++;
            }
            while (left < right and nums[right] % 2 == 1) {
                right--;
            }
            if (left < right) {
                swap(nums[left++], nums[right--]);
            }
        }
        return nums;
    }
};
```

```java
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            while (left < right && nums[left] % 2 == 0) {
                left++;
            }
            while (left < right && nums[right] % 2 == 1) {
                right--;
            }
            if (left < right) {
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
                right--;
            }
        }
        return nums;
    }
}
```

```python
class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        left, right = 0, len(nums) - 1
        while left < right:
            while left < right and nums[left] % 2 == 0:
                left += 1
            while left < right and nums[right] % 2 == 1:
                right -= 1
            if left < right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1
        return nums
```

#### 思路

记数组 $\textit{nums}$的长度为 n。先从 $\textit{nums}$左侧开始遍历，如果遇到的是偶数，就表示这个元素已经排好序了，继续从左往右遍历，直到遇到一个奇数。然后从 $\textit{nums}$右侧开始遍历，如果遇到的是奇数，就表示这个元素已经排好序了，继续从右往左遍历，直到遇到一个偶数。交换这个奇数和偶数的位置，并且重复两边的遍历，直到在中间相遇，$\textit{nums}$排序完毕。

#### **复杂度分析**

- 时间复杂度：O(n)。原数组中每个元素只遍历一次。
- 空间复杂度：O(1)。原地排序，只消耗常数空间。