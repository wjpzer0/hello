# 题目

**n 位格雷码序列** 是一个由 `2n` 个整数组成的序列，其中：

- 每个整数都在范围 `[0, 2n - 1]` 内（含 `0` 和 `2n - 1`）
- 第一个整数是 `0`
- 一个整数在序列中出现 **不超过一次**
- 每对 **相邻** 整数的二进制表示 **恰好一位不同** ，且
- **第一个** 和 **最后一个** 整数的二进制表示 **恰好一位不同**

给你一个整数 `n` ，返回任一有效的 **n 位格雷码序列** 。

**示例 1：**

```
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
```

**示例 2：**

```
输入：n = 1
输出：[0,1]
```

**提示：**

- `1 <= n <= 16`

## 我的解法

未想出，查看题解的解法，但是没有理解为什么要这样做！

```java
关键是搞清楚格雷编码的生成过程, G(i) = i ^ (i/2);
如 n = 3: 
G(0) = 000, 
G(1) = 1 ^ 0 = 001 ^ 000 = 001
G(2) = 2 ^ 1 = 010 ^ 001 = 011 
G(3) = 3 ^ 1 = 011 ^ 001 = 010
G(4) = 4 ^ 2 = 100 ^ 010 = 110
G(5) = 5 ^ 2 = 101 ^ 010 = 111
G(6) = 6 ^ 3 = 110 ^ 011 = 101
G(7) = 7 ^ 3 = 111 ^ 011 = 100
```

```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        ans = []
        for i in range(1 << n):
            ans.append(i ^ i >> 1)
        return ans        
```

### 递归生成码表

这种方法基于格雷码是反射码的事实，利用递归的如下规则来构造：

1. 1位格雷码有两个码字
2. (n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0
3. (n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1 [4] 
4. n+1位格雷码的集合 = n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1

| 2位格雷码 | 3位格雷码 | 4位格雷码 | 4位自然二进制码 |
| --------- | --------- | --------- | --------------- |
| 00        | 000       | 0000      | 0000            |
| 01        | 001       | 0001      | 0001            |
| 11        | 011       | 0011      | 0010            |
| 10        | 010       | 0010      | 0011            |
|           | 110       | 0110      | 0100            |
|           | 111       | 0111      | 0101            |
|           | 101       | 0101      | 0110            |
|           | 100       | 0100      | 0111            |
|           |           | 1100      | 1000            |
|           |           | 1101      | 1001            |
|           |           | 1111      | 1010            |
|           |           | 1110      | 1011            |
|           |           | 1010      | 1100            |
|           |           | 1011      | 1101            |
|           |           | 1001      | 1110            |
|           |           | 1000      | 1111            |
|           |           |           |                 |

### 异或转换

**二进制码→格雷码（编码）**：

此方法从对应的n位二进制码字中直接得到n位格雷码码字，步骤如下：

1. 对n位二进制的码字，从右到左，以0到n-1编号
2. 如果二进制码字的第i位和i+1位相同，则对应的格雷码的第i位为0，否则为1（当i+1=n时，二进制码字的第n位被认为是0，即第n-1位不变） [4] 

[![img](https://bkimg.cdn.bcebos.com/pic/279759ee3d6d55fb05933d396d224f4a20a4dd5c?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)](https://baike.baidu.com/pic/格雷码/6510858/0/6a211233302c95d71a4cffbd?fr=lemma&ct=single)

**公式表示**：

![img](https://bkimg.cdn.bcebos.com/formula/ab1dace29a29f8414275e7378319d921.svg)

 （G：格雷码，B：二进制码）

例如：二进制码0101，为4位数，所以其所转为之格雷码也必为4位数，因此可取转成之二进位码第五位为0，即0 b3 b2 b1 b0。

0 xor 0=0，所以g3=0

0 xor 1=1，所以g2=1

1 xor 0=1，所以g1=1

0 xor 1=1，所以g0=1

因此所转换为之格雷码为0111

## 其他解法

### 对称生成

```c++
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ret;
        ret.reserve(1 << n);
        ret.push_back(0);
        for (int i = 1; i <= n; i++) {
            int m = ret.size();
            for (int j = m - 1; j >= 0; j--) {
                ret.push_back(ret[j] | (1 << (i - 1)));
            }
        }
        return ret;
    }
};
```

```java
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> ret = new ArrayList<Integer>();
        ret.add(0);
        for (int i = 1; i <= n; i++) {
            int m = ret.size();
            for (int j = m - 1; j >= 0; j--) {
                ret.add(ret.get(j) | (1 << (i - 1)));
            }
        }
        return ret;
    }
}
```

```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        ans = [0]
        for i in range(1, n + 1):
            for j in range(len(ans) - 1, -1, -1):
                ans.append(ans[j] | (1 << (i - 1)))
        return ans
```

#### 思路与算法

假设我们已经获取到 n-1 位的格雷码序列 $G_{n-1}$，我们只需要将 $G_{n-1}$对称翻转，记作 $G_{n-1}^T$。$G_{n-1}$的首元素和 $G_{n-1}^T$的尾元素都是相同的，反之亦然。如果我们给 $G_{n-1}^T$的每个元素都加上 $2^{n-1}$，记作 $(G_{n-1}^T)'$，则 $G_{n-1}$的首元素和 $(G_{n-1}^T)'$的尾元素只有一位不相同，反之亦然。因此 $G_{n-1}$和 $(G_{n-1}^T)'$拼接的序列 $G_n=[G_{n-1},~(G_{n-1}^T)']$满足 n 位的格雷码的定义。初始值 $G_0 = [0]$。

#### 复杂度分析

- 时间复杂度：$O(2^n)$，其中 n 为格雷码序列的位数。递推过程的时间复杂度为 $O(\sum_{i=1}^n 2^{i-1})=O(2^n)$。
- 空间复杂度：O(1)。注意返回值不计入空间复杂度。


### 二进制数转格雷码

```c++
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ret(1 << n);
        for (int i = 0; i < ret.size(); i++) {
            ret[i] = (i >> 1) ^ i;
        }
        return ret;
    }
};
```

```java
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> ret = new ArrayList<Integer>();
        for (int i = 0; i < 1 << n; i++) {
            ret.add((i >> 1) ^ i);
        }
        return ret;
    }
}
```

```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        ans = [0] * (1 << n)
        for i in range(1 << n):
            ans[i] = (i >> 1) ^ i
        return ans
```

#### 思路与算法

如果我们有一个二进制数序列，我们也可以将它直接转换成格雷码序列。假设 n 位二进制数为 b，对应的格雷码为 g，转换规则如下：

$$
g(i) = b(i+1) \oplus b(i),~~~~0 \le i \lt n
$$
其中 $\oplus$ 是按位异或运算，g(i) 和 b(i) 分别表示 g 和 b 的第 i 位，且 b(n)=0。

上述转换规则的证明如下：

> 考虑 n 位二进制数 $b_i$和对应的转换码 $g_i$，并且 $b_{i+1} = b_i + 1$ 也是 n 位二进制数。$b_{i+1}$与 $b_i$的区别在于 $b_{i+1}$将 $b_i$二进制下末位连接的 1 全部变成 0，然后将最低位的 0 变成 1。假设变化涉及到的二进制位数为 k 位，则按照上述转换规则， $g_{i+1}$与$ g_i$只有在第 k - 1 位不相同，其他位都相同。因此转换得到的码相邻的数只有一位不同，而转换码第一个整数和最后一个整数分别由二进制数 0 和 $2^n-1$转 换而来，也只有一位不同。因为二进制数的取值范围为 $[0,~2^n)$，且上述转换规则为一对一映射，因此得到的转换码也是互不相同的，且取值范围也在 $[0,~2^n)$，得证。

#### 复杂度分析

- 时间复杂度：$O(2^n)$，其中 n 为格雷码序列的位数。每个整数转换为格雷码的时间复杂度为 O(1)，总共有 $2^n$个转换。

- 空间复杂度：O(1)。注意返回值不计入空间复杂度。


