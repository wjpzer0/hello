# 题目

给你一个整数 `n` ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 `n` 的 **最简** 分数 。分数可以以 **任意** 顺序返回。

**示例 1：**

```
输入：n = 2
输出：["1/2"]
解释："1/2" 是唯一一个分母小于等于 2 的最简分数。
```

**示例 2：**

```
输入：n = 3
输出：["1/2","1/3","2/3"]
```

**示例 3：**

```
输入：n = 4
输出：["1/2","1/3","1/4","2/3","3/4"]
解释："2/4" 不是最简分数，因为它可以化简为 "1/2" 。
```

**示例 4：**

```
输入：n = 1
输出：[]
```

**提示：**

- `1 <= n <= 100`

## 我的解法

好家伙思路一模一样！就是不知道有内置函数，求公因数的代码是自己写的！

```python
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        ans = []
        for i in range(2, n + 1):
            for j in range(1, i):
                a = i
                b = j
                while (a % b != 0):
                    mod = a % b
                    a = b
                    b = mod
                if b == 1:
                    ans.append(str(j) + "/" + str(i))
        return ans
```

## 其他解法

### 数学

```c++
class Solution {
public:
    vector<string> simplifiedFractions(int n) {
        vector<string> ans;
        for (int denominator = 2; denominator <= n; ++denominator) {
            for (int numerator = 1; numerator < denominator; ++numerator) {
                if (__gcd(numerator, denominator) == 1) {
                    ans.emplace_back(to_string(numerator) + "/" + to_string(denominator));
                }
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    public List<String> simplifiedFractions(int n) {
        List<String> ans = new ArrayList<String>();
        for (int denominator = 2; denominator <= n; ++denominator) {
            for (int numerator = 1; numerator < denominator; ++numerator) {
                if (gcd(numerator, denominator) == 1) {
                    ans.add(numerator + "/" + denominator);
                }
            }
        }
        return ans;
    }

    public int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a;
    }
}
```

```python
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        return [f"{numerator}/{denominator}" for denominator in range(2, n + 1) for numerator in range(1, denominator) if gcd(denominator, numerator) == 1]
```

由于要保证分数在 (0,1) 范围内，我们可以枚举分母 $\textit{denominator}\in [2,n]$ 和分子 $\textit{numerator}\in [1,\textit{denominator})$，若分子分母的最大公约数为 1，则我们找到了一个最简分数。

#### 复杂度分析

- 时间复杂度：$O(n^2\log n)$。需要枚举 $O(n^2)$ 对分子分母的组合，每对分子分母计算最大公因数和生成字符串的复杂度均为 $O(\log n)$。
- 空间复杂度：O(1)。除答案数组外，我们只需要常数个变量。


