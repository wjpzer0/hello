# 题目

给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 `2` 或 `0`。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

更正式地说，`root.val = min(root.left.val, root.right.val)` 总成立。

给出这样的一个二叉树，你需要输出所有节点中的**第二小的值。**如果第二小的值不存在的话，输出 -1 **。**

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg)

```
输入：root = [2,2,5,null,null,5,7]
输出：5
解释：最小的值是 2 ，第二小的值是 5 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg)

```
输入：root = [2,2,2]
输出：-1
解释：最小的值是 2, 但是不存在第二小的值。
```

**提示：**

- 树中节点数目在范围 `[1, 25]` 内
- $1 <= Node.val <= 2^{31} - 1$
- 对于树中每个节点 `root.val == min(root.left.val, root.right.val)`

## 我的解法

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        self.num = []

        def dfs(r):
            if r is None:
                return 
            self.num.append(r.val)
            dfs(r.left)
            dfs(r.right)
        
        dfs(root)
        print(self.num)
        Fmin = min(self.num)
        Smin = float("inf")
        for i in self.num:
            if i < Smin and i != Fmin:
                Smin = i
        return Smin if Smin != float("inf") else -1
```

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> num;

    void dfs(TreeNode* r)
        {
            if (r == nullptr)
            {
                return;
            } 
            num.push_back(r->val);
            dfs(r->left);
            dfs(r->right);
        }

    int findSecondMinimumValue(TreeNode* root) {
        dfs(root);
        unsigned int Fmin;
        Fmin = *min_element(num.begin(),num.end());
        unsigned int Smin = UINT_MAX;
        for (int i = 0; i < num.size(); i++)
        {
            if (num[i] < Smin && num[i] != Fmin )
            {
                Smin = num[i];
            }
        }
        return Smin != UINT_MAX ? Smin : -1;
    }
};
```

最憨批的解法！该条件没有用上（如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个）！

## 其他解法

### 深度优先搜索

```c++
class Solution {
public:
    int findSecondMinimumValue(TreeNode* root) {
        int ans = -1;
        int rootvalue = root->val;

        function<void(TreeNode*)> dfs = [&](TreeNode* node) {
            if (!node) {
                return;
            }
            if (ans != -1 && node->val >= ans) {
                return;
            }
            if (node->val > rootvalue) {
                ans = node->val;
            }
            dfs(node->left);
            dfs(node->right);
        };

        dfs(root);
        return ans;
    }
};
```

```java
class Solution {
    int ans;
    int rootvalue;

    public int findSecondMinimumValue(TreeNode root) {
        ans = -1;
        rootvalue = root.val;
        dfs(root);
        return ans;
    }

    public void dfs(TreeNode node) {
        if (node == null) {
            return;
        }
        if (ans != -1 && node.val >= ans) {
            return;
        }
        if (node.val > rootvalue) {
            ans = node.val;
        }
        dfs(node.left);
        dfs(node.right);
    }
}
```

```python
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        ans, rootvalue = -1, root.val

        def dfs(node: TreeNode) -> None:
            nonlocal ans
            if not node:
                return
            if ans != -1 and node.val >= ans:
                return
            if node.val > rootvalue:
                ans = node.val
            
            dfs(node.left)
            dfs(node.right)

        dfs(root)
        return ans
```

#### 思路

根据题目中的描述「如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个」，我们可以知道，对于二叉树中的任意节点 x，x 的值不大于其所有子节点的值，因此：

> 对于二叉树中的任意节点 x，x 的值不大于以 x 为根的子树中所有节点的值。
>

令 x 为二叉树的根节点，此时我们可以得出结论：

> 二叉树根节点的值即为所有节点中的最小值。
>

因此，我们可以对整棵二叉树进行一次遍历。设根节点的值为 $\textit{rootvalue}$，我们只需要通过遍历，找出严格大于 $\textit{rootvalue}$ 的最小值，即为「所有节点中的第二小的值」。

#### 算法

我们可以使用深度优先搜索的方法对二叉树进行遍历。

假设当前遍历到的节点为 $\textit{node}$，如果 $\textit{node}$ 的值严格大于 $\textit{rootvalue}$，那么我们就可以用 $\textit{node}$ 的值来更新答案 $\textit{ans}$。

当我们遍历完整棵二叉树后，即可返回 $\textit{ans}$。

#### 细节

根据题目要求，如果第二小的值不存在的话，输出 −1，那么我们可以将 $\textit{ans}$​ 的初始值置为 −1。在遍历的过程中，如果当前节点的值严格大于 $\textit{rootvalue}$ 的节点时，那么只要 $\textit{ans}$ 的值为 −1 或者当前节点的值严格小于 $\textit{ans}$，我们就需要对 $\textit{ans}$ 进行更新。

此外，如果当前节点的值大于等于$ \textit{ans}$​，那么根据「思路」部分，以当前节点为根的子树中所有节点的值都大于等于 $\textit{ans}$，我们就直接回溯，无需对该子树进行遍历。这样做可以省去不必要的遍历过程。

#### 复杂度分析

- 时间复杂度：O(n)，其中 nn 是二叉树中的节点个数。我们最多需要对整棵二叉树进行一次遍历。

- 空间复杂度：O(n)。我们使用深度优先搜索的方法进行遍历，需要使用的栈空间为 O(n)。


