# 题目

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

- get(index)：获取链表中第 `index` 个节点的值。如果索引无效，则返回`-1`。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 `val` 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 `index` 个节点之前添加值为 `val` 的节点。如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。如果`index`小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 `index` 有效，则删除链表中的第 `index` 个节点。

**示例：**

```
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
```

**提示：**

- 所有`val`值都在 `[1, 1000]` 之内。
- 操作次数将在 `[1, 1000]` 之内。
- 请不要使用内置的 LinkedList 库。

## 我的解法

关于链表的代码已经有点不熟悉了！

```python
class linkedNode:
    def __init__(self, val = None):
        self.val = val
        self.next = None

class MyLinkedList:

    def __init__(self):
        self.head = linkedNode()
        self.length = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.length:
            return -1
        node = self.head
        for i in range(index + 1):
            node = node.next
            print(node.val)
        return node.val

    def addAtHead(self, val: int) -> None:
        addNode = linkedNode(val)
        addNode.next = self.head.next
        self.head.next = addNode
        self.length += 1

    def addAtTail(self, val: int) -> None:
        addNode = linkedNode(val)
        node = self.head
        while node.next:
            node = node.next
        node.next = addNode
        self.length += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index == self.length:
            self.addAtTail(val)
            return None
        elif index < 0:
            self.addAtHead(val)
            return None
        elif index > self.length:
            return None
        addNode = linkedNode(val)
        node = self.head
        for i in range(index):
            node = node.next
        addNode.next = node.next
        node.next = addNode
        self.length += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.length:
            return None
        node = self.head
        for i in range(index):
            node = node.next
        delNode = node.next
        node.next = delNode.next
        self.length -= 1

# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

## 其它解法

### 单向链表

```c++
class MyLinkedList {
public:
    MyLinkedList() {
        this->size = 0;
        this->head = new ListNode(0);
    }
    
    int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode *cur = head;
        for (int i = 0; i <= index; i++) {
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        index = max(0, index);
        size++;
        ListNode *pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred->next;
        }
        ListNode *toAdd = new ListNode(val);
        toAdd->next = pred->next;
        pred->next = toAdd;
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode *pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred->next;
        }
        ListNode *p = pred->next;
        pred->next = pred->next->next;
        delete p;
    }
private:
    int size;
    ListNode *head;
};
```

```java
class MyLinkedList {
    int size;
    ListNode head;

    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }

    public int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode cur = head;
        for (int i = 0; i <= index; i++) {
            cur = cur.next;
        }
        return cur.val;
    }

    public void addAtHead(int val) {
        addAtIndex(0, val);
    }

    public void addAtTail(int val) {
        addAtIndex(size, val);
    }

    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        index = Math.max(0, index);
        size++;
        ListNode pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        ListNode toAdd = new ListNode(val);
        toAdd.next = pred.next;
        pred.next = toAdd;
    }

    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        pred.next = pred.next.next;
    }
}

class ListNode {
    int val;
    ListNode next;

    public ListNode(int val) {
        this.val = val;
    }
}
```

```python
class ListNode:

    def __init__(self, val):
        self.val = val
        self.next = None


class MyLinkedList:

    def __init__(self):
        self.size = 0
        self.head = ListNode(0)


    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        cur = self.head
        for _ in range(index + 1):
            cur = cur.next
        return cur.val


    def addAtHead(self, val: int) -> None:
        self.addAtIndex(0, val)


    def addAtTail(self, val: int) -> None:
        self.addAtIndex(self.size, val)


    def addAtIndex(self, index: int, val: int) -> None:
        if index > self.size:
            return
        index = max(0, index)
        self.size += 1
        pred = self.head
        for _ in range(index):
            pred = pred.next
        to_add = ListNode(val)
        to_add.next = pred.next
        pred.next = to_add

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        self.size -= 1
        pred = self.head
        for _ in range(index):
            pred = pred.next
        pred.next = pred.next.next
```

#### 思路

实现单向链表，即每个节点仅存储本身的值和后继节点。除此之外，我们还需要一个哨兵（sentinel）节点作为头节点，和一个 $\textit{size}$ 参数保存有效节点数。如下图所示。

![img](https://assets.leetcode-cn.com/solution-static/707/1_1.png)


初始化时，只需创建头节点 $\textit{head}$ 和 $\textit{size}$ 即可。

实现 $\textit{get}(\textit{index})$ 时，先判断有效性，再通过循环来找到对应的节点的值。如下图所示。

![img](https://assets.leetcode-cn.com/solution-static/707/1_4.png)


实现 $\textit{addAtIndex}(\textit{index, val})$ 时，如果 $\textit{index}$是有效值，则需要找到原来下标为 $\textit{index}$的节点的前驱节点$ \textit{pred}$，并创建新节点 $\textit{to\_add}$，将$\textit{to\_add}$的后继节点设为 $\textit{pred}$ 的后继节点，将$ \textit{pred}$的后继节点更新为 $\textit{to\_add}$ ，这样就将 $\textit{to\_add}$ 插入到了链表中。最后需要更新 $\textit{size}$。这样的操作对于 $\textit{index} = 0$ 也成立，如以下两张图所示。

![img](https://assets.leetcode-cn.com/solution-static/707/1_2.png)

![img](https://assets.leetcode-cn.com/solution-static/707/1_3.png)

实现 $\textit{addAtHead}(\textit{val})$ 和 $\textit{addAtTail}(\textit{val})$ 时，可以借助 $\textit{addAtIndex}(\textit{index, val})$ 来实现。

实现 $\textit{deleteAtIndex}(\textit{index})$，先判断参数有效性。然后找到下标为 $\textit{index}$的节点的前驱节点 $\textit{pred}$，通过将 $\textit{pred}$的后继节点更新为 $\textit{pred}$的后继节点的后继节点，来达到删除节点的效果。同时也要更新 $\textit{size}$。如下图所示。


![img](https://assets.leetcode-cn.com/solution-static/707/1_5.png)

#### 复杂度分析

- 时间复杂度：初始化消耗 O(1)，$\textit{get}$消耗 $O(\textit{index})$，$\textit{addAtHead}$消耗 O(1)，$\textit{addAtTail}$消耗 O(n)，其中 n 为链表当前长度，即 $\textit{addAtHead}$，$\textit{addAtTail}$和 $\textit{addAtIndex}$已调用次数之和，$\textit{addAtIndex}$消耗 $O(\textit{index})$。

- 空间复杂度：所有函数的单次调用空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 $\textit{addAtHead}$，$\textit{addAtTail}$和 $\textit{addAtIndex}$ 调用次数之和。


### 双向链表

```c++
struct DLinkListNode {
    int val;
    DLinkListNode *prev, *next;
    DLinkListNode(int _val) : val(_val), prev(nullptr), next(nullptr) {}
};

class MyLinkedList {
public:
    MyLinkedList() {
        this->size = 0;
        this->head = new DLinkListNode(0);
        this->tail = new DLinkListNode(0);
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }
        DLinkListNode *curr;
        if (index + 1 < size - index) {
            curr = head;
            for (int i = 0; i <= index; i++) {
                curr = curr->next;
            }
        } else {
            curr = tail;
            for (int i = 0; i < size - index; i++) {
                curr = curr->prev;
            }
        }
        return curr->val;
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        index = max(0, index);
        DLinkListNode *pred, *succ;
        if (index < size - index) {
            pred = head;
            for (int i = 0; i < index; i++) {
                pred = pred->next;
            }
            succ = pred->next;
        } else {
            succ = tail;
            for (int i = 0; i < size - index; i++) {
                succ = succ->prev;
            }
            pred = succ->prev;
        }
        size++;
        DLinkListNode *toAdd = new DLinkListNode(val);
        toAdd->prev = pred;
        toAdd->next = succ;
        pred->next = toAdd;
        succ->prev = toAdd;
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        DLinkListNode *pred, *succ;
        if (index < size - index) {
            pred = head;
            for (int i = 0; i < index; i++) {
                pred = pred->next;
            }
            succ = pred->next->next;
        } else {
            succ = tail;
            for (int i = 0; i < size - index - 1; i++) {
                succ = succ->prev;
            }
            pred = succ->prev->prev;
        }
        size--;
        DLinkListNode *p = pred->next;
        pred->next = succ;
        succ->prev = pred;
        delete p;
    }
private:
    int size;
    DLinkListNode *head;
    DLinkListNode *tail;
};
```

```java
class MyLinkedList {
    int size;
    ListNode head;
    ListNode tail;

    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
        tail = new ListNode(0);
        head.next = tail;
        tail.prev = head;
    }

    public int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode curr;
        if (index + 1 < size - index) {
            curr = head;
            for (int i = 0; i <= index; i++) {
                curr = curr.next;
            }
        } else {
            curr = tail;
            for (int i = 0; i < size - index; i++) {
                curr = curr.prev;
            }
        }
        return curr.val;
    }

    public void addAtHead(int val) {
        addAtIndex(0, val);
    }

    public void addAtTail(int val) {
        addAtIndex(size, val);
    }

    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        index = Math.max(0, index);
        ListNode pred, succ;
        if (index < size - index) {
            pred = head;
            for (int i = 0; i < index; i++) {
                pred = pred.next;
            }
            succ = pred.next;
        } else {
            succ = tail;
            for (int i = 0; i < size - index; i++) {
                succ = succ.prev;
            }
            pred = succ.prev;
        }
        size++;
        ListNode toAdd = new ListNode(val);
        toAdd.prev = pred;
        toAdd.next = succ;
        pred.next = toAdd;
        succ.prev = toAdd;
    }

    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        ListNode pred, succ;
        if (index < size - index) {
            pred = head;
            for (int i = 0; i < index; i++) {
                pred = pred.next;
            }
            succ = pred.next.next;
        } else {
            succ = tail;
            for (int i = 0; i < size - index - 1; i++) {
                succ = succ.prev;
            }
            pred = succ.prev.prev;
        }
        size--;
        pred.next = succ;
        succ.prev = pred;
    }
}

class ListNode {
    int val;
    ListNode next;
    ListNode prev;

    public ListNode(int val) {
        this.val = val;
    }
}
```

```python
class ListNode:

    def __init__(self, x):
        self.val = x
        self.next = None
        self.prev = None


class MyLinkedList:

    def __init__(self):
        self.size = 0
        self.head, self.tail = ListNode(0), ListNode(0) 
        self.head.next = self.tail
        self.tail.prev = self.head


    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        if index + 1 < self.size - index:
            curr = self.head
            for _ in range(index + 1):
                curr = curr.next
        else:
            curr = self.tail
            for _ in range(self.size - index):
                curr = curr.prev
        return curr.val


    def addAtHead(self, val: int) -> None:
        self.addAtIndex(0, val)


    def addAtTail(self, val: int) -> None:
        self.addAtIndex(self.size, val)


    def addAtIndex(self, index: int, val: int) -> None:
        if index > self.size:
            return
        index = max(0, index)
        if index < self.size - index:
            pred = self.head
            for _ in range(index):
                pred = pred.next
            succ = pred.next
        else:
            succ = self.tail
            for _ in range(self.size - index):
                succ = succ.prev
            pred = succ.prev
        self.size += 1
        to_add = ListNode(val)
        to_add.prev = pred
        to_add.next = succ
        pred.next = to_add
        succ.prev = to_add


    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        if index < self.size - index:
            pred = self.head
            for _ in range(index):
                pred = pred.next
            succ = pred.next.next
        else:
            succ = self.tail
            for _ in range(self.size - index - 1):
                succ = succ.prev
            pred = succ.prev.prev
        self.size -= 1
        pred.next = succ
        succ.prev = pred
```

#### 思路

实现双向链表，即每个节点要存储本身的值，后继节点和前驱节点。除此之外，需要一个哨兵节点作为头节点 $\textit{head}$和一个哨兵节点作为尾节点 $\textit{tail}$。仍需要一个 $\textit{size}$参数保存有效节点数。如下图所示。

![img](https://assets.leetcode-cn.com/solution-static/707/1_6.png)


初始化时，只需创建头节点 $\textit{head}$和 $\textit{size}$即可。

实现 $\textit{get}(\textit{index})$ 时，先判断有效性，然后再比较从 $\textit{head}$还是 $\textit{tail}$来遍历会比较快找到目标，然后进行遍历。如下图所示。

![img](https://assets.leetcode-cn.com/solution-static/707/1_7.png)

实现 $\textit{addAtIndex}(\textit{index, val})$ 时，如果 $\textit{index}$是有效值，则需要找到原来下标为 $\textit{index}$的节点 $\textit{succ}$和前驱节点 $\textit{pred}$，并创建新节点 $\textit{to\_add}$，再通过各自 $\textit{prev}$和 $\textit{next}$变量的更新来增加 $\textit{to\_add}$。最后需要更新 $\textit{size}$。如以下两张图所示。

![img](https://assets.leetcode-cn.com/solution-static/707/1_8.png)


实现 $\textit{addAtHead}(\textit{val})$ 和 $\textit{addAtTail}(\textit{val})$ 时，可以借助 $\textit{addAtIndex}(\textit{index, val})$ 来实现。

实现 $\textit{deleteAtIndex}(\textit{index})$，先判断参数有效性。然后找到下标为 $\textit{index}$的节点的前驱节点 $\textit{pred}$和后继节点$ \textit{succ}$，再通过各自 $\textit{prev}$和$ \textit{next}$变量的更新来删除节点，来达到删除节点的效果。同时也要更新 $\textit{size}$。如下图所示。


![img](https://assets.leetcode-cn.com/solution-static/707/1_9.png)

#### 复杂度分析

- 时间复杂度：初始化消耗 O(1)，$\textit{get}$消耗 $O(\textit{index})$，$\textit{addAtHead}$消耗 O(1)，$\textit{addAtTail}$消耗 O(1)，$\textit{addAtIndex}$消耗 $O(\textit{index})$。


- 空间复杂度：所有函数单次调用的空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 $\textit{addAtHead}$，$\textit{addAtTail}$和$ \textit{addAtIndex}$调用次数之和。


