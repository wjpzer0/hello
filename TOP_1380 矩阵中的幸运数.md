# 题目

给你一个 `m * n` 的矩阵，矩阵中的数字 **各不相同** 。请你按 **任意** 顺序返回矩阵中的所有幸运数。

幸运数是指矩阵中满足同时下列两个条件的元素：

- 在同一行的所有元素中最小
- 在同一列的所有元素中最大

**示例 1：**

```
输入：matrix = [[3,7,8],[9,11,13],[15,16,17]]
输出：[15]
解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。
```

**示例 2：**

```
输入：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
输出：[12]
解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。
```

**示例 3：**

```
输入：matrix = [[7,8],[1,2]]
输出：[7]
```

**提示：**

- `m == mat.length`
- `n == mat[i].length`
- `1 <= n, m <= 50`
- $1 <= matrix[i][j] <= 10^5$
- 矩阵中的所有元素都是不同的

## 我的解法

一步一步来，感觉代码有些臃肿！

```python
class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        row = []
        col = []

        m = len(matrix)
        n = len(matrix[0])

        for i in range(m):
            minNum = float('inf')
            for j in range(n):
                if matrix[i][j] < minNum:
                    minNum = matrix[i][j]
            row.append(minNum)
        
        for j in range(n):
            maxNum = 0
            for i in range(m):
                if matrix[i][j] > maxNum:
                    maxNum = matrix[i][j]
            col.append(maxNum)

        ans = []
        for i in range(m):
            for j in range(n):
                if row[i] == col[j]:
                    ans.append(matrix[i][j])
        return ans
```

## 其他解法

### 模拟

```c++
class Solution {
public:
    vector<int> luckyNumbers (vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<int> ret;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                bool isMin = true, isMax = true;
                for (int k = 0; k < n; k++) {
                    if (matrix[i][k] < matrix[i][j]) {
                        isMin = false;
                        break;
                    }
                }
                if (!isMin) {
                    continue;
                }
                for (int k = 0; k < m; k++) {
                    if (matrix[k][j] > matrix[i][j]) {
                        isMax = false;
                        break;
                    }
                }
                if (isMax) {
                    ret.push_back(matrix[i][j]);
                }
            }
        }
        return ret;
    }
};
```

```java
class Solution {
    public List<Integer> luckyNumbers (int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        List<Integer> ret = new ArrayList<Integer>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                boolean isMin = true, isMax = true;
                for (int k = 0; k < n; k++) {
                    if (matrix[i][k] < matrix[i][j]) {
                        isMin = false;
                        break;
                    }
                }
                if (!isMin) {
                    continue;
                }
                for (int k = 0; k < m; k++) {
                    if (matrix[k][j] > matrix[i][j]) {
                        isMax = false;
                        break;
                    }
                }
                if (isMax) {
                    ret.add(matrix[i][j]);
                }
            }
        }
        return ret;
    }
}
```

```python
class Solution:
    def luckyNumbers(self, matrix: List[List[int]]) -> List[int]:
        ans = []
        for row in matrix:
            for j, x in enumerate(row):
                if max(r[j] for r in matrix) <= x <= min(row):
                    ans.append(x)
        return ans
```

#### 思路与算法

遍历矩阵 $\textit{matrix}$，判断 $\textit{matrix}[i][j]$是否是它所在行的最小值和所在列的最大值，如果是，则加入返回结果。

#### 复杂度分析

- 时间复杂度：$O(mn \times (m + n))$，其中 m 和 n 分别是矩阵 $\textit{matrix}$的行数和列数。遍历矩阵 $\textit{matrix}$ 需要 O(mn)，查找行最小值需要 O(n)，查找列最大值需要 O(m)。

- 空间复杂度：O(1)。返回值不计算空间复杂度。


### 预处理

```c++
class Solution {
public:
    vector<int> luckyNumbers (vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<int> minRow(m, INT_MAX), maxCol(n);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                minRow[i] = min(minRow[i], matrix[i][j]);
                maxCol[j] = max(maxCol[j], matrix[i][j]);
            }
        }
        vector<int> ret;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == minRow[i] && matrix[i][j] == maxCol[j]) {
                    ret.push_back(matrix[i][j]);
                }
            }
        }
        return ret;
    }
};
```

```java
class Solution {
    public List<Integer> luckyNumbers (int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[] minRow = new int[m];
        Arrays.fill(minRow, Integer.MAX_VALUE);
        int[] maxCol = new int[n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                minRow[i] = Math.min(minRow[i], matrix[i][j]);
                maxCol[j] = Math.max(maxCol[j], matrix[i][j]);
            }
        }
        List<Integer> ret = new ArrayList<Integer>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == minRow[i] && matrix[i][j] == maxCol[j]) {
                    ret.add(matrix[i][j]);
                }
            }
        }
        return ret;
    }
}
```

```python
class Solution:
    def luckyNumbers(self, matrix: List[List[int]]) -> List[int]:
        minRow = [min(row) for row in matrix]
        maxCol = [max(col) for col in zip(*matrix)]
        ans = []
        for i, row in enumerate(matrix):
            for j, x in enumerate(row):
                if x == minRow[i] == maxCol[j]:
                    ans.append(x)
        return ans
```

#### 思路与算法

预处理出每行的最小值数组 $\textit{minRow}$ 和每列的最大值数组 $\textit{maxCol}$，其中 $\textit{minRow}[i]$ 表示第 i 行的最小值，$\textit{maxCol}[j]$ 表示第 j 列的最大值。遍历矩阵 $\textit{matrix}$，如果 $\textit{matrix}[i][j]$ 同时满足 $\textit{matrix}[i][j]=\textit{minRow}[i]$ 和 $\textit{matrix}[i][j] = \textit{maxCol}[j]$，那么 $\textit{matrix}[i][j]$是矩阵中的幸运数，加入返回结果。

#### 复杂度分析

- 时间复杂度：O(mn)，其中 m 和 n 分别是矩阵 $\textit{matrix}$ 的行数和列数。预处理 $\textit{minRow}$ 和 $\textit{maxCol}$ 需要 O(mn)，查找幸运数需要 O(mn)。

- 空间复杂度：O(m + n)。保存 $\textit{minRow}$ 和 $\textit{maxCol}$ 需要 O(m + n) 的额外空间，返回值不计入空间复杂度。


