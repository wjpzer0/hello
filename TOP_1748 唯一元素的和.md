# 题目

给你一个整数数组 `nums` 。数组中唯一元素是那些只出现 **恰好一次** 的元素。

请你返回 `nums` 中唯一元素的 **和** 。

**示例 1：**

```
输入：nums = [1,2,3,2]
输出：4
解释：唯一元素为 [1,3] ，和为 4 。
```

**示例 2：**

```
输入：nums = [1,1,1,1,1]
输出：0
解释：没有唯一元素，和为 0 。
```

**示例 3 ：**

```
输入：nums = [1,2,3,4,5]
输出：15
解释：唯一元素为 [1,2,3,4,5] ，和为 15 。
```

**提示：**

- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 100`

## 我的解法

思考还有什么可以优化！

```c++
class Solution {
public:
    int sumOfUnique(vector<int>& nums) {
        unordered_map<int, int> map;
        int ans = 0;
        for (auto & num : nums)
        {
            if (map[num] == 0)
            {
                ans += num;
                map[num] = 1;
            }
            else if (map[num] == 1)
            {
                ans -= num;
                map[num] = 2;
            }
        }
        return ans;
    }
};
```

```python
class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        ans = 0
        map = {}
        for num in nums:
            if num in map:
                map[num] += 1
            else:
                map[num] = 1
        
        for k, v in map.items():
            if v == 1:
                ans += k
        
        return ans
```

## 其他解法

### 记录每个元素的出现次数

```c++
class Solution {
public:
    int sumOfUnique(vector<int> &nums) {
        unordered_map<int, int> cnt;
        for (int num : nums) {
            ++cnt[num];
        }
        int ans = 0;
        for (auto &[num, c] : cnt) {
            if (c == 1) {
                ans += num;
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    public int sumOfUnique(int[] nums) {
        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();
        for (int num : nums) {
            cnt.put(num, cnt.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {
            int num = entry.getKey(), c = entry.getValue();
            if (c == 1) {
                ans += num;
            }
        }
        return ans;
    }
}
```

```python
class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        return sum(num for num, cnt in Counter(nums).items() if cnt == 1)
```

根据题意，我们可以用一个哈希表记录每个元素值的出现次数，然后遍历哈希表，累加恰好出现一次的元素值，即为答案。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是数组 $\textit{nums}$ 的长度。

- 空间复杂度：O(n)。哈希表需要 O(n) 的空间。


### 记录每个元素的状态 + 一次遍历

```c++
class Solution {
public:
    int sumOfUnique(vector<int> &nums) {
        int ans = 0;
        unordered_map<int, int> state;
        for (int num : nums) {
            if (state[num] == 0) {
                ans += num;
                state[num] = 1;
            } else if (state[num] == 1) {
                ans -= num;
                state[num] = 2;
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    public int sumOfUnique(int[] nums) {
        int ans = 0;
        Map<Integer, Integer> state = new HashMap<Integer, Integer>();
        for (int num : nums) {
            if (!state.containsKey(num)) {
                ans += num;
                state.put(num, 1);
            } else if (state.get(num) == 1) {
                ans -= num;
                state.put(num, 2);
            }
        }
        return ans;
    }
}
```

```python
class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        ans = 0
        state = {}
        for num in nums:
            if num not in state:
                ans += num
                state[num] = 1
            elif state[num] == 1:
                ans -= num
                state[num] = 2
        return ans
```

方法一需要遍历数组和哈希表各一次，能否做到仅执行一次遍历呢？

我们可以赋给每个元素三个状态：

- 0：该元素尚未被访问；
- 1：该元素被访问过一次；
- 2：该元素被访问超过一次。

我们可以在首次访问一个元素时，将该元素加入答案，然后将该元素状态标记为 1。在访问到一个标记为 1 的元素时，由于这意味着该元素出现不止一次，因此将其从答案中减去，并将该元素状态标记为 2。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是数组 $\textit{nums}$ 的长度。

- 空间复杂度：O(n)。哈希表需要 O(n) 的空间。


