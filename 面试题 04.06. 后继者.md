# 题目

设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。

如果指定节点没有对应的“下一个”节点，则返回`null`。

**示例 1:**

```
输入: root = [2,1,3], p = 1

  2
 / \
1   3

输出: 2
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,null,1], p = 6

      5
     / \
    3   6
   / \
  2   4
 /   
1

输出: null
```

## 我的解法

中序遍历存储好后，再查找后继的值，再用二叉搜索树的性质找到对应节点！

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderSuccessor(self, root: TreeNode, p: TreeNode) -> TreeNode:
        self.ls = []
        def dfs(node):
            if node:
                dfs(node.left)
                self.ls.append(node.val)
                dfs(node.right)
        dfs(root)

        point = bisect.bisect_right(self.ls,p.val)
        if point >= len(self.ls):
            return None
        
        num = self.ls[point]
        node = root
        while node.val != num:
            if num > node.val:
                node = node.right
            elif num < node.val:
                node = node.left
        return node
```

## 其他解法

### 中序遍历

```c++
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        stack<TreeNode*> st;
        TreeNode *prev = nullptr, *curr = root;
        while (!st.empty() || curr != nullptr) {
            while (curr != nullptr) {
                st.emplace(curr);
                curr = curr->left;
            }
            curr = st.top();
            st.pop();
            if (prev == p) {
                return curr;
            }
            prev = curr;
            curr = curr->right;
        }
        return nullptr;
    }
};
```

```java
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        TreeNode prev = null, curr = root;
        while (!stack.isEmpty() || curr != null) {
            while (curr != null) {
                stack.push(curr);
                curr = curr.left;
            }
            curr = stack.pop();
            if (prev == p) {
                return curr;
            }
            prev = curr;
            curr = curr.right;
        }
        return null;
    }
}
```

```python
class Solution:
    def inorderSuccessor(self, root: TreeNode, p: TreeNode) -> TreeNode:
        st, pre, cur = [], None, root
        while st or cur:
            while cur:
                st.append(cur)
                cur = cur.left
            cur = st.pop()
            if pre == p:
                return cur
            pre = cur
            cur = cur.right
        return None
```

为了找到二叉搜索树中的节点 p 的后继节点，最直观的方法是中序遍历。由于只需要找到节点 p 的后继节点，因此不需要维护完整的中序遍历序列，只需要在中序遍历的过程中维护上一个访问的节点和当前访问的节点。如果上一个访问的节点是节点 p，则当前访问的节点即为节点 p 的后继节点。

如果节点 p 是最后被访问的节点，则不存在节点 p 的后继节点，返回 $\text{null}$。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。中序遍历最多需要访问二叉搜索树中的每个节点一次。

- 空间复杂度：O(n)，其中 n 是二叉搜索树的节点数。空间复杂度取决于栈深度，平均情况是 $O(\log n)$，最坏情况是 O(n)。


### 利用二叉搜索树的性质

```c++
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        TreeNode *successor = nullptr;
        if (p->right != nullptr) {
            successor = p->right;
            while (successor->left != nullptr) {
                successor = successor->left;
            }
            return successor;
        }
        TreeNode *node = root;
        while (node != nullptr) {
            if (node->val > p->val) {
                successor = node;
                node = node->left;
            } else {
                node = node->right;
            }
        }
        return successor;
    }
};
```

```java
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode successor = null;
        if (p.right != null) {
            successor = p.right;
            while (successor.left != null) {
                successor = successor.left;
            }
            return successor;
        }
        TreeNode node = root;
        while (node != null) {
            if (node.val > p.val) {
                successor = node;
                node = node.left;
            } else {
                node = node.right;
            }
        }
        return successor;
    }
}
```

```python
class Solution:
    def inorderSuccessor(self, root: TreeNode, p: TreeNode) -> TreeNode:
        successor = None
        if p.right:
            successor = p.right
            while successor.left:
                successor = successor.left
            return successor
        node = root
        while node:
            if node.val > p.val:
                successor = node
                node = node.left
            else:
                node = node.right
        return successor
```

二叉搜索树的一个性质是中序遍历序列单调递增，因此二叉搜索树中的节点 p 的后继节点满足以下条件：

- 后继节点的节点值大于 p 的节点值；

- 后继节点是节点值大于 p 的节点值的所有节点中节点值最小的一个节点。


利用二叉搜索树的性质，可以在不做中序遍历的情况下找到节点 p 的后继节点。

如果节点 p 的右子树不为空，则节点 p 的后继节点在其右子树中，在其右子树中定位到最左边的节点，即为节点 p 的后继节点。

如果节点 p 的右子树为空，则需要从根节点开始遍历寻找节点 p 的祖先节点。

将答案初始化为$ \text{null}$。用 $\textit{node}$表示遍历到的节点，初始时 $\textit{node} = \textit{root}$。每次比较 $\textit{node}$的节点值和 p 的节点值，执行相应操作：

- 如果 $\textit{node}$的节点值大于 p 的节点值，则 p 的后继节点可能是 $\textit{node}$ 或者在 $\textit{node}$的左子树中，因此用 $\textit{node}$更新答案，并将 $\textit{node}$ 移动到其左子节点继续遍历；

- 如果 $\textit{node}$ 的节点值小于或等于 p 的节点值，则 p 的后继节点可能在$ \textit{node}$ 的右子树中，因此将 $\textit{node}$ 移动到其右子节点继续遍历。


由于在遍历过程中，当且仅当 $\textit{node}$ 的节点值大于 p 的节点值的情况下，才会用 $\textit{node}$ 更新答案，因此当节点 p 有后继节点时一定可以找到后继节点，当节点 p 没有后继节点时答案一定为 $\text{null}$。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。遍历的节点数不超过二叉搜索树的高度，平均情况是 $O(\log n)$，最坏情况是 O(n)。

- 空间复杂度：O(1)。


