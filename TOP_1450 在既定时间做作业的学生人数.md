# 题目

给你两个整数数组 `startTime`（开始时间）和 `endTime`（结束时间），并指定一个整数 `queryTime` 作为查询时间。

已知，第 `i` 名学生在 `startTime[i]` 时开始写作业并于 `endTime[i]` 时完成作业。

请返回在查询时间 `queryTime` 时正在做作业的学生人数。形式上，返回能够使 `queryTime` 处于区间 `[startTime[i], endTime[i]]`（含）的学生人数。

**示例 1：**

```
输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4
输出：1
解释：一共有 3 名学生。
第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。
第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。
第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。
```

**示例 2：**

```
输入：startTime = [4], endTime = [4], queryTime = 4
输出：1
解释：在查询时间只有一名学生在做作业。
```

**示例 3：**

```
输入：startTime = [4], endTime = [4], queryTime = 5
输出：0
```

**示例 4：**

```
输入：startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7
输出：0
```

**示例 5：**

```
输入：startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5
输出：5
```

**提示：**

- `startTime.length == endTime.length`
- `1 <= startTime.length <= 100`
- `1 <= startTime[i] <= endTime[i] <= 1000`
- `1 <= queryTime <= 1000`

## 我的解法

遍历，快速解决，思考其它解法在什么规模的数据下更优秀！

```python
class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        ans = 0
        for start, end in zip(startTime, endTime):
            if queryTime >= start and queryTime <= end:
                ans += 1
        return ans
```



## 其它解法

### 枚举

```c++
class Solution {
public:
    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
        int n = startTime.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (startTime[i] <= queryTime && endTime[i] >= queryTime) {
                ans++;
            }
        }
        return ans;
    }
};
```

```java
class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n = startTime.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (startTime[i] <= queryTime && endTime[i] >= queryTime) {
                ans++;
            }
        }
        return ans;
    }
}
```

```python
class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        return sum(s <= queryTime <= e for s, e in zip(startTime, endTime))
```

题目要求找到 $\textit{queryTime}$时正在做作业的学生人数，第 ii 名学生的起始时间 \textit{startTime}[i] 和完成时间 $\textit{endTime}[i] $如果满足$ \textit{startTime}[i] \le \textit{queryTime} \le \textit{endTime}[i]$，则可知该名学生在 $\textit{queryTime}$时一定正在作业。我们遍历所有学生的起始时间和结束时间，统计符合上述条件的学生总数即可。

#### **复杂度分析**

- 时间复杂度：O(n)，其中 n 为 数组的长度。只需遍历一遍数组即可。
- 空间复杂度：O(1)。

### 差分数组

```c++
class Solution {
public:
    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
        int n = startTime.size();
        int maxEndTime = *max_element(endTime.begin(), endTime.end());
        if (queryTime > maxEndTime) {
            return 0;
        }
        vector<int> cnt(maxEndTime + 2);
        for (int i = 0; i < n; i++) {
            cnt[startTime[i]]++;
            cnt[endTime[i] + 1]--;
        }
        int ans = 0;
        for (int i = 0; i <= queryTime; i++) {
            ans += cnt[i];
        }
        return ans;
    }
};
```

```java
class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n = startTime.length;
        int maxEndTime = Arrays.stream(endTime).max().getAsInt();
        if (queryTime > maxEndTime) {
            return 0;
        }
        int[] cnt = new int[maxEndTime + 2];
        for (int i = 0; i < n; i++) {
            cnt[startTime[i]]++;
            cnt[endTime[i] + 1]--;
        }
        int ans = 0;
        for (int i = 0; i <= queryTime; i++) {
            ans += cnt[i];
        }
        return ans;
    }
}
```

```python
class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        maxEndTime = max(endTime)
        if queryTime > maxEndTime:
            return 0
        cnt = [0] * (maxEndTime + 2)
        for s, e in zip(startTime, endTime):
            cnt[s] += 1
            cnt[e + 1] -= 1
        return sum(cnt[:queryTime + 1])
```

利用差分数组的思想，对差分数组求前缀和，可以得到统计出 tt 时刻正在做作业的人数。我们初始化差分数组 $\textit{cnt}$每个元素都为 0，在每个学生的起始时间处 $\textit{cnt}[\textit{startTime}[i]]$ 加 1，在每个学生的结束时间处 $\textit{cnt}[\textit{endTime}[i] + 1]$ 减 1，因此我们可以统计出 $\textit{queryTime}$时刻正在做作业的人数为$ \sum_{j=0}^{\textit{queryTime}}\textit{cnt}[j]$。

#### 复杂度分析

- 时间复杂度：$O(n + \textit{queryTime})$)，其中 n 为数组的长度，$\textit{queryTime}$为给定的查找时间。首先需要遍历一遍数组，需要的时间为 O(n)，然后需要查分求和求出 $\textit{queryTime}$时间点正在作业的学生总数，需要的时间为 $O(\textit{queryTime})$，因此总的时间为 $O(n + \textit{queryTime})$。

- 空间复杂度：$O(\max(\textit{endTime}))$。


### 二分查找

```c++
class Solution {
public: 
    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
        sort(startTime.begin(), startTime.end());
        sort(endTime.begin(), endTime.end());
        int lessStart = upper_bound(startTime.begin(), startTime.end(), queryTime) - startTime.begin();
        int lessEnd = lower_bound(endTime.begin(), endTime.end(), queryTime) - endTime.begin();
        return lessStart - lessEnd;
    }
};
```

```java
class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        Arrays.sort(startTime);
        Arrays.sort(endTime);
        int lessStart = upperbound(startTime, 0, startTime.length - 1, queryTime);
        int lessEnd = lowerbound(endTime, 0, endTime.length - 1, queryTime);
        return lessStart - lessEnd;
    }

    public static int upperbound(int[] arr, int l, int r, int target) {
        int ans = r + 1;
        while (l <= r) {
            int mid = l + ((r - l) >> 1);
            if (arr[mid] > target) {
                ans = mid;
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return ans;
    }

    public static int lowerbound(int[] arr, int l, int r, int target) {
        int ans = r + 1;
        while (l <= r) {
            int mid = l + ((r - l) >> 1);
            if (arr[mid] >= target) {
                ans = mid;
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return ans;
    }
}
```

```python
class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        startTime.sort()
        endTime.sort()
        return bisect_right(startTime, queryTime) - bisect_left(endTime, queryTime)
```

对于每个学生的作业时间 $[\textit{startTime}[i], \textit{endTime}[i]]$，一定满足 $\textit{startTime}[i]\le \textit{endTime}[i]$。如果第 i 名学生在$ \textit{queryTime}$时正在作业，则一定满足$ \textit{startTime}[i] \le \textit{queryTime} \le \textit{endTime}[i]$。设起始时间小于等于 $\textit{queryTime}$ 的学生集合为 $\textit{lessStart}$，设结束时间小于 $\textit{queryTime}$的学生集合为 $\textit{lessEnd}$，则根据上述推理可以知道 $\textit{lessEnd} \in \textit{lessStart}$，我们从 $\textit{lessStart}$去除 $\textit{lessEnd}$的子集部分即为符合条件的学生集合。因此我们通过二分查找找到始时间小于等于$ \textit{queryTime}$的学生人数，然后减去结束时间小于 $\textit{queryTime}$的学生人数，最终结果即为符合条件要求。

#### 复杂度分析

- 时间复杂度：$O(n \log n)$，其中 n 为 数组的长度。排序需要的时间为 $O(n \log n)$，二分查找的时间复杂度为 $O(\log n)$。

- 空间复杂度：$O(\log n)$。排序需要的栈空间为 $O(\log n)$。


