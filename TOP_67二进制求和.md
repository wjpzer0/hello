#### 题目

给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 1 和 0。

示例 1:
输入: a = "11", b = "1"
输出: "100"

示例 2:
输入: a = "1010", b = "1011"
输出: "10101"

提示：
每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零

#### 我的解法

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        numa = int(a, 2)
        numb = int(b, 2)
        num = numa + numb
        return bin(num)[2:]
```

使用内置函数

#### 其他解法

###### 模拟

```java
StringBuilder ans = new StringBuilder();
int ca = 0; //是否进一位 
for (int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0; i--, j--) {
    int sum = ca;
    sum += (i >= 0 ? a.charAt(i) - '0' : 0); 
    // 获取字符串a对应的某一位的值 当i<0是 sum+=0（向前补0） 否则取原值 ‘1’的char类型和‘0’的char类型刚好相差为1
    sum +=( j >= 0 ? b.charAt(j) - '0' : 0);
    // 获取字符串a对应的某一位的值 当i<0是 sum+=0（向前补0） 否则取原值 ‘1’的char类型和‘0’的char类型刚好相差为1
    ans.append(sum % 2);  
    // 如果二者都为1  那么sum%2应该刚好为0 否则为1
    ca = sum / 2;   
    // 如果二者都为1  那么ca 应该刚好为1 否则为0
}
ans.append(ca == 1 ? ca : "");
// 判断最后一次计算是否有进位  有则在最前面加上1 否则原样输出
return ans.reverse().toString();
```

**思路**
整体思路是将两个字符串较短的用 0 补齐，使得两个字符串长度一致，然后从末尾进行遍历计算，得到最终结果。
本题解中大致思路与上述一致，但由于字符串操作原因，不确定最后的结果是否会多出一位进位，所以会有 2 种处理方式：
第一种，在进行计算时直接拼接字符串，会得到一个反向字符，需要最后再进行翻转
第二种，按照位置给结果字符赋值，最后如果有进位，则在前方进行字符串拼接添加进位
时间复杂度：O(n))

###### 位运算

```python
class Solution:
    def addBinary(self, a, b) -> str:
        x, y = int(a, 2), int(b, 2)
        while y:
            answer = x ^ y
            carry = (x & y) << 1
            x, y = answer, carry
        return bin(x)[2:]
```

**思路和算法**
我们可以设计这样的算法来计算：
把 a 和 b转换成整型数字 x 和 y，在接下来的过程中，x 保存结果，y 保存进位。
当进位不为 0 时
计算当前 x 和 y 的无进位相加结果：answer = x ^ y
计算当前 x 和 y 的进位：carry = (x & y) << 1
完成本次循环，更新 x = answer，y = carry
返回 x 的二进制形式
为什么这个方法是可行的呢？在第一轮计算中，answer 的最后一位是 x 和 y 相加之后的结果，carry 的倒数第二位是 x 和 y最后一位相加的进位。接着每一轮中，由于 carry 是由 x 和 y 按位与并且左移得到的，那么最后会补零，所以在下面计算的过程中后面的数位不受影响，而每一轮都可以得到一个低 ii 位的答案和它向低 i + 1i+1 位的进位，也就模拟了加法的过程。

**复杂度分析**
时间复杂度：O(∣a∣+∣b∣+X⋅max(∣a∣+∣b∣))，字符串转化成数字需要的时间代价为 O(∣a∣+∣b∣)，计算的时间代价为 O(max{∣a∣,∣b∣})，X 为位运算所需的时间，因为这里用到了高精度计算，所以位运算的时间不一定为 O(1)。
空间复杂度：这里使用了 xx 和 yy 来保存 a 和 b 的整数形式，如果用 Python 实现，这里用到了 Python 的高精度功能，实际的空间代价是 O(|a| + |b|)。



